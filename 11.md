# Chapter 11: Token-Based Authentication

We have reached a point where our application could benefit from some persistent state.  I would like to implement features to return readers to their last reading location, or to the last location read on a different device.  First, we need persistent storage extending beyond a single sessionor device.  It is time to introduce user authentication.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch11-starter
```

## The Compounding Complexities of Authentication

I confess, I rather loathe designing authentication for my applications.  Authentication systems tend to be involved undertakings, and extremely prone to scope creep.

Assume we're building the simplest possible authentication system.  Right out of the gate, we need a model for users, and all its usual CRUD actions; registration pages, a login page, a user profile page, and probably some admin pages.  

Don't forget users are sure to forget their passwords, so we need a password reset page.  That requires some secondary verification of user identity.  So now my application needs to send emails or text messages, so I guess I'll be configuring a mailserver now.  Oh, and we need views for our password recovery process; one page to request a reset, and another to set a new password!

Nevermind the fact that logging in doesn't **DO** anything valuable for our users.  Users don't benefit from authentcation until we build something on top of it.  The entire login process itself, is just boilerplate.  Something to get out of the way before we can move on to better things.

## Planning our Iteration

Trying to avoid as many possible headaches as we can, I have settled on the use of a third party authentication provider.  Using OAuth; we can let someone else can handle registration, account recovery, and account updates.  To say nothing of information security.

Leaving us to focus as tightly as possible on the one feature we need for our application, identity verification.  All while giving our users a better experience as well.

Although I try to give an introduction, if you haven't worked with OAuth before, familiarizing yourself with the process might help.  [Digital Ocean's excellent article on OAuth2](https://www.digitalocean.com/community/tutorials/an-introduction-to-oauth-2) is a helpful summary of the basics.

We are using an Authorization Code authentication pattern for our application.  This pattern requires a server-side application layer, and would not be appropriate for pure client-side applications because it relies on the use of secret keys.

Here is a simple process flow for this pattern:
1. A user comes to our site and signs in.
2. Our application redirects to a 3rd party authenticator.
3. The authenticator verifies the user's identity (login).
4. The user is asked to approve our application's access level.
5. After approval, users redirect to our application with a code from the authenticator
6. Our server validates this code using a secret key (provided previously by the authenticator).
7. Our application responds with the code, and a client ID identifying our application
8. The authenticator validates our request, responding with an access token dictating our permisssions
9. Our server uses this token to query the authenticator for any desired information about the user.
10. Login creates a user record in our database, or fetches an existing record.
11. An internal token is created for the user by our server and sent to the client.
12. Our client uses this token to authentcate future actions in our application.

That list of steps might seem more complex than designing our own authentication.  However, what's not on the list makes a big difference.  If users need to update accounts, recover passwords, or register, they do so with the authenticator.  All we care about is proving their identity.

There is no shortage of OAuth2 providers.  The big names are Google and Facebook, but given our target audience, I am choosing to use GitHub.  Many applications support several providers, and perhaps also roll their own auth systems as an alternative.  

My thoughts on roll-your-own systems are clear at this point.  However, using multiple OAuth providers is also problematic.  If I used GitHub authentication last visit, and Google today, suddenly I have two accounts on the service.  Designers try mitigating this problem by having users link several accounts during signup.  Or, by merging records after several authentication services have created fractured accounts for a user.

I prefer to avoid the whole mess.  I am willing to wager most users in my target audience have Github accounts.  If not, they can decide whether they would like to create one to access our service's authenticated features.

## OAuth Provider Registration

Before we begin, we need to register our application with GitHub to create the secret keys required for authentication.  

You need to register for [Github's developer program](https://github.com/developer/register).

Inside your account settings, you have the option to [manage developer settings](https://github.com/settings/developers).

When you make it this far, click the link to register a new OAuth application.

![Create a New OAuth Application](/images/11/RegisterOAuth.png)

The most important parts of this are your homepage and a callback URL.  The callback URL is where GitHub directs users after successful sign in and approving your application's access to their data.  This URL is where our application regain control and finishes the authentication handshake.  Since this is an API route, I am setting my callback URL as `/api/github` so it is consistent with our existing routes.

![Configure New OAuth Application](/images/11/RegisterOAuth2.png)

Now we have what we need to begin configuring our application.

## Managing Sensitive Keys

Before continuing, we need a way to manage secure keys.  Our application security relies on the secret keys provided by GitHub remaining a secret.  

These values must never be committed to our project repositories.  That means keeping these keys out of our source code.  A task for which environment variables are well-suited.

I am using a gem `dotenv` to manage environment variables for our application.  `dotenv` allows us to define all of the variables needed in our application inside a file named `.env`.  The gem automatically loads these variables for us and makes them available throughout our rails application.

To begin the setup, add `dotenv` to your project's gemfile.

``` ruby(/api/Gemfile)
source 'https://rubygems.org'

git_source(:github) do |repo_name|
  repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include?("/")
  "https://github.com/#{repo_name}.git"
end


# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
gem 'rails', '~> 5.1.3'
# Use sqlite3 as the database for Active Record
gem 'sqlite3'
# Use Puma as the app server
gem 'puma', '~> 3.7'
# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
# gem 'jbuilder', '~> 2.5'
# Use Redis adapter to run Action Cable in production
# gem 'redis', '~> 3.0'
# Use ActiveModel has_secure_password
# gem 'bcrypt', '~> 3.1.7'

# Use Capistrano for deployment
# gem 'capistrano-rails', group: :development

# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible
# gem 'rack-cors'

gem 'commonmarker'
+ gem 'dotenv-rails'

- group :development, :test do
-   # Call 'byebug' anywhere in the code to stop execution and get a debugger console
-   gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
-   gem 'rspec-rails', '~> 3.6'
- end

- group :development do
-   gem 'listen', '>= 3.0.5', '< 3.2'
-   # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
-   gem 'spring'
-   gem 'spring-watcher-listen', '~> 2.0.0'
-   gem 'foreman', '~> 0.82.0'
-   gem 'annotate'
- end

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]
```

Once that is done, go ahead and run `docker-compose exec api bundle install`.

Next we need to provide a `.env` file.  To do this though, I am actually creating two files.  It would do little good to offload our sensitive keys into environment variables if we then commit a list of those keys to our repo anyhow.  Because of this, `.env` should be added to our `.gitignore` file.  However, I find it helpful to commit a template listing the environment variables my application **should** define.  That way I have a guide for expected variables I need when deploying my application.

To begin, add `.env` to your git ignore (if you are tracking this project in your own repo).

Then define the following file.

``` bash(/api/.env-template)
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
```

I allow this template file to be committed, but never to contain secure values.  When I deploy, I copy this template, renaming the file to `.env`, and populating each value. Do that now, filling in the client ID and secret provided by GitHub when you registered your OAuth application.

## Authentication Step by Step

We now have the foundation in place we need to start building our authentication system.  This iteration is involved, but luckily we can break this into a few smaller chunks of work.

### Steps 1 - 4: Logging in from our UI

Looking at our list of authentication steps above, we first need to handle creating a control in our UI to allow users to begin authentication.  We do this with a simple button on our application's menu.

Open our menu bar component, and make the following changes.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
+ import { Container, Image, Menu, Icon } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

import { ConnectedChapterMenuItems } from '../containers/chapter_provider';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   paddingTop: "13px",
-   paddingBottom: "13px"
- };

- const tightItem = {
-   paddingTop: "0",
-   paddingBottom: "0"
- }

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          stackable
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container textAlign="center">
            <Menu.Item className="banner" style={tightItem}>
              <Image size='mini' src={reactLogo} />
              <Image size='mini' src={railsLogo} />
              <Menu.Item header>Reactivating Rails: A work in progress</Menu.Item>
            </Menu.Item>

            <Menu.Menu position='right' style={tightItem} value={this.props.active_chapter}>
              <ConnectedChapterMenuItems />
+               <Menu.Item href="https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52" name='Sign in with GitHub'>
+                 <Icon name='github' size="big" />
+               </Menu.Item>
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Since GitHub handles most of the actual authentication UI, all we need to own is a link that takes our users off-site to authorize our application.  We are using a simple GitHub Icon, linked to an authorization page.  Notice I am also passing a GET parameter in the URL, containing my client ID (you need to update this with your unique client ID if you are following along).

Render this update, and click the new link.  You should be directed to a login page on GitHub, asking the user to authorize your application's access.

We are not requesting any additional permissions/scopes in our authorization link, so this request only gains us access to the user's public profile.  Luckily, that is all we need.

![Authorize Apllication Page](/images/11/AuthorizeApplication.png)

If you complete the authorization; GitHub attempts to redirect you to the URL you defined in your application setup.  In my case, that brings us to `http://138.197.14.5:3000/api/github`.

### Step 5: Beginning the Authentication Handshake

Now we need to update our Rails application to be ready to receive this route when Github redirects users our way.

That means we are going to need a new controller for this action.  Let's generate that now.

```
rails generate controller api/authentication github 
```

Most of that generated content works just fine for our needs.  However, we should adjust the route path a bit.

``` ruby(/api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
+     get 'github/', to: "authentication#github"
    get 'nodes/', to: "nodes#index"
    get 'chapters/', to: "chapters#index"
  end
end
```

With our route in place, let's turn our attention to setting up our controller action.

### Steps 6 - 8 verifying the Github Credentials

We are going to use a gem `github_api` to simplify our interactions with the Github OAuth service.  Add the gem to your gemfile, and bundle install.

``` ruby(/api/Gemfile)
source 'https://rubygems.org'

git_source(:github) do |repo_name|
  repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include?("/")
  "https://github.com/#{repo_name}.git"
end


# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
gem 'rails', '~> 5.1.3'
# Use sqlite3 as the database for Active Record
gem 'sqlite3'
# Use Puma as the app server
gem 'puma', '~> 3.7'
# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
# gem 'jbuilder', '~> 2.5'
# Use Redis adapter to run Action Cable in production
# gem 'redis', '~> 3.0'
# Use ActiveModel has_secure_password
# gem 'bcrypt', '~> 3.1.7'

# Use Capistrano for deployment
# gem 'capistrano-rails', group: :development

# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible
# gem 'rack-cors'

gem 'commonmarker'
gem 'dotenv-rails'
+ gem 'github_api'

- group :development, :test do
-   # Call 'byebug' anywhere in the code to stop execution and get a debugger console
-   gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
-   gem 'rspec-rails', '~> 3.6'
- end

- group :development do
-   gem 'listen', '>= 3.0.5', '< 3.2'
-   # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
-   gem 'spring'
-   gem 'spring-watcher-listen', '~> 2.0.0'
-   gem 'foreman', '~> 0.82.0'
-   gem 'annotate'
- end

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]
```

When the user authorizes our application on Github, they redirect to the callback URL we provided when we set up our application. 

After logging in to GitHub, our users hit the authentication#github controller action we set up a route for in the previous step.  The redirect back to our server from GitHub also contains a single `code` parameter as part of the request.  We use this code in combination with our secret key to confirm this is a legitimate request, and request an access token from the GitHub API.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
  end
end
```

We read the code from our parameters, and then instantiate a new Github class instance provided by the `github_api` gem.  Creating that instance requires passing in our client secret and client id.  We then use the `get_token` method to validate the code given to us by GitHub is legitimate, and if so trade it for an access token for the GitHub API.

### Step 9: Retrieving the User's GitHub Profile

Now that we have an access token for the user we can make an API request for their public profile.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
+     github_users = Github::Client::Users.new oauth_token: token
+     user = github_users.get
  end
end
```

This simple query allows us to return the authenticated user's public profile, which includes all of the information we need to setup or fetch our internal record for the user.  Before we can move forward though, we need a User model.

### Step 10: Create or Fetch the Internal User

Let's generate a model to store our user records.  For a starting point, I am going to store; the GitHub user ID, the user's profile email address, the username/login, and an avatar URL if available.

```
bin/rails generate model user github_id:integer github_email:string username:string avatar:string
```

Now let's create a method on our user model to fetch or create a new user record as part of our sign-in process.

``` ruby(/api/app/models/user.rb)
# == Schema Information
#
# Table name: users
#
#  id           :integer          not null, primary key
#  github_id    :integer
#  github_email :string
#  username     :string
#  avatar       :string
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#

class User < ApplicationRecord
  def self.create_or_fetch(user)
    find_by(github_id: user.id) || create(
      github_id: user.id,
      github_email: user.email,
      username: user.login,
      avatar: user.avatar_url
    )
  end
end
```

Our `create_or_fetch` method lives up to its name, either using the GitHub user ID to fetch a previously created record, or returning a new one.

All we need to do now is update our controller to make use of this method.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
+     user = User.create_or_fetch(github_users.get)
  end
end
```

### Step 10: Generate an Internal Token for the User

Now that we have the record information we need from Github's API we do not have any need of our GitHub authentication token any longer.  Instead, we can now transition to using an internal token format to authenticate ongoing requests from our user.  This token is what we persist in our client-application if we want to preserve user sessions beyond the life of a single browser window.

We can use a JSON Web Token (JWT) for this internal token to store our Active Record ID for the user.  That allows us to quickly fetch the user's full profile when needed for future requests.

To get started, we again need to install a gem.

``` ruby(/api/Gemfile)
source 'https://rubygems.org'

git_source(:github) do |repo_name|
  repo_name = "#{repo_name}/#{repo_name}" unless repo_name.include?("/")
  "https://github.com/#{repo_name}.git"
end


# Bundle edge Rails instead: gem 'rails', github: 'rails/rails'
gem 'rails', '~> 5.1.3'
# Use sqlite3 as the database for Active Record
gem 'sqlite3'
# Use Puma as the app server
gem 'puma', '~> 3.7'
# Build JSON APIs with ease. Read more: https://github.com/rails/jbuilder
# gem 'jbuilder', '~> 2.5'
# Use Redis adapter to run Action Cable in production
# gem 'redis', '~> 3.0'
# Use ActiveModel has_secure_password
# gem 'bcrypt', '~> 3.1.7'

# Use Capistrano for deployment
# gem 'capistrano-rails', group: :development

# Use Rack CORS for handling Cross-Origin Resource Sharing (CORS), making cross-origin AJAX possible
# gem 'rack-cors'

gem 'commonmarker'
gem 'dotenv-rails'
gem 'github_api'
+ gem 'jwt'

- group :development, :test do
-   # Call 'byebug' anywhere in the code to stop execution and get a debugger console
-   gem 'byebug', platforms: [:mri, :mingw, :x64_mingw]
-   gem 'rspec-rails', '~> 3.6'
- end

- group :development do
-   gem 'listen', '>= 3.0.5', '< 3.2'
-   # Spring speeds up development by keeping your application running in the background. Read more: https://github.com/rails/spring
-   gem 'spring'
-   gem 'spring-watcher-listen', '~> 2.0.0'
-   gem 'foreman', '~> 0.82.0'
-   gem 'annotate'
- end

# Windows does not include zoneinfo files, so bundle the tzinfo-data gem
gem 'tzinfo-data', platforms: [:mingw, :mswin, :x64_mingw, :jruby]

```

Similar to our work with Github's OAuth tokens, encoding and decoding our JWT strings rely on the use of secret key encryption.  We need to treat our JWT secret keys with the same level of care as our Github keys and ensure they do not get committed to our repositories.  I recommend adding the value to your `.env` file and template.  In this instance, you are free to generate your own random string to serve as your secret key.

We are also going to encode an issuer URL into our token to ensure the origin matches when we decode the token on subsequent requests.

``` bash(/api/.env-template)
GITHUB_CLIENT_ID=
GITHUB_CLIENT_SECRET=
JWT_SECRET=
CLIENT_URL=http://138.197.14.5
```

We are going to need to leverage our encoding and decoding logic for tokens from several parts of our application.  Externalizing this process into its own class helps keep our code DRY.

Set up a new module in your controller concerns.

``` ruby(/api/app/controllers/concerns/token_ops.rb)
module TokenOps
  extend ActiveSupport::Concern
  def self.encode(user)
    payload = {
      iss: ENV['CLIENT_URL'],
      id: user.id,
      exp: 30.days.from_now.to_i,
      iat: Time.now.to_i
    }
    JWT.encode payload, ENV['JWT_SECRET'], 'HS256'
  end

  def self.decode(token)
    options = {
      iss: ENV['CLIENT_URL'],
      verify_iss: true,
      verify_iat: true,
      leeway: 30,
      algorithm: 'HS256'
    }
    JWT.decode token, ENV['JWT_SECRET'], true, options
  end
end
```

We are encoding only our client ID into this token, along with some other items to help us control or authenticate the token.  We only decode this token on the server-side, so we need to execute some other steps if we want to fetch the user's full profile through to the client.  This token only exists to validate which user we are are receiving requests from on our server.

### Step 11: Providing the Token to Our Client

Now, let's upgrade our controller again to build out our token.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
+   include TokenOps
  
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
    user = User.create_or_fetch(github_users.get)
+     jwt = TokenOps.encode(user)
    
+     redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}", status: 200
  end
end

```

I now include our TokenOps module in this controller to gain access to the encode and decode functions we need to manage our tokens.  We are passing the returned User record into our token encoder and allowing it to build our JWT token.  Then we are redirecting back to the client at a new `/auth/:token` route we have not yet defined.

We use this new route to pass the token into our client environment, and execute a saga to complete user authentication.

### Step 12: Completeing the client-side authentication

The redirect from our server lands us back in our client environment.  However, we still need to translate our JWT token into the user profile information we need to personalize our UI.

We need to prepare to handle this new client-side route.  First, you can create your constants.

``` javascript(/client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
export const AUTH_ROUTE = "AUTH_ROUTE";
```

Then we need to define this route in our store settings.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import createSagaMiddleware from 'redux-saga'
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';
import alerts from './alerts';
import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
+   [ROUTES.AUTH_ROUTE]: "/auth/:token"
};

const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = connectRoutes(
  history,
  routeMap,
  { restoreScroll: restoreScroll(), initialDispatch: false }
);

const reducers = combineReducers({location: routeReducer, settings, nodes, chapters, alerts});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

const store = createStore(
  reducers, composeWithDevTools(routerEnhancer, middlewares)
);

sagaMiddleware.run(rootSaga);
initialDispatch();

export default store;
```

Now we can go ahead and define a saga to handle the client side of our authentication process.  As you define this saga, **do not forget to add it to your root saga!**

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { routeHome } from '../actions/routes';

export function* hydrateUser(action){
  yield put(routeHome());
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    console.log(user.data);
  } catch(e){
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

Our `hydateUser` saga fires in response to the `/auth/:token` route on our client.  The saga itself does not differ much from sagas we have seen previously, except that we are leveraging the watched action itself inside our saga.  In this case, we take then token sent as part of our route action's payload and use it to call our API with a request for the user's profile.

Remember we are only decoding our JWT token's server-side, so we need to call to our API to fetch the user information we need.

For now, I have commented out a mock call to `someUserLoadAction` as a placeholder for my future intent of this saga.  We need to set up another API action to complete this hydration before we are ready for that step.

### Wrapping Up our Simple Authentication

I want to take a pause here to point out that we have met the necessary criteria of the authentication schema we have outlined previously.  We have gone through all the steps of trading tokens, following redirects, and querying APIs it takes to get a  proof of our user's identity.  We have dealt with many moving pieces, and I have intentionally kept this first pass simple in the hopes it will making understanding the process flow easier to follow.

Now that the groundwork is out of the way though, there are some things I want to go back and improve.

## Token Lifespan and Visibility

First, I want to adjust the lifespan of our JWT token, and transition to using two separate tokens.  We are relying on URL parameters to pass our JWT token between our server and client.  That is a highly visible place to store a sensitive piece of information; it winds up in our logs, the user's browser history, and who knows where else.  That is not ideal for a token that grants 30 days of access to a user's account.

So I am going to upgrade my internal tokens so that the token used in my routes has a shorter two-minute lifespan.  Then we can issue a long-life persistent token as part of our user's profile hydration when the client requests other user details.  We can then limit the use of this long-life token to our request headers, so it is not as visible as its short-lived counterpart. 

> Note: A more secure approach still would be to seed our short-life token with a random string of characters, and limit that token to a single use.  This process would involve storing this random seed in the user's database record as we create the token.  When exchanging for a long-life token, we could then check the seed value in the short-term matches the current value stored for the user, and invalidate any request that did not match.  For the sake of simplicity in our examples, I am settling on a simple time-based expiration

Let's upgrade our `TokenOps module to accommodate this.

``` ruby(/api/app/controllers/concerns/token_ops.rb)
module TokenOps
  extend ActiveSupport::Concern
+   def self.encode_short(user)
+     short_payload = token_payload(2.minutes.from_now.to_i, user)
+     JWT.encode short_payload, ENV['JWT_SECRET'], 'HS256'
+   end
  
+   def self.encode_long(user)
+     long_payload = token_payload(30.days.from_now.to_i, user)
+     JWT.encode long_payload, ENV['JWT_SECRET'], 'HS256'
+   end

  def self.decode(token)
    options = {
      iss: ENV['CLIENT_URL'],
      verify_iss: true,
      verify_iat: true,
      leeway: 30,
      algorithm: 'HS256'
    }
    JWT.decode token, ENV['JWT_SECRET'], true, options
  end

+   private
+     def self.token_payload(expires, user)
+       {
+         iss: ENV['CLIENT_URL'],
+         id: user.id,
+         exp: expires,
+         iat: Time.now.to_i
+       }
+     end
end
```

Now we can choose which type of token we issue inside of our controller according to our needs.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
    user = User.create_or_fetch(github_users.get)
+     jwt = TokenOps.encode_short(user)
    
    redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}", status: 200
  end
end
```

## Hydrating the Client-Side User

Now that we are set up to issue our long-term token, I think we are ready to commit this information to our store and "complete" the sign in process.  Let's start by setting up an `fsa` scope on our user model to limit what we pass back to the client for our users.

``` ruby(/api/app/models/user.rb)
# == Schema Information
#
# Table name: users
#
#  id           :integer          not null, primary key
#  github_id    :integer
#  github_email :string
#  username     :string
#  avatar       :string
#  created_at   :datetime         not null
#  updated_at   :datetime         not null
#

class User < ApplicationRecord
+   def fsa(token)
+     {
+       id: id,
+       github_email: github_email,
+       username: username,
+       avatar: avatar,
+       token: token
+     }
+   end
  
  def self.create_or_fetch(user)
    find_by(github_id: user.id) || create(
      github_id: user.id,
      github_email: user.email,
      username: user.login,
      avatar: user.avatar_url
    )
  end
end

```

I am taking a different approach to my "scope" here, and setting it up as an instance method for our User model.  We want to issue a new long-term token when we hydrate our user on the client.  Since `token` is not part of our Active Record association, we need our scope method to accept outside data when formatting our return payload.  This approach allows us to preserve the `fsa` interface on the class we are using in our other models.

Now, let's set up a route for this action.

``` ruby(/api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
    get 'github/', to: "authentication#github", format: false
+     get 'hydrate_user/', to: "authentication#show"
    get 'nodes/', to: "nodes#index"
    get 'chapters/', to: "chapters#index"
  end
end

```

Now we can build the matching controller action.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    code = params[:code]
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
    user = User.create_or_fetch(github_users.get)
    jwt = TokenOps.encode_short(user)
    
    redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}", status: 200
  end
  
+   def show
+     token = params[:token]
+     user_id = TokenOps.decode(token)[0]["id"]
+     user = User.find(user_id)
+     long_token = TokenOps.encode_long(user)
+     
+     render json: user.fsa(long_token), status: 200
+   end
end
```

Our show action takes the short-term token passed through our URL and uses it to verify the record we need to access.  Decoding the token grants us a user ID which we can use to locate our database record.  Then, we encode that returned user again, this time creating a long-term token with a 30-day duration.  This controller action is the only time we use our a URL based JWT token to authenticate a user, going forward the long-term token can be sent with our request headers when targetting the authenticated actions of our controllers.  (Once we have some authenticated actions)

Now we can finish out our saga by setting up our Store with a reducer to handle this user information.  For brevity's sake, I am going to assume we have covered reducer setup enough not to talk through this in detail.  However, our new files are included here for those following along with a build.  **Be sure to also add this new reducer to your store/combineReducers function (not shown).**

``` javascript(/client/src/constants/user.js)
export const SET_USER = "SET_USER";
export const CLEAR_USER = "CLEAR_USER";
```

``` javascript(/client/src/actions/user.js)
import * as constants from "../constants/user";

export const setUser = (payload) => ({
  type: constants.SET_USER, payload
});

export const clearUser = () => ({ type: constants.CLEAR_USER }) ;
```

``` javascript(/client/src/actions/user.spec.js)
/* global expect */
import * as actions from './user';

let test_user = {
  avatar: "https://avatars0.githubusercontent.com/u/shiba",
  github_email: "awesome@wow.com",
  id: 9000,
  token: "wow.much.secret",
  username: "doge"
};

describe("User actionCreators", ()=>{
  test("setUser() assigns active user", () =>{
    expect(actions.setUser(test_user)).toMatchSnapshot();
  });

  test("clearUser wipes user", () =>{
    expect(actions.clearUser()).toMatchSnapshot();
  });
});
```

``` javascript(/client/src/reducers/user.js)
import * as constants from '../constants/user';
const default_state = {};

const userReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.SET_USER):
      return {...action.payload};
    case(constants.CLEAR_USER):
      return {};
    default:
      return state;
  }
};

export default userReducer;
```

``` javascript(/client/src/reducers/user.spec.js)
/* global expect */
import  userReducer from './user';
import * as actions from '../actions/user';

let defaultState = {};
let exampleState = {
  avatar: "https://avatars0.githubusercontent.com/u/shiba",
  github_email: "awesome@wow.com",
  id: 9000,
  token: "wow.much.secret",
  username: "doge"
};

describe("User reducer", ()=>{
  test("SET_USER populates user object",()=>{
    let fsa = actions.setUser(exampleState);
    expect(userReducer(defaultState,fsa)).toEqual(exampleState);
  });
  
  test("CLEAR_USER empties user object", () =>{
    expect(userReducer(exampleState, actions.clearUser())).toEqual(defaultState);
  });
});
```

### Resolving our User Hydration Saga

Now that our store is set up with our new reducer, we can finish out the green path of our `userHydration` saga.  We are going to dispatch two actions on successful hydration; populating the user key of our store, and delivering an alert to the user confirming their login.

``` javascript(/client/src/sagas/hydrate_user.js)
+ import { takeLatest, put, call, all } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import { addAlert } from '../actions/alerts';

export function* hydrateUser(action){
  yield put(routeHome());
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
+     yield all([
+       put(setUser(user.data)),
+       put(addAlert("Sign in successful, welcome " + user.data.username + ".","success"))
+     ]);
  } catch(e){
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

## Updating Our Authenticated UI

Now that the user retrieval is complete, we need to create some UI updates to illustrate the change to our users.  I am going to set up the user's avatar URL to replace our GitHub badge after sign-in.  We can also add a small dropdown to contain a sign-off link.

Since our profile badge now needs to track the state of our user's authentication, it is time to split this off into its own component.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Icon, Dropdown } from 'semantic-ui-react';

class UserBadge extends Component {
  render() {
    if(!this.props.username){
      return (
        <Menu.Item href="https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52" name='Sign in with GitHub'>
          <Icon name='github' style={{marginRight: 0}} size="big" />
        </Menu.Item>
      );
    } else {
      let badge = <Image src={this.props.avatar} avatar />;
      return (
        <Menu.Item name={this.props.username}>
          <Dropdown icon={badge} compact pointing="top right">
            <Dropdown.Menu>
+               <Dropdown.Item onClick={this.props.dispatchClearUser}>Sign Out</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </Menu.Item>
      );
    }
  }
}

export default UserBadge;
```

We are using the presence of a defined username to determine if we should throw the github badge or a similar icon built from the user's GitHub avatar.  This component is also where we build our sign-out link for future use.

We still need to map in the props our component needs.  I am going to echo the pattern we used in `ChapterProvider` to setup a factory to build connected components for our user state.

``` javascript(/client/src/containers/user_provider.js)
import { connect } from 'react-redux';

import UserBadge from '../components/user_badge';
import { clearUser } from '../actions/user';

export const connectToUser = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
};

const mapStateToProps = (state) => ({
  username: state.user.username,
  avatar: state.user.avatar
});

const mapDispatchToProps = (dispatch) => ({
+   dispatchClearUser: (e) => dispatch(clearUser())
});

// EXPORTABLE CONNECTED COMPONENTS
+ export const ConnectedUserBadge = connectToUser(UserBadge);
```

Along with our user's authentication state, we are also connecting a clear user action.  We do not really need a server-side sign out action at this point.  The lack of a token on future visits makes our visitor unable to make authenticated requests.  So if we nuke the token client-side, we are signed out.

Now we should update our menu bar accordingly.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

import { ConnectedChapterMenuItems } from '../containers/chapter_provider';
+ import { ConnectedUserBadge } from '../containers/user_provider';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   paddingTop: "13px",
-   paddingBottom: "13px"
- };

- const tightItem = {
-   paddingTop: "0",
-   paddingBottom: "0"
- }

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          stackable
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container textAlign="center">
            <Menu.Item className="banner" style={tightItem}>
              <Image size='mini' src={reactLogo} />
              <Image size='mini' src={railsLogo} />
              <Menu.Item header>Reactivating Rails: A work in progress</Menu.Item>
            </Menu.Item>
            <Menu.Menu position='right' style={tightItem} value={this.props.active_chapter}>
              <ConnectedChapterMenuItems />
+               <ConnectedUserBadge />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

We now have a functioning sign out link in our UI and an updated UI for our authenticated users.  There are some worts on this design.  For one thing, since our sign in and sign out changes are not route changes there's nothing in our application that clears our alert messages until the user navigates to a new page.  We should address this before moving on.

My first idea was to retool our signout action as a route change.  We already have a saga in place that's listening to route changes and clearing our alert object.  It is tempting to connect to this existing setup, so all our alert clears rely on the same architecture.  The problem is, I do not want the signout action added to my user's history.  Thinking about it, having the ability to "back" button your way to the signout action does not really help our users, and might, in fact, cause problems.  Moreover, if we change a route, we also need to control the window scroll somehow, so the user does not lose place while reading.  I do not want to fix one annoyance, only to create myself another.

So instead I am inclined to manage the alert clear through a saga.  Since we have a `hydrateUser` saga managing sign in, adding a `dehydrateUser` saga for signout still gives our design a predictable symmetry.

``` javascript(/client/src/sagas/dehydrate_user.js)
import { takeLatest, put, all, call } from 'redux-saga/effects';
import { delay } from 'redux-saga';

import * as actions from '../constants/user';
import { addAlert, clearAlerts } from '../actions/alerts';

export function* dehydrateUser(action){
  try{
    yield all([
      put(clearAlerts()),
      put(addAlert("Sign out successful","danger"))
    ]);
    
+     yield call(delay,3000);
+     yield put(clearAlerts());
  } catch(e){
    // We need some error handling
  }
} 

export function* watchSignOut(){
  yield takeLatest(actions.CLEAR_USER, dehydrateUser);
};
```

We are introducing a new utility function for Redux Saga, `delay` which as the name suggests, introduces a delay to our saga execution.  We can use this to place a 3-second timer to clear our alert messages from the screen.  Go ahead and add similar code to the `hydrateUser` action so that alert does not linger endlessly on the screen.

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call, all } from 'redux-saga/effects';
+ import { delay } from 'redux-saga';
import axios from 'axios';

import * as routes from '../constants/settings';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
+ import { addAlert, clearAlerts } from '../actions/alerts';

export function* hydrateUser(action){
  yield put(routeHome());
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    yield all([
      put(setUser(user.data)),
      put(addAlert("Sign in successful, welcome " + user.data.username + ".","success"))
    ]);
    
+     yield call(delay,3000);
+     yield put(clearAlerts());
  } catch(e){
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

That brings us to the end of our authentication setup.  Given the length of this chapter just laying out the groundwork for our authentication, we are going to split making our first authenticated requests off into its own chapter.  For the moment, we should fill in the gaps of our test suite before we wrap things up.

## Authentication Tests

Let's catch our test suite up with our current work.

### Client-Side Tests

Client-side we already setup reducer and action creators tests for our new `user` branch of our application state.  We should add in some tests for our two new sagas though `hydateUser` and `dehydrateUser`.  Since once again I am not introducing new testing methodologies with these tests, we are not going to cover them in detail.

``` javascript(/client/src/sagas/hydrate_user.spec.js)
/* global expect */
import { call, put } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axios from 'axios';

import { hydrateUser } from './hydrate_user';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import { clearAlerts } from '../actions/alerts';

describe("hydrateUser", () => {
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken" }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting HOME",() => {
    expect(saga.next().value).toEqual(put(routeHome()));
  });
  
  test("saga then trades temp token for long-term",() => {
    expect(saga.next().value).toEqual(call(axios.get, "/api/hydrate_user?token=" + action.payload.token));
  });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user).value["ALL"];
    expect(results[0]).toEqual(put(setUser(sample_user.data)));
    expect(results[1]["PUT"].action.type).toEqual("ADD_ALERT");
  });
  
  test("saga then delays and clears alerts after timer", ()=> {
    expect(saga.next().value["CALL"]["fn"]).toEqual(delay);
    expect(saga.next().value).toEqual(put(clearAlerts()));
  });
});
```

``` javascript(/client/src/sagas/dehydrate_user.spec.js)
/* global expect */
import { put } from 'redux-saga/effects';
import { delay } from 'redux-saga';

import { dehydrateUser } from './dehydrate_user';
import { clearAlerts } from '../actions/alerts';

describe("dehydrateUser", () => {
  let saga = dehydrateUser();

  test("saga by clearing old alerts and notifying of logout", ()=> {
    let results = saga.next().value["ALL"];
    expect(results[0]).toEqual(put(clearAlerts()));
    expect(results[1]["PUT"].action.type).toEqual("ADD_ALERT");
  });
  
  test("saga then delays and clears alerts after timer", ()=> {
    expect(saga.next().value["CALL"]["fn"]).toEqual(delay);
    expect(saga.next().value).toEqual(put(clearAlerts()));
  });
});
```

### Server-Side Tests

Much of our server-side authentication remains undeveloped.  Most notably, we don't have any error handling in place to resolve issues such as fraudulent tokens, expired credentials, or other critical failures.  However, before moving on, I think we should at least lay down some tests for our green path tests so that testing our authentication does not seem like an insurmountably large task when the rest of the system is in place.

To start, let's look at our `TokenOps` class.  

``` ruby()
require 'rails_helper'

RSpec.describe TokenOps do
  describe "encode" do
    it "provides an encode short and long term function" do
      expect(TokenOps.respond_to? :encode_short).to be true
      expect(TokenOps.respond_to? :encode_long).to be true
    end
    
    it "can decode a user's id" do
      user = User.create({
        github_id: "test",
        github_email: "test@test.com",
        username:"something_witty",
        avatar:"someimage.gif",
      })
      
      token = TokenOps.encode_short user
      decoded_id = TokenOps.decode(token)[0]["id"]
      expect(decoded_id).to eq user.id
    end
  end
end
```

Most of the logic in our encoding methods are handled by the jwt gem we are leveraging.  Since the gem itself is already tested I do not feel a need to cover these methods in details.  Instead, we can ensure that the TokenOps class responds to these methods, that way some alarms will at least ring if the interface of this class gets changed down the line.  Then our decoding tests can run a full encode/decode cycle to ensure we can move from raw data, to token, and then back.  We are also checking the critical `id` value is available in the decoded value.

Next up, our `User` model is the first we have written complex enough to leave me wanting some test coverage.

``` ruby(/api/spec/models/user_spec.rb)
require 'rails_helper'

RSpec.describe User, type: :model do
  before(:each) do
    @user = User.create({
        github_id: 2,
        github_email: "test@test.com",
        username:"something_witty",
        avatar:"someimage.gif",
      })
  end
  
  it "provides .fsa(token) to produce user FSA response object" do
   fsa = @user.fsa("sometoken")
   expect(fsa[:username]).to eq @user.username
   expect(fsa[:token]).to eq "sometoken"
  end
  
  describe "create_or_fetch" do
    it "creates a new user if one cannot be found" do
      User.create_or_fetch(OpenStruct.new({
        id: 1,
        email: "someone",
        username: "someoneelse",
        avatar: "someimage"
      }))
      
      expect(User.all.count).to eq 2
    end
    
    it "returns a recond by github_id if available" do
      requested_user = User.create_or_fetch(OpenStruct.new({id: 2}))
      expect(requested_user).to eq @user
      expect(User.all.count).to eq(1)
    end
  end
end
```

Tests for out `User` model check that the class provides an `fsa` interface consistent with our other models, and includes a token in the JSON created.  We should also have coverage for both scenarios our `create_or_fetch` function covers; creating new users as needed, or returning an existing record.

Finally we can turn to the `AuthenticationController` to test the two routes we created to manage the code & token exchange with Github to sign in our users.

``` ruby(/api/spec/controllers/api/authentication_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::AuthenticationController, type: :controller do
  describe "GET #github" do
    let(:sample_response) { OpenStruct.new({id: 1, email: "", login: "", avatar_url: ""}) }
   
    before(:each) do
      #create a stub for main Github API class.  Stub is then allowed to respond to 
      # .get_token(code).token chain of our controller with a fake token.
      github = double("github")
      class_double("Github", :new => github).as_stubbed_const(:transfer_nested_constants => true)
      allow(github).to receive_message_chain(:get_token, :token) { "fake token" }
      
      #Similar to above we mock the Client::Users class then allow the returned double
      #github_users to respond to #get with a mocked user profile response.
      @github_users = double("@github_users")
      allow(Github::Client::Users).to receive(:new) { @github_users }
      allow(@github_users).to receive(:get) { sample_response }
    end
    
    it "returns http success for new users" do
      get :github
      expect(response).to have_http_status(:success)
    end
    
    it "returns http success for existing users" do
      User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
      get :github
      expect(response).to have_http_status(:success)
    end
  end
  
  describe "GET #show" do
    it "returns a user profile" do
      user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
      token = TokenOps.encode_short(user)
      
      get :show, params: {:token => token}
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)).to include("id","username","github_email","token","avatar")
    end
  end
end 

```

Our authentication controller relies heavily on the github gem we're leveraging to communicate with the API.  Unfortunatly, since we don't want our tests to be firing off actual API requests, that leaves us needing to mock a fair bit of content.  To begin, we can setup a `class_double` for the `Github` class provided by our gem.  Using the `.as_stubbed_const(:transfer_nested_constants => true)` option will ensure this double replaces the preloaded class, and also supplies the nested modules we need as well.  This save use from needing to mock the `Github::Client` and `Github::Clients::Users` modules our controller leverages.

Our mocked Github class will in turn return a double when its `new` method is invoked.  Allowing this double to respond to the chain `.get_token(code).token` will ensure that we generate a stubbed token for the next step in our controller, even though we aren't supplying a legitimate code for the exchange.

Then our token exchange proceeds in much the same way, `Github::Client::Users` is allowed to send back yet another double `github_users` when its `new` method is invoked.  This new double responds to a `get` method and returns a mocked user profile.

All of this happens in our before block for our tests.  But the result serves my needs of limiting our controller tests to the scope of the application we actually control.   Thus, our actual tests/expectations are rather simple.  If we return an existing user from the API, we should see that user fetched from the database and returned.  Otherwise, we should see a new record created.

Finally, we need one last test for our `show` action, which we use to trade the short-term token for a long-term token.  Here we can easily just create a new user, build a token, and test the action's outcome.  We're expecting a 200 response, and doing some quick checks to ensure the critical data is present in our response.

## Wrapping Up

We now have a basic authentication system in place (granted with some limitations).  But we have made it through the entire OAuth handshake with GitHub.  We also setup an internal tokening system to track our own user records.  The client side was also upgraded to track a new user state in our store, and support sign-in and sign-out for our users.

Next chapter we'll take a step further and write our first authenticated actions by setting up some basic functionality to track the user's last-read chapter, or furthest read chapter of our book.  That will allow us to restore the reader's position on repeat visits to the site, and lay the groundwork for some more ambitious features in future iterations.