# Chapter 2: Installing React and Rails

In this chapter we will set up the client and server side frameworks, we will need for our application.  We will be discussing the differences in how our servers operate in development and production environments.  As well as some helpful toools we can lean on to keep our devlopment efforts easy and enyable.

## Rails New

We are going to start the installation process with the Rails side of our application.

If you have worked with Rails before, you are probably already familiar with this process.  What you may not be aware of, if you are venturing to use Rails 5 for the first time, is that we now have new generators available for bootstrapping API based applications.

The Rails side of our application is going to surrender the view layer to React completely.  Limiting the backend to an API interface alone helps us enforce this separation.  Bootstrapping the application as an API also leaves out many of Rail's modules that manage the View layer, but leaves the Model and Controller framework in place.

If you're following along, and want to ensure matching versions, at the time of writing, I am using:
* Ruby 2.3.1
* Rails 5.1.3

To create our application, enter the generator command:
`rails new [application name] --api --skip-test-unit` 

Or in my case:
`rails new reactive-api --api --skip-test-unit`

*Note: I plan to use Rspec for this application, so I have elected to skip the use of Test Unit.  If you prefer a different test framework you can, of course, adjust accordingly.*

Then you should switch to the directory and run bundle install:
`cd reactive-api && bundle install`

While bundler finishes its work, dive into the application directory, and have a look around.

## What Makes an API?

You need to be running Rails 5+ for the above *--api* flag to work correctly.  Using this flag removes a lot of overhead from our application we do not need.

**The API generator simplifies our asset pipeline, removing:**
* coffee-rails
* jquery-rails
* sass-rails 

The thought here is clear; we pass only JSON in our responses, so there's no need for the JavaScript libraries CoffeeScript or jQuery.  Also, similarly, the SASS processing of our CSS is now retired.  Note any of these tools might find their way into our client-side application, but the need for them might be less prevalent as React has more powerful native tools at its disposal.  For example, React itself is far better at managing state than Rail's use of jQuery.  The overrun use of jQuery responses in larger applications (lovingly referred to as "jQuery hell" by the Rails community) is what many developers hope to avoid by adopting a frontend UI framework.

Since React supports ES2015 syntax, the need for CoffeeScript is really a matter of preference.  My take is that the cleaned-up syntax of ES2015 is making the syntactic sugar supplied by CoffeeScript less and less of a draw.

The need for SASS is also less clear, as we may opt for storing our styles in the JavaScript syntax of our React components, greatly simplifying our application level CSS.

**Some other gems left behind:**
* **uglifier:** which handles the minification of our JavaScript assets.  We still get minification as part of our Webpack compiling when we run our React client in production, but our client, not server owns this process.
* **turbolinks:** Which speeds page loads in our rails applications by intelligently reloading only necessary contents of our pages on route changes, simulating single page applications.  React will be inheriting this role.

You might also notice the absence of a few standard folders from our newly generated application.

**Application folders MIA:**
* **app/assets, vendor/assets, and lib/assets:** No surprises here as we have ditched the asset pipeline.
* **app/helpers:** Gone with our view layer.  Keep in mind though that our `concerns/` folders remain in `models/concerns/` and `controllers/concerns/` for similar shared logic used in the Model or Controller layers.

Also, we have activated a few other convenience features:
* Our generators now detect that our application sets the flag `config.api_only = true` and will helpfully generate new application contents without producing views.
* There is also mention of a commented-out Gem, rack-cors in our Gemfile.  

> rack-cors simplifies the authorization of cross-origin request scripts (CORS).  CORS authorization is a necessary step whenever your API and the client operate on different origins (domains, sub-domains, or ports).  rack-cors helps you configure the bounds in which your API allows cross-origin requests, and handles the needed preflight requests accordingly.  It is a MASSIVELY helpful gem when you need to venture into the world of cross-origin requests.

Our application structure avoids the subject of CORS entirely.  Instead, Create React App uses a request proxying strategy when our application runs in development modes; negating the need for CORS.  

In production modes, Webpack can compile its production assets into the `public/` directory of our rails application.  The rails "homepage" `index.html` file thereby becomes the single page of our single page application, again bypassing the need for CORS requests in production as well.  Handy, no?

With that introduction behind us, let's turn to the client side for a moment.  

## Create React App

We are going to be using create-react-app (CRA) to bootstrap our client application.

There are no shortages of React starters out there.  You can find one pre-configured to meet most any needed combination of tools.  Unfortunately, the problem with most starters is that along with the libraries you want; you can probably count on two or three that are more in the "nice to have" bucket, and not the "need to have" bucket.  And then probably one or two more that are in the "what the hell does this thing do?" bucket.

Starters can be helpful as you gain experience; you find one that fits your style and learn to tweak it the last 10% it needs to be a perfect fit.

create-react-app (CRA), is a minimalist configuration maintained by the Facebook team.  CRA is geared entirely towards getting you started quickly with **React**, and it leaves the extensibility to you. Going through the process to install and configure the tools you use a few times helps you immensely when you decide to move on to more complex starters.  You can ignore this advice if you choose, just know that some members of the React community may make stern "tsk tsk" noises if you ever confess this sin to them. 

You can install create-react-app with NPM.  However, you need to set the global flag: 

`npm install -g create-react-app`

Then you can create a new application:

`create-react-app [name]`

In my case, I am going to use the imaginative name, reactive-client:

`create-react-app reactive-client`

> **Note:** I recommend executing this command outside of your Rails application folder hierarchy.  There's no need for the folders to be nested, and personally, I enjoy the clean separation of client side, and API application files.*

When the commands above are finished executing CRA has set up a new directory for your client-side project files.  If you open that new folder `reactive-client`, it contains a directory `node_modules`, that not surprisingly contains your node modules.  

There's also a `public` folder, which contains the root of our application, an `index.html` file.  This directory is also where all of our client-side scripts compile.  When running our application in production using compiled assets, CRA produces compiled javascript files, placing them into this directory, and then referencing them from our `index.html` file so that our application can bootstrap React.  When we set up our true production environment, this build process can be configured to happen in our Rails `public/` directory instead.  For now, we leave it as-is.

For now, the bulk of our work happens in the `src` directory.  If you open it, you should notice immediately how much less opinionated CRA is compared to Rails.  At the time of writing I have the following:

``` markdown
App.css                     Stylesheet for our starter App Component
App.js                      The starter component of our app
App.test.js                 Test suite smoke test
index.css                   Application level CSS
index.js                    JavaScript entry point to our application
logo.svg                    A stylish blue logo with swirlie bits
registerServiceWorker.js    Service worker manager
```

There are not many opinions enforced among these seven files.  If you are picking up React for the first time, but have worked with Rails for a while, then comparing React's somewhat loosely defined project structure might discomfort you at first.  Resist the urge to panic for now.  As we add complexity to our app, we can set conventions for file structures, and the concerns those files manage.

## Boot the server(s)

Now that we're installed, it's time to boot up our servers and make a quick health check.  Since we're already poking around in our client folders, let's start there.

Within your client folder, execute the command:
`npm start`

Your console should helpfully report that you can now view your app on localhost:[port].  Let's go check that out!

> **Note:** both Rails and CRA bind servers to ports defined in your application environment unless strictly told to do otherwise.  In my case, the use of port 8080 is the default, but your environment may vary.  Keep an eye on this if you struggle with examples.

![CRA Starter App Homepage](/images/1/CRAHomepage.png)

Nothing fancy, but we are looking good so far.  Let's demonstrate one thing before we move on.  Open `App.js`, and update its contents to the following:

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
+           <h2>Oh snap!</h2>
        </div>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

export default App;
```
As soon as you save the updated file, swap back to your browser, and avoid the deeply rooted reflex you have to mash `ctrl + r` to reload the page.  CRA will helpfully detect the updated file, and perform a hot reload for the refreshed contents.

![Updated CRA Starter App Homepage](/images/1/CRAHomepageHotReload.png)

This bit of convenience will be a huge boon to our productivity.  Now, we need to connect our Rails application to this development environment so we can enjoy this hot-reloading behavior as we work in development.  We want to enjoy the perks of hot reloading, but we must not wake the CORS dragon.

With confidence CRA has our client up and running, let's turn our attention to Rails.

Change to your Rails application directory, and start the server:
`bin/rails server`

Uhh oh, if you haven't tweaked your application configurations you may be greeted with a cheery error like this one:

```
/usr/local/rvm/gems/ruby-2.3.1@reactivating/gems/puma-3.9.1/lib/puma/binder.rb:269:in `initialize': Address already in use - bind(2) for "127.0.0.1" port 8080 (Errno::EADDRINUSE)
```
  
That is because we still have our client app running on port 8080, and Rails is trying to start Puma bound to that same address/port.  Open up Puma's configuration file, and we can trace where this error is originating.

``` ruby(/reactive-api/config/puma.rb)
# File example truncated
port        ENV.fetch("PORT") { 3000 }
```

This configures puma to check my local environment variables for a PORT setting.  If Puma finds no port assignment, it defaults 3000.

We can hunt out a similar setting inside CRA if we do a little digging.  We need to look inside CRA's main dependency; an npm package called `react-scripts`.  This dependency ships the framework of CRA's configuration (items like Webpack, Babel, etc.).  This one dependency gives us all the out of the box configuration CRA ships.

To peek into its settings, have a look at the modules' folder located at `node_module/react-scripts/`.  There you can find the script run when we execute our `npm start` command in the terminal.

``` javascript(/reactive-client/node_modules/react-scripts/scripts/start.js)
// File example truncated
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
```

This line of code is functionally equivalent to the Ruby code we saw in our Puma configuration.

We can not have both development servers running on the same port.  Technically we could change either one, but changing CRA's configuration would require us to "eject" react-scripts.  Ejecting react-scripts copies all the dependency’s scripts into our project, allowing us to make customizations to settings like this.  

Usually I delay ejecting react-scripts if possible; in fact, CRA considers react-scripts production capable for small and mid-sized applications.  So many CRA users might never need to eject at all.  

We could also alter Puma's configuration file, but this port overlap is a problem that only exists in our development environment.  In production, we plan to have only one server running, so I would prefer not to take special pains to alter our Puma configuration file to correct our dev setup.

For the moment, let's get rails running by altering our start command.  We'll be setting up a manageable process for this in just a moment anyhow.

Start your Rails server: `bin/rails server -p 3000` 

Now you should see Puma coming online on port 3000 as requested.  If all goes well, there will be much rejoicing; you are on Rails!

![Rails Application Homepage](/images/1/RailsHomepage.png)

## Forwarding API Requests

Now that we've done a smoke test on each of our servers, it's time to tackle request forwarding between our client-server, and our API.

In the long term, our production application will compile our React client into a public assets directory, containing a minified file with all our JavaScript, and an HTML index for our application.  This production build can target the Rails' `public/` directory, and let Puma (or whatever server you choose) run the entire show for our production application.

This moment in time where we need two servers to play nicely and handle requests across multiple origins is a passing thing.  Or a symptom of our development environment.  It'd be a shame if we had to set up all our API requests to satisfy COR preflight checks, for a condition that only exists in development.

What is a preflight request?  Any time your application needs to make a cross-domain request to another server, the request must be limited to either a GET, POST, or HEAD type.  And POST requests may only use content-types application/x-www-form-urlencoded, multipart/form-data, or text/plain.  That's fairly limiting when you're trying to build a restful API.
  
Failing to meet these conditions results in your application needing to a make a preflight request. During a preflight request, an initial handshake is sent to the server.  The receiver then checks the origin of the request to see if it is an approved sender, and the headers of the request are checked to ensure they include no potentially malicious content.  Typically this is done by limiting to a short-list of standard header options, or expressly authorized custom headers.  If the preflight check goes well, the usual request can proceed.  If the preflight fails, the server returns an error.

Preflight requests are not an insurmountable obstacle, and in fact, Rails makes them easy to do; even suggesting a gem `rack-cors` in your gemfile to handle this setup.  If you plan to keep your client and server hosting separate for scalability reasons, this might be appropriate.  You could keep Rails entirely devoted to your API, and give over hosting of your client files to a separate server, or CDN.

However, for small to midsized applications, this seems needlessly convoluted.  Luckily, CRA gives us a solution for this that is dead simple to implement.

Open the `package.json` file of your client application.  We are going to add a key `proxy` to our top-level object, and give it a value for our Rails application server (on port 3000, or whatever you have elected to use.)

``` json(/reactive-client/package.json)
{
  "name": "reactive-client",
  "version": "0.1.0",
  "private": true,
+   "proxy": "http://localhost:3000",
  "dependencies": {...},
  "scripts": {...},
}
```

Now, we just need to test this out.  Lets set up a smoke-test controller action so we can ensure our proxy is working as expected before moving forward.

Inside your Rails application directory, generate a new controller action:

`bin/rails generate controller smoketest example --no-test-framework`

That command creates a new controller for us, and a route `get 'smoketest/example'`.  Before we move on, it would be an excellent idea to create a namespace for all our API routes to operate within.  That way we are less likely to collide with client-side routes as we expand out our application.

Open your Rails route configuration file, and update it to the following:

``` ruby(/reactive-api/config/routes.rb)
Rails.application.routes.draw do
+   namespace :api do
+     get 'smoketest/example'
+   end
end
```

Now look at your routes using the command `bin/rails routes` in your terminal, and you should see the following:

`GET  /api/smoketest/example(.:format) api/smoketest#example`

We can nest all our API routes into this namespace to create a clear line of separation for forwarded routes.  However, to account for this namespace, we need to nest our controllers inside an `api/` folder to account for this route change:

`mkdir app/controllers/api && mv app/controllers/smoketest_controller.rb app/controllers/api`

One last thing to do, open the newly generated smoke-test controller. 
 The example action we have created currently returns an empty response.  Let's set it to send back some very basic JSON.

``` ruby(/reactive-ap/app/controllers/api/smoketest_controller.rb)
+ class Api::SmoketestController < ApplicationController
  def example
+     render json: {smoketest: "hello world"}
  end
end
```

Notice we have also changed SmokeTestController to inherit from a new module `Api`, again to account for our changed route.

With all that in place, we are ready for our test.  Be sure you have **both** your client and API servers running.  In a terminal, execute:

`curl http://138.197.14.5:8080/api/smoketest/example`

You should receive a response:

 `{"smoketest":"hello world"}`

Notice that our curl command is directed at port 8080, which is the port of my React client-server, not the API.  When CRA receives a request that it does not have a route to handle, it forwards that request on to the indicated server in our proxy settings, in this case, our API.  Another way we could look at this would be to direct the curl command at the API server itself: `curl http://138.197.14.5:3000/api/smoketest/example`.  The result is the same `{"smoketest":"hello world"}`, we only targeted our request directly at the API server, bypassing the proxy.

With this proxying in place, we can now query our API as a local path such as `api/smoketest/example` from within on client application.  This request proxying eliminates our need to manage CORS requests.

## Managing Servers

Let's make one final configuration to our development environment before we wrap up.

Right now, we need both our servers running to have our application functional in development.  This requires us to have two distinct processes running in two separate terminals, and the use of two commands each time we want to start our servers.  Not a huge deal, but it would be nice if we could start and stop the application more easily.

We are going to use Foreman to help us manage these server processes.

Begin by adding Foreman to your Gemfile's development dependencies, `gem 'foreman', '~> 0.82.0'` and then `bundle install`

Foreman simplifies the running of multiple processes with the use of a Procfile.  Foreman can help you to start several processes in a single terminal, with a single command.  When one process fails, Foreman also helpfully shuts down the remaining controlled processes.

To setup, create a file named `Procfile` in your Rails API application directory.  Then edit the file to contain the following details.

``` bash(/reactive-api/Procfile)
client: cd [client-application directory] && npm start
api: bin/rails server -p 3000
```

Save the file, and shut down any running servers.  Once your Procfile is in place, execute the following from your Rails application directory, `foreman start`.

You should see Foreman start each server process:
``` bash
18:40:19 api.1    | => Booting Puma
18:40:19 api.1    | => Rails 5.1.3 application starting in development on http://138.197.14.5:3000
18:40:19 api.1    | => Run `rails server -h` for more startup options
18:40:19 api.1    | Puma starting in single mode...
18:40:19 api.1    | * Version 3.9.1 (ruby 2.3.1-p112), codename: Private Caller
18:40:19 api.1    | * Min threads: 5, max threads: 5
18:40:19 api.1    | * Environment: development
18:40:19 api.1    | * Listening on tcp://138.197.14.5:3000
18:40:19 api.1    | Use Ctrl-C to stop
18:40:20 client.1 | Starting the development server...
18:40:20 client.1 | 
18:40:26 client.1 | Compiled successfully!
18:40:26 client.1 | 
18:40:26 client.1 | You can now view reactive-client in the browser.
18:40:26 client.1 | 
18:40:26 client.1 |   http://localhost:8080/
18:40:26 client.1 | 
18:40:26 client.1 | Note that the development build is not optimized.
18:40:26 client.1 | To create a production build, use npm run build.
```

Using `ctrl + c` to kill the Foreman process shuts down both application servers.  We must start our applications out of the Rails directory to use Foreman to manage the servers.

## Summary

That brings us to the end of Chapter 1.  we have set up both our client and API servers, and carved out space for both to operate.

We set up create-react-app to manage proxy requests to our API, eliminating the need to manage CORS.

We also configured Foreman to simplify the task of managing multiple server processes in development.

In the next chapter we begin our first iteration of actual application development, and bootstrap a **very** simple version of our reader.  Setting up simple action on our API and client will let us quickly bootstrap a minimum viable(?) product for our reader.
