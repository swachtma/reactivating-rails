# Chapter 2: Loading and Displaying Basic Content

## Start with the Hotdogs

My favorite programming book I've ever read is [Rework](https://www.amazon.com/Rework-Jason-Fried/dp/0307463745/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=1502762510&sr=8-1), written by Jason Fried of Basecamp.  That might be an odd claim, considering that book has not one single line of code in its pages.  But Rework reads like a mission statement for builders, whether that's builders of businesses, or software.  And given Basecamp's connections to the very root of the Rails community, I think it makes and excellent place for us to turn for guidance.

One of Rework's teachings, is that we should strive to focus on the most important parts of a thing first.  And endeavor not to be distracted by the accoutrements, until you've got the basics handled.  The analogy Jason uses, is that of a hotdog cart.  Put simply, he says if you are going to open a hotdog cart, the first thing you should focus your attention on, is the hotdogs.  Not the buns, the condiments, the cart, the marketing, staffing... you need hotdogs.

I find this be a particularly apt analogy, because if there is one thing you probably don't want to focus on the inner workings of in much detail, it's a hotdog.  Given the choice between hotdogs, and anything else on the cart.  I'd rather avoid knowing too much about the hotdogs.

Why focus on tube meats, when we could dive into the gleaming design of our cart.  The materials, the colors, the inspiring log, the witty name...  I could spend a month or two there alone.

Just like we could focus the first foray into our application on all the great and grand trimmings we could add.  We're obviously going to need Redux, so we might as well install that now.  And how will we turn our markdown into beautiful HTML?  Maybe someone already has a parser written we can use or adapt.  Maybe we should go looking for a gem.  And maybe what about our routing; should we just go ahead and install react-router now, or maybe redux-little-router is a better fit for our stack.  I'd hate to choose the wrong one, so maybe I'll go reads some blogs about the pro and cons...

Or, we could make hotdogs.  Not sexy, but right now anything else would be a distraction.

So, what is our application, at its core.  If we're building a reader, then I suppose the first feature we should scratch of the list, is providing something to read.

## Starter setup

If you're jumping in here and want to setup the app locally, you can clone the branch snapshot:
`git clone -b Chapter2Starter https://github.com/swachtma/reactivating-rails-app.git`

## Simple Requirements

I find it's best to write out requirements each time I iterate over an application.  And the first iteration can be the most difficult.  When you have a blue sky in front of you, everything seems simultaneously possible, and impossible.  We need to pick out some business rules that are big enough to get us started, but not so big that our first iteration gets away from us.

Here's a shortlist from some quick brainstorming:
* We need to import a selection of .md files and display their contents to our users.
    * This could be done directly in React, or in Rails with information passed to React. 
    * That means we need some way of enforcing content order.
    * We want to support the continued crowd sourced editing of the project in the long term via GitHub.  That likely means a need for divisions of content, a single document containing an entire book will make tracking changes/suggesting updates unwieldy.
        * We could enforce strict naming conventions
        * We could create simple rules (chapters ordered alphabetically by file name)
* We need a way to pass this information to our React views and display it.
    * We could pass all the content in its original text-blob format direct from the files
    * We could create and object structure that organizes information into chapters, sections, paragraphs, etc.
    * We could create an ordered array of the document/book from begging to end.

That's my shortlist of features for iteration 1: we need to read content in, and display it.  

With several ideas on the table we need to pick a direction, and I'm inclined to lean towards the simplest approach in most cases.  But if I'm honest this is an area that often vexes me as a programmer, because the simplest approach I can see, does not lead me in the direction my gut tells me we are headed in the medium, let alone long term.

For example, we could import or md files directly with our react client, and cut the server out completely in preliminary stages of our application.  In fact, we could go very far indeed without ever involving an API server.  

But since we know that's the direction we are headed (it's a book about using React with Rails after all), it seems a shame to architect things on the client side we know we'll eventually want to migrate to the API.

With that in mind, here's my compromised spec:
* Rails will expect a collection of .MD files in a project directory.
    * These files will be read by the API and sent as a response when requested by the client
* When the client boots, it will request the book contents from the API
* When the client receives content, it will render the text to the screen.

Not as basic as we can make it, but this is the most distilled version of our project intent I am able to create at this moment.  

## Reading on Rails

We could start this spec on the client or the API, and it's largely a matter of preference.  I've long been a fan of view first design; building the UI, and getting that right before I line up the guts of the application to support it.  But I must say, when working against an API, I feel somewhat free of that constraint.  Because, at the risk of spoiling the surprise, when building an API your "view" is going to look something like...

```
{"oh gee": "what a shock, it's a bunch of JSON "}
```

And given that we can rearrange that view in about 2 shakes of a capybara's tail, I'm not that inclined to fret over it.  And since starting with the API saves me the trouble of mocking an API for the sake of starting on the client, that's the way I'm going to go.  

### Project planning

We need a place inside our rails application to house our book contents in their raw .md document form.  Since that doesn't fit inside our normal MVC architecture, we need to carve out some space.  I'm inclined to use the `lib/` directory of our project, as in the future I expect this might be a process we run on a scheduled, or trigger basis.  Since Rails 5 expects scheduled tasks to live in `lib/tasks`, this seems like the perfect place.

Change to the `lib/` directory, then we need to retrieve the books files.  You can clone them from the book's GitHub repository: 
`git clone https://github.com/swachtma/reactivating-rails`.

That will create a new directory `reactivating-rails` which contains all the book's raw .MD files, and well as an `images/` directory, which in turn contains a subdirectory matching the name of each chapter file, and housing all that chapter's images.

### Out with the old

We aren't going to be needing our API proxy smoke test any longer.  Before we move forward, let's clear some of the old brush:
```
rm ~/reactive-api/app/controllers/api/smoketest_controller.rb`
```

You can also delete the route from `config/routes.rb`:
```(ruby)
get 'smoketest/example'
```

### In with the new

Now let's generate a new controller for sending our book contents to our client.  And we'll look a new generator command we neglected to use when setting up our smoke test in the previous chapter.

Run the following in your Rails project directory:
`bin/rails generate controller api/book index`

Notice the use of `api/controller` in our generator command.  That tells Rails to create our controller action inside the api directory we created in the previous chapter.  It also makes that Controller Class part of the `Api` namespace automatically, and sets up a matching namespaced route.  Not bad for one command.

That said, while this is close to what I want, the generate route lands our index at `localhost/api/book/index`, but conventions for index actions typically don't require you to explicitly include *index* in the route.  Let's update `config/routes.rb` as follows:
```(ruby)
namespace :api do
  get 'book/', to: "book#index"
end
```

I'm choosing to use index here, since we'll be delivering the whole book contents in one pass.  A `#show` action feels more aptly named, but given that standard convention would expect show to accept an :id parameter to dictate specific contents to display, `#index` seems to be the better fit for now.  I expect in the long term, we may say goodbye to this controller entirely, as we'll likely be serving sub-sections of the book, out of several controllers, not it's whole contents from a single action.  This will do for now.

### Fat, fat, fat controller

We're about to write some ugly rails, and cram more stuff into a controller than is wise, or acceptable.  I need you to bear with me.  This is the code were going to end with, we're just looking for the most direct way to get where we are going for the moment, so we have a foundation (even a shaky one), to start from.

Let's open the new book#index controller we just generated in `app/controllers/api/book_controller`.

If we're going to display our book data inside the client, we first need to locate the book chapters, and weed out all the accessory data from the containing directory.  Then we'll need to examine each valid file, and convert the data inside into a format we can send easily to the client.

Let start with fetching the raw data:
```(ruby)
def index
  book_dir = "lib/reactivating-rails/"
  raw_file_list = Dir.entries(book_dir)
  
  filtered_file_list = raw_file_list.select do |file|
    path = book_dir + file
    File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)
  end
 end
```

First, we’re fetching an array of all the files in our book's directory use `Dir.entries`, unfortunately for our purposes this will also return entries such as `..` in our set.  We also pull back the `README.md` file that will someday container our GitHub project description for the book, which is a `.md` file, but not an actual chapter of the book's content.

We must then set out some criteria for what gets include as content, and what doesn't.  So for now, let's use the `Array.select` method to trim down our list.  `Array.select` allows us to patch each member of the array to a block, and will return a new filtered array containing only members whose values caused the block to evaluate `true`.

If our case we're evaluating 3 criteria in our block:
`File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)`

Setting some basic rules:
1. The member must be a file
2. The member must have the extension `.md`
3. And the filename must not be `readme.md`

If you execute the above in an Irb console you should return:
`["0.md", "1.md"] `

Or something similar... as hopefully by the time you read this I will have more than 2 chapters written.

Now we have our list of file names sorted out.  Now we need to read those files, and process their content into a format we can send to the client as a bit of JSON.  Trying not to stress the format of the JSON object structure this early in the game, I am inclined to simply construct an array of the book's contents, and pass that as the payload of this API endpoint.

```(ruby)
def index
  book_dir = "lib/reactivating-rails/"
  raw_file_list = Dir.entries(book_dir)
  
  filtered_file_list = raw_file_list.select do |file|
    path = book_dir + file
    File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)
  end
  
  filtered_file_list.sort!
  payload = []
  filtered_file_list.each do |file|
    File.open(book_dir + file).each { |line| payload.append(line) }
  end
end
```

First, I'm invoking a destructive `Array.sort!` on my list of filtered names.  The original array I returned was already sorted helpfully in alphabetical order, but I think it's best we enforce this convention with a bit of code.  For now, we'll be relying on the names of our chapter files being alphabetically ordered to enforce the order of the book's contents.

We also set up and empty `payload` array, which we'll be using to store the contents of the book's chapters.

Then we loop through each file in our list.  And with each file, read line by line, appending to our array as we go.  Ruby helpfully lets us enumerate through files line by line, so we don't need to do any special string parsing to pull this off.

And finally, we need to render our JSON rsponse.  For now, we're going to use a very simple object structure, passing a single key `payload`, which will contain our array of book content.

```(ruby)
def index
  book_dir = "lib/reactivating-rails/"
  raw_file_list = Dir.entries(book_dir)
  
  filtered_file_list = raw_file_list.select do |file|
    path = book_dir + file
    File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)
  end
  
  filtered_file_list.sort!
  payload = []
  filtered_file_list.each do |file|
    File.open(book_dir + file).each { |line| payload.append(line) }
  end
  
  render json: {payload: payload}, status: 200
end
```

Notice we're now passing a status code 200 with our JSON response.  The 200 code is an OK response, in the future we'll be using other codes to pass back different error responses as well, but for now it’s just good to get into the practice of having a response code included in our route outcomes.

With all that in place, let's run a quick test with curl.  Our updated route should have the action hosted on http://localhost:3000/api/book, however the request proxying we set up in Chapter 1 should also ensure that we have that same resource available (by proxy), on port 8080 where our client application is bound.  Let's test both of those items in one pass using the command, `curl http://138.197.14.5:8080/api/book/`.

You should get back a fairly substantial block of JSON in the form:
```(javascript)
{ "payload": [ ... ] }
```

With that in place, we have enough that we can turn our attention to the client.

## Our first API Call

At this point, there is no real connection between our client and API.  But now that we have some content ready for serving, we can change that.

First though, we need a way to manage our API calls.  Technically, we could do this with vanilla JavaScript, but that would leave us to manage the best form of communication for each browser where our application is served.  Personally, I'd rather not reinvent that wheel.  So I'll be farming out this task to a library called Axios, which will give us a layer of abstraction about how the communication is managed browser by browser.  Instead Axios gives us a promise based architecture we can rely on to handle our API communication.

### Installing Axios

The installation process for Axios is simple, as we can manage the whole thing through NPM.  And unlike bundler, we can add packages to our project directly from the command line, without need to update a package list store in our application.

From your client directory, run:
`npm install axios --save`

That flag `--save` tells NPM that we want to update our package.json file with this dependency.  If you open your `package.json` file you will now see `"axios": "^0.16.2"` listed among your dependencies (your version may vary).

### Setting the default component state

Keeping to the path of least resistance, we're going to modify the `App.js` component that CRA bootstrapped for us for this iteration.  Like our API first pass we're going to be fattening up this component with some code it ought not own.  But this will get us quickly to the goals of our first iteration.

Before we even touch an API call, let's make some enhancements to our starter component `src/App.js`:

```(javascript)
import React, { Component } from 'react';
import axios from 'axios';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      book_body: ["Loading, please wait..."]
    };
  }
  
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Reactivating Rails: A work in progress</h2>
        </div>
        <div className="App-intro">
          { this.renderContentBlocks(this.state.book_body) }
        </div>
      </div>
    );
  }
}

export default App;
```

The CRA sets up our application's starter component using the new ES6 class syntax, and generally if you're starting to use React at this stage in the game, this is the syntax you'll want to learn.  While the older syntax is still supported, the community is migrating in this direction.

Before we can connect our API to this component, we need to set up some state that we can load our retrieved content into.  I also think, that since the loading of book content will happen asynchronously, we should also set some default/placeholder text that can be displayed in the event the load from our API takes a bit of time.

We're going to first add a constructor method to our class.  Inside we are going to instantiate a `state` object, and create a property `book_body`, that will store an array.  And into this array we've loaded a few lines of default text.  This structure seems an effective way to store our application default text for now, since we know our API will eventually return us the book's content in a matching array form.

```(javascript)
constructor(props){
  super(props);
  this.state = {
    book_body: ["Loading, please wait..."]
  };
}
```

Now we need to render out that default text, again keeping in mind that we are going to have to repeat and update this process when the book loads.

For this, let's setup a function `renderContentBlocks`, which will return an updated array of HTML elements:
```(javascript)
renderContentBlocks = (content) => {
  let content_blocks = [];
  content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
  return content_blocks;
}
```

We're using the new ES6 arrow function syntax here as we do not want, or need the function to create its own binding for `this`.  We'll expect this function to take one argument, an array of content.  We then setup a new empty array, using the `let` keyword to limit the variables scope to this function block.  

Then, looping through each element on the passed `content` array, we wrap the text in HTML paragraphs, and append the updated content into our `content_blocks` array.  Notice that we are also using the length of the array we are constructing to assign a `key` property to each element we add.  This is a necessary convention whenever you create a collection of elements like this for the render function of a component.  Finally, this array gets passed as the function's return value.

Then the last thing we need to do, is render this content.  React will help us here, by automatically rendering the contents of an array of HTML elements/components.  All we need to do is update the apps starter text with a call to our newly created render function.

Before we wrap up, let's go ahead and update the page title as well.

```(javascript)
render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Reactivating Rails: A work in progress</h2>
        </div>
        <p className="App-intro">
          { this.renderContentBlocks(this.state.book_body) }
        </p>
      </div>
    );
  }
```

Now let's render that content out, and we should see our new defaults loading for us:

![Updated App.js Component with Showing Default Text](/images/2/AppCompDefaultState.png)

### Making the Call

With the groundwork in place, we are ready to add in our API call.

We're going to use the component’s lifecycle method `componenetWillMount` to fire our API call.  This function gets invoked one time for each component’s lifecycle, and since we don't expect the book's contents to change frequently, that makes this lifecycle method a better fit than others that might get called every time the component is updated.

```(javascript)
import React, { Component } from 'react';
import axios from 'axios';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
    this.state = {
      book_body: ["Loading, please wait..."]
    };
  }
  
  componentWillMount(){
    axios.get("/api/book")
    .then(
      (response) => {
        this.setState((prevState) =>{
          return {book_body: response.data.payload};
        });
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Reactivating Rails: A work in progress</h2>
        </div>
        <div className="App-intro">
          { this.renderContentBlocks(this.state.book_body) }
        </div>
      </div>
    );
  }
}

export default App;
```

To start, we'll need to import Axios as a module for this component.

Since Axios is promise based, we can add its calls to our component’s lifecycle methods without it blocking our rendering.  When Axios receives its response, it will return execution to the `then` method chained to the promise, or the `catch` method in instances where the call produces an error.

For now, we are going to limit the `catch` branch of the promise to logging the error to the console, until we have introduced more comprehensive error support.

Right now, let's focus on the `then` branch of our promise.  We're expecting Axios to return a response object, which in turn will house the content of our book at `response.data.payload`.  We'll need to use the setState function of the component to update the book_body property of the state with the content we loaded:

```(javascript)
componentWillMount(){
    axios.get("/api/book")
    .then(
      (response) => {
        this.setState((prevState) =>{
          return {book_body: response.data.payload};
        });
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
```

setState will pass control to an anonymous function, which receives the previous (current) application state as a parameter.  The function is expected to return a *new* object representing the component state, *not* an updated copy of the previous state object.  Hence our function returns a new object, using the object literal syntax, and assigning the book_body attribute of this new object to the content we have loaded.

When a new state is provided to the component, it is rendered again using that state, and we finally have a readable representation of our book.

![First rough render of our book content](/images/2/FirstBookRender.png)

## Refactoring the API logic

At this point, we've got our hotdog.  It's packed full of unsavory bits, and I'd rather no one now exactly how it's been made, but the end product is somethat very minimally fulfills our needs.

Now it's time to run back through this code, and make some incremental improvements.

The Client I am less concerned about at the moment, becasue I'm fairly confident we'll be abandonning this implementation entirely as our needs evolve.  The API however, is already doing some things that are going to be around for the long term; namely locating and parsing our chapter files.  It is however doing them in an inappropriate place. We probably won't be able to solve for all of that right now, but we can take some steps in the right direction.

I also think we should take a moment to lay down some basic tests to support these features of our application that might be sticking around.

### A good place to part ways

If you're already confident in your abilities with Rails, this might be a good point for you to jump forward to Chapter 3.  We're gonig to focus on refactoring the API code, installing Rspec, and laying down some basic tests.  If you're up to speed on all of that, I suggest jumping forward to the commit at the beginnig of Chapter 3.  That's where we'll next be focused on intereactions between Ract and Rails.  If you could use some exposure to Rails in isolation, stick with me for the next few sections.

### Refactoring Book#index

We need to skinny down our fat controller so that it's not managing the minutia of loading loading our book's content, and is instead more focused on our handling just the request/response process.

There are two steps of actions crammed in that do not belong:
1. Locating relevant chapter files from a directory
2. Processing those files into a response format

We're going to skinny up our controller by moving each of these processes above into a standalone class.  For now, those class files will live in `controllers/concerns`, since we'll still be invoking them in our controller actions (for now).

There is also one other fairly substantial problem with our parsing of the chater files.  We're treating each line of the files we read as its own block of content.  However `.md` files have several elements in them that are block level elements (meaning the store nested inline elements as parts of a larger structure).  Since our parser treats every line as a block, we're creating elements like ordered or unorder lists where each list item is wrapped in a surrounding paragraph tag.

That's going to be a major headache when we try to parse this `.md` content into HTML.  So as we refactor the file parsing let's also try to extend our parse logic a bit to better deal with this case.

### Finding files

Let's start with the file location problem, since it's the easier of our two refactors.  

The end goal of this Class is to provide us an array of files that need to be parsed.  Right now, we're retuning an ordered list of the file names; however this creates a burder of us where we need to maintain the directory path as a standalone variable, and pass both the files array, and the path as parameters to our parser.  Ideally, the file locator class would return a ready to use array.

```(ruby)
class Api::BookController < ApplicationController
  def index
    file_list = BookFileFinder.new("lib/reactivating-rails/").entries
    
    payload = []
    file_list.each do |file|
      File.open(file).each { |line| payload.append(line) }
    end
    
    render json: {payload: payload}, status: 200
  end
end
```

Let's start by simplifying our controller to the interface we'd like the new class to provide.  Notice we've stripped out the directory travesal, and filtering of files from the controller action.  Instead, we'll be instatiating a new instance of BookfileFinder, and expecting it to provide an entries interface: `file_list = BookFileFinder.new("lib/reactivating-rails/").entries`

The returned `file_list`, will then be used by our parsig logic, which remains unchanged for now.

Now, let's set up the actual class in `app/controllers/concerns/book_file_finder.rb`.

```(ruby)
class BookFileFinder
  attr_reader :entries
  
  def initialize(path)
     @path = path 
     @entries = locate_chapter_files.sort!
  end
  
  def locate_chapter_files
     raw_file_list = expand_file_paths(Dir.entries(@path))
     filter_chapter_files(raw_file_list);
  end
  
  def filter_chapter_files(raw_file_list)
      filtered_list = raw_file_list.select do |file|
          File.file?(file) && File.extname(file) == ".md" && !/readme\.md/i.match?(file)
      end
  end
  
  def expand_file_paths(file_array)
    file_array.map do |file|
      @path + file
    end
  end
end
```

First we declare an attr_reader for our class' public interface.  

Our class' `initialize` function expects one parameter, a path to our book's directory.  It also sets our `entries` attribute by kicking off our traversal of the files directory by invoking `locate_chapter_files`.  Most of the logic migrates over directly from our controller, however we have introduced the `expand_file_paths` method to the class to meet our new requirement of returning an array containing complete path.

Inside `expand_file_paths` we use the `Array.map` method to transform each member to the passed file array, concatenating the base `@path` variable onto each file name.  The lgoc then continues as we saw in our controller; the list of files is filtered to contain only chapter files, and finally the array is sorted alphabetically.

Now would be a good time to refresh your client, and ensure we haven't broken anything during our refactor.

### Upgrading our Parser

Now that we have cleaned up our file processing a bit, let's give a similar upgrade to the parsing logic.

We need to determine which line we import are the openning of a block series, and which are inline elements.  Our block elements for now will include: unordered lists, ordered list, code blocks, and tables.  Since we're dealing with string parsing we're going to need to write some regex to help us determine where these block elements start, and where they stop.

We'll need to upgrade our parsing logic so that as each line is imported, we determine if it's a block or inline element.  Inline elements shouldn't need special treatment, for now.  Block elements will need to continue collecting additional lines, until we reach the end of the element; we may need two regular expressions to solve this: one for the opening line of the block, and another for the close.

Here's a crash course for Markdown formatting of these elements, if you are not familiar:
| Element         | Open with a pipe charachter, followed by the cell contents and then another pipe. This pipe, content, pipe pattern repeats for the # of columns in the table. Opening and closing pipes are optional | `^.{3,}\|.{3,}$`         | Failure to match opening pattern. |
|-----------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|--------------------------|-----------------------------------|
| Tables          | Marked with `*`,`+`, or `-` and a space.,May contain leading tabs to denote indentation.,Or be followed by lines beginning with a space to nest line in the previous bulltet.                        | `^\s*(\*|-|\+|(\s.)).*$` | Failure to match opening pattern. |
| Unordered lists | Marked with a number (any number), followed by a period.,May contain leading spaces for indentation.,May be followed by a line with leading spaces to nest items in the previous bullet.             | `^\s*(\d+\.|(\s+)).*$`   | Failure to match opening pattern. |
| Ordered lists   | Marked with opening and closing triple backtick charachters                                                                                                                                          | `^```.*$`                | 2nd Match of opening pattern      |