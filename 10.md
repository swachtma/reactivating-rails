# Chapter 10: Composing Complex Components

Building our application so far, we have worked with components and containers mostly for simple UI renderings.  This iteration, we are redesigning one critical element of our interface; improving how code examples render for our book.  As we do, we look at several new component strategies: mixing local component and store states, new composability patterns, and component refs.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch10-starter
```

## Planning our Iteration

One of our application's most important tasks is effectively displaying example code for our project.  So far, we've used an out-of-the-box parser to turn markdown into HTML.

I think that considering the minimal installation effort we invested, we achieved acceptable early results.  However, this is a core feature.  How our reader handles example code should distinguish our application from competitors.  We should make some investments here.

**Here's the scope of our next iteration:**
* Code examples should support syntax highlighting
* Code lines with notable changes should be highlighted to help readers focus
* File names/paths should be included in a header for each code example
* Code of lower importance should collapsable
* Code should support easy copy/paste to promote following along with book examples

## Our Code Fence Markdown

To support the spec for this iteration, we need to introduce some proprietary markdown formatting.

Standard Markdown code fences open with three backtick characters, followed by an optional language name (``` javascript).  Code fences close with another line containing three backtick characters.  Lines included between the open and close tags hold the example code.

We are going to adapt the opening tag syntax to be ``` language(path/to/file.ext) so that our opening tag supports an optional path to each file.

We are also going to adopt Github's markdown syntax for diffs, using them to highlight or collapse lines of code.

Here is the spec for this feature in our application:
* Normal lines have no identifier and are rendered as-is 
* Low priority lines are collapsible
  * By default, these lines render collapsed but expand when clicked
  * Low priority lines begin with a (- ) character pattern
* High priority items are highlighted
  * High priority lines begin with a (+ ) character pattern.

Below you can compare a standard markdown example (left), to our altered syntax (right).

![Markdown Example Syntax](/images/10/MDExample.png)

## Getting Data Ready

Before we can start working, we need to prepare data for our components.  We currently treat each code example as a large multi-line string.  

Our application must parse each example as follows:
* Isolate and remove the opening and closing code fence markers
  * Identify the language and file path
* Parse lines, splitting out sections of low, normal, and high priority code.
  * Remove priority markers from each line before rendering the text

We can write a High Order Component to prepare the data/props needed to render our upgraded code examples.  That approach cleanly separates data preparation tasks from rendering our UI; making our code more explicit, testable, and modular.

## Parsing Code Blocks

Since I am about to create several components all used to render nodes, I am going to group all these related files inside a folder `src/components/nodes`.

After creating your folder, create the following file:

``` javascript(/client/src/components/nodes/parse_code_node.js)
import React from 'react';

const parseCodeNode = (node) => {
  let passthroughProps = {
    // More to come
  };
  
  return class extends React.Component {
    render(){
      <CodeBlock { ...passthroughProps } />;
    }
  };
};

export default parseCodeNode;

class CodeBlock extends Component {
  render(){
+     return <div>HEY LISTEN! { JSON.stringify(this.props) }</div>;
  }
}
```

This example creates a new high order component `parseCodeNode`, which uses an object, `passthroughProps` to hold our parsed data.  Using this object and the spread operator, we can ensure all our prepared data reaches the rendered child component.  We're using a simple `CodeBlock` component as a placeholder for now, and calling `JSON.stringify` in our initial render to ensure all our props print to the screen for easy debugging as we build.

Let's take another step forward.

``` javascript(/client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

+ export const parseBlockOpen = (first_line) => {
+   if(fenceLine(first_line)){
+     return first_line.replace(
+       /^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]
+    ).split(",");
+   } else{
+     return [undefined,undefined];
+   }
+ };

export const fenceLine = (line) => line.match(/^```/);

const parseCodeNode = (node) => {
+   let all_lines = node.content.trim()split("\n");
+   let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
  let passthroughProps = {
    node_id: node.id,
    block_type: block_type,
    block_path: block_path
  };
  
  return class extends Component {
    render(){
      return <CodeBlock { ...passthroughProps } />;
    }
  };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>HEY LISTEN! { JSON.stringify(this.props) }</div>;
-   }
- }
```

Our HOC expects to receive a node of markdown content when invoked.  We first test the assumption that this node is a code fence by splitting the lines of text into an array.  `parseBlockOpen` then inspects the first line of our content.  

We begin with a Regex test, ensuring the first line is a code fence opening.  If the first line is a fence, we execute further tests, if not we return `undefined` for our block's language type and file path.

Where the first line of our content **is** a fence opening, we use a Regular expression again to pull the information we need from the opening tag.  `String.replace` allows us to pull out specific fragments from our regex evaluation.  Each set of parentheses in the regular expression forms what is called a match group.  The second parameter of the replace function allows us to access these matches using the `$#` shorthand.  In this case, we are interested in `$2`, and `$4`; the language type, and file path respectively.

If this regular expression is over your head and you would like to dig into it, I have set up [an example at Regex101.com](https://regex101.com/r/t9Okoc/1/) that should help you work through it.

A new assignment operator sets `[block_type, block_path]` using `parseBlockOpen`'s return.  `block_type` receives its value from the first index of the returned array, while `block_path` receives the second.  We add these two values to our passthrough props object.

Our HOC is already growing complex, so let's add a wave of tests before we move forward.  

``` javascript(/client/src/components/nodes/parse_code_node.spec.js)
/* global expect*/
import * as unit from './parse_code_node';

describe("fenceLine()",()=>{
  describe("returns true only if code fence",()=>{
    expect(unit.fenceLine("```")).toBeTruthy();
    expect(unit.fenceLine("``` ")).toBeTruthy();
    expect(unit.fenceLine("* ")).toBeFalsy();
  });
});

describe("parseBlockOpen",()=>{
  let examples = [
    {test: "```", outcome: ["",""]},
    {test: "``` ", outcome: ["",""]},
    {test: "```javascript", outcome: ["javascript",""]},
    {test: "``` javascript", outcome: ["javascript",""]},
    {test: "```javascript(/to/file.ext)", outcome: ["javascript","/to/file.ext"]},
    {test: "``` javascript(/to/file.ext)", outcome: ["javascript","/to/file.ext"]}
  ];
  
  examples.forEach((example => {
    test("test value provide outcome",()=>{
      expect(unit.parseBlockOpen(example.test)).toEqual(example.outcome);
    });
  }));  
});
```

Here `forEach` is used to test that our regular expression evaluation produces the behavior we need.

Next, we need to parse our code block into sections by priority.  I am going to assemble an object for each section, storing its content and priority level.  We also need a unique key value to use when we print these sections to the screen.  Before we start cutting up content, we need to isolate lines of code from the fence's open/close tags.

``` javascript(/client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

- export const parseBlockOpen = (first_line) => {
-   if(fenceLine(first_line)){
-     return first_line.replace(
-       /^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]
-     ).split(",");
-   } else{
-     return [undefined,undefined];
-   }
- };

export const fenceLine = (line) => line.match(/^```/);

+ export const getContentLines = (lines) =>
+   fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;

const parseCodeNode = (node) => {
  let all_lines = node.content.trim().split("\n");
+   let content_lines = getContentLines(all_lines);
  let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
-   let passthroughProps = {
-     node_id: node.id,
-     block_type: block_type,
-     block_path: block_path,
-   };
  
-   return class extends Component {
-     render(){
-       return <CodeBlock { ...passthroughProps } />;
-     }
-   };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>HEY LISTEN! { JSON.stringify(this.props) }</div>;
-   }
- }
```

`getContentLines` removes the first and last backticks lines from the code fences using `Array.slice()`.

Next, we must sort lines into sections, checking each line's leading characters to determine their priority level.

``` javascript(/client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

- export const parseBlockOpen = (first_line) => {
-   if(fenceLine(first_line)){
-     return first_line.replace(
-       /^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]
-     ).split(",");
-   } else{
-     return [undefined,undefined];
-   }
- };

export const fenceLine = (line) => line.match(/^```/);

export const getContentLines = (lines) =>
  fenceLine(lines[0]) ? lines.slice(1,lines.length - 2) : lines;

+ export const divideSections = (block_contents) => {
+   let remaining_lines = block_contents;
+   let block_sections = [];
+   let working_section;
+   
+   while(remaining_lines.length !== 0){
+     let line = remaining_lines.shift();
+     let clean_line = filterFlag(line);
+     
+     if(!working_section){
+       working_section = { priority: getSectionPriority(line) };
+       working_section.content = [clean_line];
+     } else{
+       if(line[0] && line[0].match(flagMap[working_section.priority])) {
+         working_section.content.push(clean_line);
+       } else{
+         remaining_lines.unshift(line);
+         block_sections.push(working_section);
+         working_section = null;
+       }
+     }
+   }
+   
+   if(working_section){ block_sections.push(working_section) }
+   return block_sections;
+ }

export const filterFlag = (line) => {
  return line.replace(/^([+-]\s)?(.*)$/,"$2");
}

export const flagMap = {
  high: /\+[ ]/,
  low: /-[ ]/,
  normal: /[^+-]/
};

export const getSectionPriority = (line) => {
  switch(line[0]){
    case("+"):
      return "high";
    case("-"):
      return "low";
    default:
      return "normal";
  }
}

const parseCodeNode = (node) => {
  let all_lines = node.content.trim().split("\n");
  let content_lines = getContentLines(all_lines);
  let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
  let passthroughProps = {
    node_id: node.id,
    block_type: block_type,
    block_path: block_path,
+     block_sections: divideSections(content_lines)
  };
  
-   return class extends Component {
-     render(){
-       return <CodeBlock { ...passthroughProps } />;
-     }
-   };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>HEY LISTEN! { JSON.stringify(this.props) }</div>;
-   }
- }
```

The bulk of our logic lives in `divideSections`, which takes the total collection of lines and creates a variable `remaining_lines` to hold unprocessed content.  

A while loop persists as long as `remaining_lines` has more content.  Entering this loop, we check if a `working_section` is already defined.  When `working_section` is undefined on a new line, a new `working_session` instantiates.  The priority of this first line sets the priority level for lines that follow.

Reading subsequent lines, we ensure their priority matches the current working section.  If so, the additional line is cleaned of its marker and appended to our array. Then the loop continues with the next line.

When the incoming line's priority flag differs from the current working section's, we close the current `working_section`, appending the object to `block_sections` and resetting `working_section` to `null`.  The current line of our loop is unshifted back into our array of remaining lines.  When the loop runs its next iteration, we re-evaluate this line as the start of a new `working_section`.

When the loop ends, we append the final `working_section` to `block_sections`.

This method processes our code example into a series of sections, each divided by a change in priority level. There's just one small problem; this code is an unholy mess.  Sometimes I have to write the wrong code to work out the right code.  With a working demonstration, we can refactor to something better.

## Working with Classes

We have been using ES2015 class extensively with React components.  However, nothing stops us from creating classes that are **not** components to logically divide our work.

Our current unwieldy `parseCodeNode` function, works with three types of content: the whole code block itself, sections of our example, and individual lines.  Let's try reworking this function as a group of classes that align with these taxonomical divisions.  Create a new folder `/src/components/nodes/lib/` to store these new class files.

For the code fence itself, I need my class to identify the language used, the file path, an ID for the node, and its contents.  Create a file `code_fence.js` in your new directory.

``` javascript(/client/src/components/nodes/lib/code_fence.js)
class CodeFence {
  constructor(node){
    let all_lines = node.content.trim().split("\n");
    
    this.node_id = node.id;
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
    this.content_lines = CodeFence.getContentLines(all_lines);
  }
  
  static fenceLine = (line) => line.match(/^```/);
  
  static parseFenceOpen = (first_line) => {
    if(CodeFence.fenceLine(first_line)){
      return first_line.replace(
        /^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]
      ).split(",");
    } else{
      return [undefined,undefined];
    }
  };
  
  static getContentLines = (lines) =>
    CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
}

export default CodeFence;
```

Focus on how the class syntax above differs from using a function or HOC to manage this same work.  Most of the logic used is a direct migration of functions we wrote previously, but now inside the class' constructor, we assign items we need to capture to instance attributes on the class.  

You may notice we also translated many of our standalone exportable functions into static methods.  This transformation allows us to preserve our existing tests, with only minor adjustments.  Move your `parse_code_node.spec` spec file to the `nodes/lib` directory under the name `code_fence.spec.js`, and make the change below.

``` javascript(/client/src/components/nodes/lib/code_fence.spec.js)
/* global expect*/
import CodeFence from './code_fence';

describe("ParseCodeBlock.fenceLine()",()=>{
  describe("returns true only if code fence",()=>{
    expect(CodeFence.fenceLine("```")).toBeTruthy();
    expect(CodeFence.fenceLine("``` ")).toBeTruthy();
    expect(CodeFence.fenceLine("* ")).toBeFalsy();
  });
}); 

describe("ParseCodeBlock.parseFenceOpen()",()=>{
-   let examples = [
-     {test: "```", outcome: ["",""]},
-     {test: "``` ", outcome: ["",""]},
-     {test: "```javascript", outcome: ["javascript",""]},
-     {test: "``` javascript", outcome: ["javascript",""]},
-     {test: "```javascript(/to/file.ext)", outcome: ["javascript","/to/file.ext"]},
-     {test: "``` javascript(/to/file.ext)", outcome: ["javascript","/to/file.ext"]}
-   ];
  
  examples.forEach((example => {
    test("test value provide outcome",()=>{
      expect(CodeFence.parseFenceOpen(example.test)).toEqual(example.outcome);
    });
  }));
});

+ describe("CodeFence.getContentLines()",() =>{
+   test("removes open and close fence",()=>{
+     let test_value = ["```","test value","```"];
+     expect(CodeFence.getContentLines(test_value)).toEqual(["test value"]);
+   });
+ });
```

Instead of using the `import *` syntax we import the `CodeFence` class as a whole.  We've also defined a new test for `CodeFence.getContentLines`.

Now, create a new file with a `CodeBlock` component that leverages this new class.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';

class CodeBlock extends Component {
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
  }
  
  render(){
    return(
      <div 
        key={"code_block_" + this.code_fence.node_id}
        id={"code_block_" + this.code_fence.node_id}
        className={"language-"+this.code_fence.block_type}
      >
        { 
          this.code_fence.block_path ?
          <div>{ this.code_fence.block_path }</div> :
          null 
        }
        <div>
          { JSON.stringify(this.code_fence.content_lines) }
        </div>
      </div>
    )
  }
}

export default CodeBlock;
```

Each component rendered passes a node from its props to the `CodeFence` class' constructor.  The class provides the items needed to populate this component; an ID, file path, and raw text for the node.

Next update `NodesList` to use this `CodeBlock` component.

``` javascipt(/client/src/components/nodes_list.js)
import React, { Component } from 'react';
import MarkdownIt from 'markdown-it';
+ import CodeBlock from './nodes/code_block';

const md = new MarkdownIt();

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
+       switch (node.node_type) {
+         case("code_block"):
+           return nodes_list.push(
+             <CodeBlock key={"node_" + node.id} node={node} />
+           );
+         default:
+           return nodes_list.push(
+             <p 
+               key={"node_" + node.id} 
+               dangerouslySetInnerHTML={{__html: md.render(node.content)}}
+             />
+             );
+       }
    });
    return nodes_list;
  }
  
-   render() {
-     return (
-       <div id="nodes_list">
-         { this.renderNodes(this.props.nodes) }
-       </div>
-     );
-   }
}

export default NodesList;
```

You should now have a very rough render of `CodeBlock` available.

![Early Rendering of New Code Fence](/images/10/EarlyFenceRendering.png)

Now we need to tackle individual sections of code.  My initial thoughts are to translate the concept of our first iteration's `working_section` into another class.  That class should have an interface for taking code line by line, monitoring priority flag changes, and signaling the section is complete when priority changes.  

It is still not clear to me whether I need a dedicated class for individual lines yet.  The best way to decide is to see how the sections class looks without it.

``` javascipt(/client/src/components/nodes/lib/code_section.js)
class CodeSection {
  constructor(first_line, node_id, section_id){
    this.contents = [];
    this.section_id = "node_" + node_id + "_section_" + section_id;
    this.priority = CodeSection.checkPriority(first_line);
  }
  
  static checkPriority(line) {
    let flag = line[0];
    let flagMap = { "+": "high", "-": "low"};
    
    return flagMap[flag] ? flagMap[flag] : "normal";
  }
}

export default CodeSection;
```

Here, our constructor creates an array for containing the section contents.  We also build a unique ID using a node and section id so that we have a unique key value available when React renders this content.

Instantiating this class creates a new section, and set its priority.  Next, we need an interface to read additional lines one at a time.

``` javascipt(/client/src/components/nodes/lib/code_section.js)
class CodeSection {
-   constructor(first_line, node_id, section_id){
-     this.contents = [];
-     this.section_id = "node_" + node_id + "_section_" + section_id;
-     this.priority = CodeSection.checkPriority(first_line);
-   }
  
  get completed() {
    return {
      section_id: this.section_id,
      priority: this.priority,
      contents: CodeSection.preserveLineBreaks(this.contents)
    };
  }
  
+   continues = (line) =>
+     this.priority === CodeSection.checkPriority(line);

+   appendLine = (line) => {
+     this.contents.push(
+       CodeSection.cleanLine(line)
+     );
+   }
  
    
  static preserveLineBreaks(contents){
    return Array.from(contents, c => c === "" ? " " : c);
  }
  
  static cleanLine(raw_line) {
    return raw_line.replace(/^([+-]\s)?(.*)$/,"$2");
  }
  
-   static checkPriority(line) {
-     let flag = line[0];
-     let flagMap = { "+": "high", "-": "low"};
-     
-     return flagMap[flag] ? flagMap[flag] : "normal";
-   }
}

export default CodeSection;
```

The example above creates two more interfaces for this class; `continues` and `appendLine`.  `continues` accepts an incoming line and checks if its flag matches the priority set for the section.  If that next line matches the section's priority, `continues` returns true.

`appendLine` provides an interface to extend the section.  First removing the line's priority flag, and then appending it onto the section.

A getter method, `complete` returns an object containing the section's id, content, and priority.  The `complete` method also leverages a small helper method, `preserveLineBreaks`, which updates any empty lines in our content to a string with one space. This single space prevents `<pre>` tags from collapsing lines of whitespace when examples render.

Before moving on, add some tests for this class.

``` javascript(/client/src/components/nodes/lib/code_section.spec.js)
/* global expect */
import CodeSection from './code_section';

const test_lines = [
  { test: "+ ", priority: "high" },
  { test: "some code", priority: "normal" },
  { test: "- ", priority: "low" },
  { test: "", priority: "normal" },
];

describe("CodeSection.checkPriority()", ()=>{
  test_lines.forEach((run) =>{
    test("returns flag prioity", ()=>{
      expect(CodeSection.checkPriority(run.test)).toEqual(run.priority);
    });
  });
});

describe("CodeSection.cleanLine()", ()=>{
    test("removes priority flags from line", ()=>{
      expect(CodeSection.cleanLine("+ test")).toEqual("test");
      expect(CodeSection.cleanLine("- test")).toEqual("test");
      expect(CodeSection.cleanLine(" test")).toEqual(" test");
    });
});
```

Now let's upgrade `CodeFence` to utilize our sections class.

``` javascript(/client/src/components/nodes/lib/code_fence.js)
import CodeSection from './code_section';

class CodeFence {
  constructor(node){
    let all_lines = node.content.trim().split("\n");
    let content_lines = CodeFence.getContentLines(all_lines);
    
    this.node_id = node.id;
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
+     this.sections = this.parseSections(content_lines);
  }
  
+   parseSections = (remaining_lines) => {
+     let current_section, sections = [];
+     
+     while(remaining_lines.length > 0){
+       current_section = current_section || new CodeSection(
+         remaining_lines[0], this.node_id, sections.length
+       );
+ 
+       if(current_section.continues(remaining_lines[0])){
+         current_section.appendLine(remaining_lines.shift());
+         if(remaining_lines.length === 0) {
+           sections.push(current_section.completed)
+         }
+       } else {
+         sections.push(current_section.completed);
+         current_section = null;
+       }
+     }
+     
+     return sections;
+   }
  
  static fenceLine = (line) => line.match(/^```/);
  
-   static parseFenceOpen = (first_line) => {
-     if(CodeFence.fenceLine(first_line)){
-       return first_line.replace(
-         /^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]
-       ).split(",");
-     } else{
-       return [undefined,undefined];
-     }
-   };
  
-   static getContentLines = (lines) =>
-     CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
}

export default CodeFence;
```

We have added a `sections` attribute to the `CodeFence` constructor, and a new function `parseSections` which builds an array of sections into this placeholder.  

The logic inside `parseSections` is still complex, but it's more readable now that we can leverage the named methods supplied by our `CodeSection` class.  The basic premise of the method is unchanged.  We create an empty array `sections` to store our parsed sections.  While lines remain; we instantiate a new `CodeSection` if one doesn't already exist, passing it the next line.  Each additional line repeats a test; `continues`, checking for flag changes, if not found, the line is shifted off `remaining_lines` and into the section.

When a flag change **is** detected, `continues` returns false.  The completed section is then appended to our `sections` array using the `completed` getter method we created.  On the last line, we append the final section and return our complete list of sections.

Check our work by doing a quick update to our `CodeBlock` component.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
  render(){
    return(
      <div 
       key={"code_block_" + this.code_fence.node_id}
       id={"code_block_" + this.code_fence.node_id}
       className={"language-"+this.code_fence.block_type}
      >
        { this.code_fence.block_path ? <div>{ this.code_fence.block_path }</div> : null }
        <div>
+           { JSON.stringify(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

If you look at your rendered application, you should now see each code example printing an array of objects representing each section of the code.

![Code Fence with Divided Sections](/images/10/CodeFenceWithSections.png)

Before we move on, I think we should add an integration test to cover the entire setup of a `CodeFence` and its use of the `CodeSection` class.

``` javascript(/client/src/components/nodes/lib/code_fence.spec.js)
/* global expect*/
import CodeFence from './code_fence';

const test_node = {
  id: 78,
  chapter_id: 2,
  node_type: 'code_block',
  content: '``` javascript(/client/src/App.js)\n+ console.log("high")\n- console.log("low")\nconsole.log("normal")\n```'
};

describe("CodeFence Integration Tests",()=>{
  let code_block = new CodeFence(test_node);
  test("parses code sections",()=>{
    expect(code_block.sections.length).toEqual(3);
    expect(code_block.sections[0].priority).toEqual("high");
    expect(code_block.sections[1].priority).toEqual("low");
    expect(code_block.sections[2].priority).toEqual("normal");
  });
  
  test("parses code type",()=>{
    expect(code_block.block_type).toEqual("javascript");
  });
  
  test("parses code path",()=>{
    expect(code_block.block_path).toEqual("/client/src/App.js");
  });
  
  test("assigns each section an ID",()=>{
    expect(code_block.sections[0].section_id).toEqual("node_78_section_0");
  });
});

- describe("ParseCodeBlock.fenceLine()",()=>{
-   test("returns true only if code fence",()=>{
-     expect(CodeFence.fenceLine("```")).toBeTruthy();
-     expect(CodeFence.fenceLine("``` ")).toBeTruthy();
-     expect(CodeFence.fenceLine("* ")).toBeFalsy();
-   });
- });

- describe("ParseCodeBlock.parseFenceOpen()",()=>{
-   let examples = [
-     {test: "```", outcome: ["",""]},
-     {test: "``` ", outcome: ["",""]},
-     {test: "```javascript", outcome: ["javascript",""]},
-     {test: "``` javascript", outcome: ["javascript",""]},
-     {test: "```javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]},
-     {test: "``` javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]}
-   ];
-   
-   examples.forEach((example => {
-     test("test value provide outcome",()=>{
-       expect(CodeFence.parseFenceOpen(example.test)).toEqual(example.outcome);
-     });
-   }));
- });

- describe("ParseCodeBlock.getContentLines()",() =>{
-   test("removes open and close fence",()=>{
-     let test_value = ["```","test value","```"];
-     expect(CodeFence.getContentLines(test_value)).toEqual(["test value"]);
-   });
- });
```

Instantiating our class with an example markdown node, we check that our test value provides all the outputs we rely on; IDs, sections, file paths, and language types.

Now, with the heavier lifting behind us, let's start addressing our UI.

## Styling our Enhanced CodeBlocks

Now that we have our base data in place, we can upgrade our rendering.  Let's start with some updates to our top level `CodeBlock` component, adding style and proper renderings for our prop values.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

const codeBlockStyle = {
  marginBottom: "16px"
};

const blockHeaderStyles = {
  borderBottom: "3px double #021a40",
  backgroundColor: "#021a40",
  color: "#fff",
  padding: "5px 10px 5px 20px",
  textOverflow: "ellipsis"
};

const blockBodyStyle = {
  padding: "10px 0",
  border: "1px solid #021a40",
  backgroundColor: "#F0F0F0",
  overflowX: "scroll"
};

class CodeBlock extends Component {
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
  }
  
  renderCodeSections = (sections) => {
    return Array.from(sections, s => {
      return(
        <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
        contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
  render() {
    return (
      <div 
        style={codeBlockStyle} 
        key={"code_fence_" + this.props.node.id}
        id={"code_block_" + this.code_fence.node_id} 
        className={"language-"+this.code_fence.block_type}
      >
        { this.code_fence.block_path ? 
        <div style={blockHeaderStyles}>{ this.code_fence.block_path }</div> : null 
        }
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We are adding some styles to our `CodeBlock` container, and adding a `renderCodeSections` method to print sections using an undefined `CodeSection` component.  Inside `renderCodeSections`, `Array.from` allows us to iterate through a collection and construct a new array from its contents.  This process transforms our array of raw sections into an array of full-fledged components.

## Components with Independent State

Let's define our `CodeSection` component. We are going to install a library to manage our syntax highlighting in code section; HighlightJS.  HighlightJS can post-process our code blocks to markup code with colors and text styles.  This styling makes our examples easier to read than plain monochromatic text.

To install HighlightJS, we need to update `index.hmtl` with a link to HighlightJS' Javascript.  We also need a link to a CSS theme for the highlighter to use.  Both are available off the `jsdelivr` CDN.  If you would like to ensure you are using the latest version of HighlightJS, check the installation instructions on the [HighlightJS website](https://highlightjs.org/download/) for updated CDN links, or use the example links provided below.

I am also taking this opportunity to install the [Font Awesome Icon Libray](http://fontawesome.io/icons/), which I plan to use with my new components as well.

``` html(/client/public/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
    <!--
      manifest.json provides metadata used when your web app is added to the
      homescreen on Android. See 
      https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css"></link>
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
    <script src="https://use.fontawesome.com/4dddb60c9c.js"></script>
+     <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/highlight.min.js"></script>
+     <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.13.1/build/styles/default.min.css">
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>React App</title>
  </head>
  <body>
    <noscript>
      You need to enable JavaScript to run this app.
    </noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>
```

Now that we have HighlightJS available let's set up our CodeSection Component.

``` javascript(/client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

- const codeSectionStyle = {
-   display: "table-row",
-   padding: "0 5px",
-   lineHeight: "100%"
- };

- const codeGutterStyle = {
-   display: "table-cell",
-   padding: "0 5px"
- };

- const codeBodyStyle = {
-   margin: 0,
-   display: "table-cell",
-   width: "100%",
-   paddingRight: "10px",
- };

class CodeSection extends Component {
  constructor(props){
    super(props);
+     if(props.priority === "low"){
+       this.minimizedContent = props.contents[0];
+       this.state = {collapsed: true};
+     } else { this.state = {collapsed: false} }
  }

  renderSectionContent = () => {
    let p = this.props;
    return this.state.collapsed ? <CodeCollapsed {...p} /> : <CodeFull {...p} />;
  }
  
  toggleCollapse = (e) => {
    if(this.props.priority === "low"){
      this.setState({collapsed: !this.state.collapsed});
    }
  };
  
  render() {
    let priority = this.props.priority;
    let icon = this.state.collapsed ? "plus" : "minus"; 
    
    return (
      <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={codeSectionStyle}>
        <div className="codeGutter" style={codeGutterStyle}>
          <i className={"fa fa-"+ icon +"-square-o"}></i>
        </div>
        <div className="codeBody" style={codeBodyStyle} id={this.props.section_id}>
          { this.renderSectionContent() }
        </div>
      </div>
    );
  }
}

export default CodeSection;
```


Let's look at this component as a whole, minimizing its style attributes focus us on the component's behavior rather than its presentation.

Looking at our constructor, we see this component maintains an internal state, separate from Redux.  While both `props` and `state` dictate how components render and behave, a component should never mutate its props.

The component's *state* is mutatable.  In `CodeSection`, we're using a `state.collapsed` value to dictate whether our low priority components render fully, or truncate their contents.  `CodeSection`, when set to `normal` or `high` priority defaults to uncollapsed, and is not collapsible at all.  A low priority section defaults to a collapsed state but should be expandable when clicked.

Using an `onClick` event, our component toggles its collapsed state using `setState`.  When the component's state changes, it updates and renders either the `CodeCollapsed` or `CodeFull` component.  An icon for an open/close button renders in the left-hand margin of our example as well to show the current state of the component to our users.

Now let's look at those `CodeCollapsed` and `CodeFull` components.

``` javascript(/client/src/components/nodes/code_full.js)
/* global hljs */
import React, { Component } from 'react';

class CodeFull extends Component {
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_full"));
  }
  
  render() {
    return (
      <code id={this.props.section_id+"_full"}>
        <pre className={this.props.block_type}>{this.props.contents.join("\n")}</pre>
      </code>
    );
  }
}

export default CodeFull;
```

`CodeFull` renders the section's entire contents using `<code>` and `<pre>` tags to ensure our examples render as text instead of HTML, and preserve their indentation.  We also supply the example's language inside a `className` attribute of our `<pre>` tag so that HighlightJS knows what syntax it is marking up.

Inside a lifecycle method `componentDidMount` we invoke HighlightJS.  By default, HighlightJS would automatically search out markup to transform after the page's onload event fired.  However, using HighlightJS with React can be unpredictable. Modifying the document object model (DOM) outside of React's normal render cycles can break react's ability to update when the state of our application changes.  I had to push HighlightJS down to my lowest level components and ensure the content HighlightJS operated on was static; otherwise, issues arose.

By static content; I mean that either `CodeCollapsed` and `CodeFull` render, or they do not.  Once `CodeCollapsed` and `CodeFull` components render, React cannot modify them.  Our parent component, however, can still collapse and expand the content of each section by re-rendering to exchange the collapsed component for the full, or vice versa.  This isolation of each section gives HighlightJS a safe space to operate and make DOM modifications.

Let's look at our `CodeCollapsed` component now.

``` javascript(/client/src/components/nodes/code_collapsed.js)
/* global hljs */
import React, { Component } from 'react';

class CodeCollapsed extends Component {
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_collapsed"));
  }
  
  render() {
    let contents = this.props.contents;
    return (
      <code id={this.props.section_id+"_collapsed"}>
        <pre className={this.props.block_type}>
          <div>
            {contents[0]} 
            <i className="fa fa-arrows-h" aria-hidden="true"></i>
            {contents[contents.length-1].trim()}
            </div>
        </pre>
      </code>
    );
  }
}

export default CodeCollapsed;
```

Here, our component prepares abbreviated content for the section.  We take the first and last line of our content, and renderer an arrow icon between to denote the content can expand.

Finally, I want to make a few updates to our App.css file.

``` css(/client/src/App.css)
img {max-width: 100%;}

#reader-pane img {border: 1px solid #021a40;}

+ code {
+   background-color: rgba(27,31,35,0.05);
+   border-radius: 3px;
+   padding: 0.2em .5em;
+   margin: 0;
+   font-size: 85%;
+ }
+ 
+ .codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
+ .codeGutter .fa { font-size: 12px; opacity: 0; }
+ .lowPrioritySection .fa { opacity: 100; }
+ .lowPrioritySection { cursor: pointer; } 
+ .highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }

pre {white-space: pre-wrap; margin: 0;}

#root .hljs {padding: 0;}

- #reader-pane {
-   margin-top: 85px;
- }

- @media only screen and (max-width: 990px) {
-   #app .banner {
-     margin-left: -10px;
-   }
- }

- @media only screen and (max-width: 767px) {
-  #app #reader-pane {
-    margin-top: 125px;
-  }
- }
```

Take a look at our updated code examples.

![Code Section with Styling](/images/10/StyledCodeSections.png)

We have a few more convenience items to add before we finish.

## Child Components with Refs

One iteration goal was to allow code examples to be copied easily to the clipboard.  That way, readers don't struggle when they want to pull example code from our book.

We complicated this with our support for minimizing blocks of example code.  Now, copying full examples requires users to expand all the minimized sections to capture everything while highlighting.  Let's add some support for a one-click copy function to each example.  Let's also create an expand/minimize all button for each `CodeBlock` component, to fully expand or shrink all an example's sections in one click.

Prep our UI with three buttons: copy, collapse, and expand.  Some semantic UI components can help us quickly create this interface.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
+ import { Popup, Button, Icon } from 'semantic-ui-react'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     return Array.from(sections, s => {
-       return(
-         <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
+         { this.code_fence.block_path ? 
+           <div style={blockHeaderStyles}>
+             { this.code_fence.block_path }
+             <Popup
+               trigger={
+                 <Button icon size="mini" floated="right" color="grey">
+                   <Icon name='plus' />
+                 </Button>
+               }
+               position="bottom center" content='Expand All'
+             />
+             <Popup
+               trigger={
+                 <Button icon size="mini" floated="right" color="grey">
+                   <Icon name='minus' />
+                 </Button>
+               }
+               position="bottom center" content='Collapse All'
+             />
+             <Popup
+               trigger={
+                 <Button icon size="mini" floated="right" color="grey">
+                   <Icon name='copy' />
+                 </Button>
+               }
+               position="bottom center" content='Copy All'
+             />
+           </div> 
+           : null 
+         }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

### Copying Examples to the Clipboard

Our copy functionality is the simplest of these tools to engineer, as we are going to lean on an NPM package [Clipboard.js](https://clipboardjs.com/) to do most of the heavy lifting. 

To install, run `docker-compose exec client yarn add clipboard@2.0.1` in your application directory.

Next, update `CodeBlock` to use this module.  We already have easy access to code examples as strings in our component props, so that gives us a head start.  Make some small modifications to the `CodeFence` class.

``` javascript(/client/src/components/nodes/lib/code_fence.js)
import CodeSection from './code_section';

class CodeFence {
  constructor(node){
    let all_lines = node.content.trim().split("\n");
    
    this.node_id = node.id;
+     this.content_lines = CodeFence.getContentLines(all_lines);
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
+     this.sections = this.parseSections([...this.content_lines]);
  }
  
+   get copy(){
+     return Array.from(this.content_lines, (line) =>{
+       return CodeSection.cleanLine(line);
+     }).join("\n");
+   }
  
-   parseSections = (remaining_lines) => {
-     let current_section, sections = [];
-     
-     while(remaining_lines.length > 0){
-       current_section = current_section || new CodeSection(remaining_lines[0], this.node_id, sections.length);
-       if(current_section.continues(remaining_lines[0])){
-         current_section.appendLine(remaining_lines.shift());
-         if(remaining_lines.length === 0) { sections.push(current_section.completed) }
-       } else {
-         sections.push(current_section.completed);
-         current_section = null;
-       }
-     }
- 
-     return sections;
-   }
  
  static fenceLine = (line) => line.match(/^```/);
  
-   static parseFenceOpen = (first_line) => {
-     if(CodeFence.fenceLine(first_line)){
-       return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
-     } else{
-       return [undefined,undefined];
-     }
-   };
  
-   static getContentLines = (lines) =>
-     CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
}

export default CodeFence;
```

We are modifying our `content_lines` variable to be an instance property, making it is accessible from outside the constructor.  

Our call to `parseSections` needs updating as well.  We're using a destructive `Array.shift()` method, so if we continue to pass in `content_lines`, our parsing of the sections leaves `content_lines` as an empty array.  We could rewrite the `parseSections` to use non-destructive methods.  Alternatively, by changing how we invoke this function, it doesn't receive the array we want to preserve.  I have opted for the later, using a spread operator and array literal to create a new array instance when we invoke `parseSections`.

Finally, a new getter method `copy` gives us a clear interface when we want to retrieve our clipboard content for each example.   Using `Array.from` builds a new array from `content_lines`.  We pass each line through `CodeSection.cleanLine()` to remove priority flags we don't want on our clipboard.  Then we join the members of the array with line breaks, creating a complete string of our example.

Now we can update our code block component.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react'
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     return Array.from(sections, s => {
-       return(
-         <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
+   componentDidMount(){
+     let button = this.triggerCopy.querySelector("button");
+     return new clipboardJS(button, {
+       text: () => this.code_fence.copy
+     });
+   }
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? 
          <div style={blockHeaderStyles}>
            { this.code_fence.block_path }
-             <Popup
-               trigger={
-                 <Button icon size="mini" floated="right" color="grey">
-                   <Icon name='plus' />
-                 </Button>
-               }
-               position="bottom center" content='Expand All'
-             />
-             <Popup
-               trigger={
-                 <Button icon size="mini" floated="right" color="grey">
-                   <Icon name='minus' />
-                 </Button>
-               }
-               position="bottom center" content='Collapse All'
-             />
+             <span ref={ref => this.triggerCopy = ref}>
+               <Popup
+                 trigger={
+                   <Button icon size="mini" floated="right" color="grey">
+                     <Icon name='copy' />
+                   </Button>
+                 }
+                 position="bottom center" content='Copy All'
+               />
+             </span>
          </div> 
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

`ClipboardJS` causes us a small problem; when creating a new instance of `clipboardJS`, we must pass an element to trigger the copy behavior.  If we do this on a user's first click of the copy button, (using an onclick handler), it would instantiate clipboardJS, but wouldn't perform our copy.  We need to instantiate the class **before** someone might click on our button.  

That sounds like a job for lifecycle methods; but how do we register an event handler to an element before it has rendered?

For this React provides us with refs.  The `refs` attribute, added to our JSX elements, provides a callback method that can be used to identify elements.  Just before the component mounts, the ref callback fires.  This callback function receives an instance of the bound element, allowing us to reference a specific rendered node.  In this case, we are wrapping our copy button inside a `<span>` tag.  Our `ref` ties that element to a new instance attribute of our component: `this.triggerCopy`.

Our `ref` (in `this.triggerCopy`) is available before our components lifecycle method `componentDidMount` fires.  Inside `componentDidMount` we register `ClipboardJS` to our ref, configuring it to copy the full code example when clicked.

Notice we can use refs like any other DOM selector.  I had difficulty with Semantic UI not allowing me to tag refs directly onto its components.  I was forced to wrap this button in a span tag carrying the ref.  I could, however, use further selectors against that ref to further narrow my target; `triggerCopy.querySelector("button")` targets the HTML button element inside our referenced span.

Revisit your application with this updated code, and try out the copy button.

### Collapse and Expand All Sections

Let's examine another use case for refs.  How do we implement a function on our parent component (`CodeBlock`) that causes state changes in its child components?

Our parent component isn't even aware its children track an independent state.  In theory, we could rewrite `CodeBlock` and `CodeSection`, ensuring all the state maintenance happens inside the parent `CodeBlock`, then pass state from parent to child as props.

That would be a hassle to build though, especially considering that each example renders an undetermined number of sections.  Plus, only a subset of those sections **do anything** with the collapsed/expanded state.  Our high and normal priority sections blissfully ignore the expand/collapse behavior.  However, if we agree that the state should live in our child `CodeSection` components, how do we mass-update their state from a parent?  Luckily, we have refs for that.

To begin, we need a method which assigns a specific state to `state.collapsed` inside of our `CodeSection` components.

``` javascript(/client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

- const codeSectionStyle = {
-   display: "table-row",
-   padding: "0 5px",
-   lineHeight: "100%"
- };

- const codeGutterStyle = {
-   display: "table-cell",
-   padding: "0 5px"
- };

- const codeBodyStyle = {
-   margin: 0,
-   display: "table-cell",
-   width: "100%",
-   paddingRight: "10px",
- };

class CodeSection extends Component {
-   constructor(props){
-     super(props);
-     if(props.priority === "low"){
-       this.minimizedContent = props.contents[0];
-       this.state = {collapsed: true};
-     } else { this.state = {collapsed: false} }
-   }

-   renderSectionContent = () => {
-     let p = this.props;
-     return this.state.collapsed ? <CodeCollapsed {...p} /> : <CodeFull {...p} />;
-   }
  
-   toggleCollapse = (e) => {
-     if(this.props.priority === "low"){
-       this.setState({collapsed: !this.state.collapsed});
-     }
-   };
  
+   setCollapse = (bool) => {
+     if(this.props.priority == "low"){
+       this.setState({collapsed: bool});
+     }
+   };
  
-   render() {
-     let priority = this.props.priority;
-     let icon = this.state.collapsed ? "plus" : "minus"; 
-     
-     return (
-       <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={codeSectionStyle}>
-         <div className="codeGutter" style={codeGutterStyle}>
-           <i className={"fa fa-"+ icon +"-square-o"}></i>
-         </div>
-         <div className="codeBody" style={codeBodyStyle} id={this.props.section_id}>
-           { this.renderSectionContent() }
-         </div>
-       </div>
-     );
-   }
}

export default CodeSection;
```

Next, we need to setup refs to create a path for us to invoke this function.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react'
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
  renderCodeSections = (sections) => {
+     this.section_refs = [];
    return Array.from(sections, s => {
      return(
+         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
+         contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
+   collapseSections = (bool) => {
+     this.section_refs.forEach((ref) => {
+       if(ref){ ref.setCollapse(bool) }
+     });
+   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? 
          <div style={blockHeaderStyles}>
            { this.code_fence.block_path }
            <Popup
              trigger={
+                 <Button onClick={()=>this.collapseSections(false)}
+                 icon size="mini" floated="right" color="grey">
+                   <Icon name='plus' />
+                 </Button>
              }
              position="bottom center" content='Expand All'
            />
            <Popup
              trigger={
+                 <Button onClick={()=>this.collapseSections(true)}
+                 icon size="mini" floated="right" color="grey">
+                   <Icon name='minus' />
+                 </Button>
              }
              position="bottom center" content='Collapse All'
            />
            <span ref={ref => this.triggerCopy = ref}>
              <Popup
                trigger={
                  <Button icon size="mini" floated="right" color="grey" onClick={this.copyToClipboard}>
                   <Icon name='copy' />
                  </Button>
                }
                position="bottom center" content='Copy All'
              />
            </span>
          </div> 
          : null 
        }
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We are updating `renderCodeSections` to create an array of refs for our sections as we render them.  These refs grant access to each instance of `CodeSection` that `CodeBlock` creates.  More importantly, we can use those refs to invoke the new `setCollapse` instance method within each section.

From there, this looks like any other click handler we might create.

`collapseSections` takes a single boolean value.  When invoked, it loops through our refs, calling `ref.setCollapse`, and passing a boolean value.  Then, by wrapping our call to `collapseSections` in an anonymous function and passing the correct boolean value, we can reuse `collapseSections` to serve both the expand and collapse actions.

### Sharing Refs with Parent and Child

Good so far, but I fear our `CodeBlock` component has again grown too large.  Let's move the header content out of our `CodeBlock` component to isolate the behavioral code driving our buttons.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { 
          this.code_fence.block_path ?
+           <CodeHeader block_path={this.code_fence.block_path} collapseHandler={this.collapseSections} />
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We are now referring to the entire header section as a single component, and passing in the few props it needs; the `block_path` and `collapseHandler` function.

Here's the matching `CodeHeader` setup for our refactor.

``` javascipt(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react';

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

class CodeHeader extends Component {
  render() {
    return (
      <div style={blockHeaderStyles}>
        { this.props.block_path }
        <Popup
          trigger={
            <Button onClick={()=>this.props.collapseHandler(false)}
            icon size="mini" floated="right" color="grey">
              <Icon name='plus' />
            </Button>
          }
          position="bottom center" content='Expand All'
        />
        <Popup
          trigger={
            <Button onClick={()=>this.props.collapseHandler(true)}
            icon size="mini" floated="right" color="grey">
              <Icon name='minus' />
            </Button>
          }
          position="bottom center" content='Collapse All'
        />
        <span ref={ref => this.triggerCopy = ref}>
          <Popup
            trigger={
              <Button icon size="mini" floated="right" color="grey">
               <Icon name='copy' />
              </Button>
            }
            position="bottom center" content='Copy All'
          />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

Our click handler for the collapse and expand buttons passes as a prop from `CodeBlock`.  `collapseSections` takes on a new name, `collapseHandler` when passed a prop from the parent component.  However, its use is unchanged.  When invoked from within a child component, `this` still references our parent `CodeBlock` component.  That allows us to access the `this.section_refs` array on the parent `CodeBlock` from inside `CodeHeader`, and fire the open/collapse for each section.  

What about our ref on the copy button?  We've passed a reference down from the parent, can we pass a ref up just as easily from the child?

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { 
          this.code_fence.block_path ?
+           <CodeHeader block_path={this.code_fence.block_path} 
+           collapseHandler={this.collapseSections} triggerRef={(trigger) => this.triggerCopy = trigger} />
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

Creating a prop `triggerRef` for our `CodeHeader` component, we pass a function used to register a ref.  This function sets `this.triggerCopy` inside `CodeBlock`, relying on `this` to reference our parent, even when invoked inside a child.

However, its `CodeHeader` that actually uses this function to assign a ref on an element.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react';

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

class CodeHeader extends Component {
  render() {
    return (
      <div style={blockHeaderStyles}>
        { this.props.block_path }
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />

+          <span ref={this.props.triggerRef}>
          <Popup
            trigger={
              <Button icon size="mini" floated="right" color="grey">
               <Icon name='copy' />
              </Button>
            }
            position="bottom center" content='Copy All'
          />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

Just like that, we restore support for our copy button inside the child component.

I am going to do a bit of final cleanup on the `CodeBlock` render before we close out.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#F0F0F0",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
+   renderHeaderIf = (block_path) => {
+     if(block_path){ return( 
+       <CodeHeader 
+         block_path={this.code_fence.block_path} 
+         collapseHandler={this.collapseSections}
+         triggerRef={(trigger) => this.triggerCopy = trigger} 
+       />
+     )}
+   };
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
+         { this.renderHeaderIf(this.code_fence.block_path) } 
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

## Summary

Our code examples are now far richer than the default renderings provided by our out-of-the-box markdown processors.

We introduced several new composability patterns for React components: 
* Using ES2015 classes to encapsulate work.
* Mixing local component state with our Redux store
* Using refs to manipulate element behaviors across parent and child components.

There are still significant gaps in our code examples.  Most notably, support for small mobile screens.  In a future iteration, we might need to address this with device-specific rendering.  For now, we are putting a pin in this.

In the next chapter, we introduce a token-based authentication system.  This login system allows us to save the user's reading position across several visits.  See you there.