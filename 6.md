# Chapter 6: Layout with React & Redux

We resisted focusing on our UI in these first five chapters while configuring our application's internals. With scaffolding in place, let's spend an iteration building a layout that looks more like real software, and less like a pile of raw text.

In this chapter and iteration we:
* Use Semantic UI for rapid layout prototyping
* Refactor our `App.js` component into several focused sub-components. 
* Add client-side translation of Markdown into HTML
* Introduced a `chapters` endpoint, client-side storage, and supporting actions.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

```bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch6-starter
```

## Semantic UI, Up and Running

UI libraries abound in the React ecosystem; including component libraries for Material-UI, Semantic-UI, Bootstrap, and I am sure dozens more of which I am not even aware.  

Semantic and Material UI, both offer component libraries which feel like natural extensions to React.  I tend to favor Material UI for small-scale UIs like mobile screens, or browser extensions.  However, I prefer Semantic when desktop UIs are a primary audience, so that's what we are using for this project.

Installing Semantic UI is a snap, just run the following command through docker-compose; `docker-compose exec client yarn add semantic-ui-react@0.82.5`

We also need CSS assets for Semantic in our project.  Semantic's documentation offers several approaches; I am going to opt for referencing the CSS files from a CDN.  To do so, add the following to your index.html file.

``` html(/client/public/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
-     <!--
-       manifest.json provides metadata used when your web app is added to the
-       homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
-     -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
+     <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css"></link>
-     <!--
-       Notice the use of %PUBLIC_URL% in the tags above.
-       It will be replaced with the URL of the `public` folder during the build.
-       Only files inside the `public` folder can be referenced from the HTML.
-       Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
-       work correctly both with client-side routing and a non-root public URL.
-       Learn how to configure a non-root public URL by running `npm run build`.
-     -->
    <title>React App</title>
  </head>
-   <body>
-     <noscript>
-       You need to enable JavaScript to run this app.
-     </noscript>
-     <div id="root"></div>
-     <!--
-       This HTML file is a template.
-       If you open it directly in the browser, you will see an empty page.
-       You can add webfonts, meta tags, or analytics to this file.
-       The build step will place the bundled scripts into the <body> tag.
-       To begin the development, run `npm start` or `yarn start`.
-       To create a production bundle, use `npm run build` or `yarn build`.
-     -->
-   </body>
</html>
```

## Scaffolding a Layout

When building UI in React, I start working a single file.  Seeing the whole helps highlight where logical divisions are for components.  With that in mind, let's make some temporary changes to our App component.

First, add a bit of navigation,  creating a placeholder control to allow readers to flip between chapters.  Our example adapts a layout starter provided on Semantic UI's website.  I am not qualified to make design decisions without adult supervision, so this approach gives gains us some professional guidance.

Open `client/src/App.js`, and let's get to work.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
+ import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import axios from 'axios';
import {loadNodes } from './actions/nodes';
+ import rrLogo from './assets/images/reactivating-rails.png';
import './App.css';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
  paddingTop: "8px",
  paddingBottom: "8px"
};

- const mapStateToProps = (state) => ({
-   book_body: state.nodes
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {
-       content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)
-     });
-     return content_blocks;
-   }
  
+   render() {
+     return (
+       <div id="app">
+         <Menu borderless stackable fixed="top" style={ fixedMenuStyle }>
+           <Container>
+             <Menu.Item><Image width='200' src={rrLogo} /></Menu.Item>
+ 
+             <Menu.Menu position='right'>
+               <Dropdown text='Jump to Chapter...'
+                 pointing className='link item'>
+                 <Dropdown.Menu>
+                   <Dropdown.Item>List Item</Dropdown.Item>
+                   <Dropdown.Item>List Item</Dropdown.Item>
+                 </Dropdown.Menu>
+               </Dropdown>
+             </Menu.Menu>
+           </Container>
+         </Menu>
+         <div id="reader-pane">
+           <Container text>
+             { this.renderContentBlocks(this.props.book_body)}
+           </Container>
+         </div>
+       </div>
+     );
+   }
}

- export default connect(
-   mapStateToProps,
-   mapDispatchToProps
- )(App);
```

First, some quick housekeeping; create a folder for image files at `client/assets/images` directory.  Once your folder is created, [download this image](https://www.dropbox.com/s/p5fii5v3xq1hkuh/reactivating-rails.png?dl=0) and save it as `reactivating-rails.png` inside your new directory.

Next, copy the updated `render` method from the example above to your local project. We aren't going to go through this code line by line.  Semantic UI is a large project; I can't document its components in the scope of this book. Besides, excellent documentation is already available on [the Semantic-UI React Website](https://react.semantic-ui.com).  I'll cover some components we use heavily, but for others, please supplement from the official documentation as needed.

Luckily most Component names in Semantic UI are, well... semantic.

### Some Thoughts on Styles

At the top of our altered file, we are defining a JavaScript style object.  There are many ways to style React components: inline styles, style objects, or external stylesheets.  Not to mention the many libraries working to solve this problem.

I am skeptical to completely abandon external stylesheets as some advocate for when working with React.  However, the lines between presentation, structure, and behavior in React are already blurred.  It's hard to argue that externalizing all our styles is imperative.  There's a real reusability advantage to keeping styles embedded with our components.

Locally styling components, and limiting external CSS to global style rules is my compromise.  If we need to reuse styles beyond a single component, we'll favor external CSS.  For everything else, we can stay close to our components.

### Inline Style Syntax

If you haven't used JavaScript styles before, the syntax easily translates if you are familiar with CSS.

Hyphenated style names drop their hyphen in favor of camel case name.  So `padding-left`, becomes `paddingLeft`.  Styles accept integers values in some cases, but to pass specific units, such as `"5px"` you can rely on string values.

With the above `App.js` updates in place, let's check our rendering.

![Semantic-UI Reworked Application Layout](/images/6/SemanticUILayoutRework.png)

## Slicing Up Components

It's time for a long overdue refactor on our App component.

We have a **lot** happening in one component.  We are making API calls, connecting to Redux, dispatching actions, and building an entire layout.  Now, with a foundation set, we can start making more thoughtful decisions on separating concerns.

### Container Components

Let's start with a look at how we render nodes since our server-side work here is complete(ish).

Create two new directories in your client folder, `src/components` and `src/containers`.

Next, create a file `src/components/reader_pane.js`.  Inside, set up a new component, and migrate some code from `App.js`.

``` javascript(/client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {
      content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)
    });
    return content_blocks;
  }
  
  render() {
    return (
      <div id="reader-pane">
        <Container text>
          { this.renderContentBlocks(this.props.book_body) }
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

This example is about as simple as React Components come.  We are externalizing our reader's viewport into its own components.  That way, we isolate logic for rendering nodes from the App component, making our markup more readable.  Now, when included in our App component, this work is abstracted using the more readable name `ReaderPane` to describe what renders.

Let's look at what our App component would look like with this change.

``` javascript((/client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import axios from 'axios';
import { loadNodes } from './actions/nodes';
+ import ReaderPane from './components/reader_pane';
import rrLogo from './assets/images/reactivating-rails.png';
import './App.css';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   paddingTop: "8px",
-   paddingBottom: "8px"
- };

- const mapStateToProps = (state) => ({
-   book_body: state.nodes
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {
-       content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)
-     });
-     return content_blocks;
-   }
  
  render() {
    return (
      <div id="app">
        <Menu borderless stackable fixed="top" style={ fixedMenuStyle }>
          <Container>
            <Menu.Item><Image width='200' src={rrLogo} /></Menu.Item>

            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...'
                pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
+         <ReaderPane book_body={this.props.book_body} />
      </div>
    );
  }
}

- export default connect(
-   mapStateToProps,
-   mapDispatchToProps
- )(App);
```

A step in the right direction... but I still see at least two problems.  

For one, we rely on a prop `book_body` being passed into `ReadPane` when it renders.  Our `App` component doesn't have any business orchestrating what nodes render in this specialized child component.  What does this look like when we only want to print one chapter, or a few sections at once?  Filtering to a subset of content seems like inappropriate work for a component primarily concerned with the global layout.

Let's build a better foundation, and reap some extra cleanup while we are at it.

### React Containers

Create a new component, `src/components/nodes_list.js`, and populate the file as follows.

``` javascript(/client/src/components/nodes_list.j)
import React, { Component } from 'react';

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
      nodes_list.push(<p key={node.id}>{node.content}</p>)
    });
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

Our new NodesList component has one task; it receives an array of nodes and prints them.  We are also updating variable names to match the "node" concept defined by our API; dropping names like `book_contents` used in the wild-west day of chapters 1 and 2.

This step allows us to remove the node looping and printing from `ReaderPane`.  We still need to pass nodes as a prop to the component.  We just moved the work downstream.  

This situation is where containers come into play.  React convention is to distinguish between components that manage store connections, from those that handle presentation.  With Redux, that means giving a certain level of prestige to components we connect to the store; separating the logic centers of our application from presentational elements.

Go ahead and create another file `src/containers/filtered_nodes_list.js`.  

``` javascript(/client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

const mapStateToProps = (state) => ({
  nodes: state.nodes
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

Remember in chapter four we said `connect` returns a function which is immediately invoked using another component; and **that** function returns a new component, merging our store state with component's existing properties?  We are about to see that magic in action when we call a component we never technically defined, `FilteredNodeList`.

mapStateToProps can solve our need to manually pass around a property containing nodes for our component to render.  Instead, the new container fetched them from the store.  The component dynamically created by `connect` handles the work of selecting the appropriate nodes from our store.  Leaving our `NodesList` component focused on their visual rendering.

We could have contained the `NodeList` component and our work with `connect` in a single file for the same result.  Defining the connect/container code as its own module isolates the selection of what render from how it looks and behaves in our UI.  As we start adding complexity, filtering what we choose to print, this separation of concerns encourages clarity.

### ReaderPane Reassembled

Now, return to our `ReaderPane` component and pull everything together.  Remember though that I said I saw two problems?  Right now, our `App` component calls `<ReaderPane book_body={this.props.book_body} />`, passing it a rigidly names `book_body` prop to indicate what it should render.  

What happens if we want to reuse this component to print something else?  We would have to use that same prop name `book_body` regardless of what we rendered.  We can add flexibility by configuring `ReaderPane` to expect nested child components using the `children` property.  This specially named prop contains any elements passed via JSX nesting.

``` javascript(/client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  render() {
    return (
      <div id="reader-pane">
        <Container text>
+         { this.props.children }
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

Finally, pull it all together in `App.js`.  Pay attention to our use of the `ReaderPane` component and `FilteredNodeList`.  We've removed `mapStateToProps` from `App.js` now that we have our `FilteredNodeList` container manages the retrieval of nodes from our store.  Passing `null` to the first parameter of `connect` ensures that `mapDispatchToProps` correctly populates the second parameter.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import axios from 'axios';
import { loadNodes } from './actions/nodes';
import ReaderPane from './components/reader_pane';
+ import FilteredNodesList from './containers/filtered_nodes_list';
import rrLogo from './assets/images/reactivating-rails.png';
import './App.css';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   addingTop: "8px",
-   paddingBottom: "8px"
- };

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(
-       <p key={content_blocks.length}>{block.content}</p>
-     )});
-     return content_blocks;
-   }
  
  render() {
    return (
      <div id="app">
        <Menu borderless stackable fixed="top" style={ fixedMenuStyle }>
          <Container>
            <Menu.Item><Image width='200' src={rrLogo} /></Menu.Item>

            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...'
                pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
+         <ReaderPane>
+           <FilteredNodesList />
+         </ReaderPane>
      </div>
    );
  }
}

export default connect(
+   null,
  mapDispatchToProps
)(App);
```

Make sure you understand the interplay between `ReaderPane`, `FilteredNodeList`, and `NodeList` before moving forward.  `Nodelist` handles the presentation of nodes, and builds a collection of elements for us.  However, it's called in `ReaderPane` with our `FilteredNodeList` container supplying the nodes to render.

## Moving Towards Navigation

Let's split out our menu into its own component to isolate our navigation elements.

Create a new file `src/components/menu_bar.js`, and migrate the menu from our `App` layout.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import rrLogo from '../assets/images/reactivating-rails.png';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
  paddingTop: "8px",
  paddingBottom: "8px"
};

class MenuBar extends Component {
  render() {
    return (
        <Menu borderless stackable fixed="top" style={ fixedMenuStyle }>
          <Container>
            <Menu.Item><Image width='200' src={rrLogo} /></Menu.Item>

            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...'
                pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Again, you can trim down `App.js` to accommodate this new component.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import axios from 'axios';

import { loadNodes } from './actions/nodes';
import ReaderPane from './components/reader_pane';
+ import MenuBar from './components/menu_bar';
import FilteredNodesList from './containers/filtered_nodes_list';
import './App.css';

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(
-       <p key={content_blocks.length}>{block.content}</p>
-     )});
-     return content_blocks;
-   }
  
  render() {
    return (
      <div id="app">
+       <MenuBar />
        <ReaderPane>
          <FilteredNodesList />
        </ReaderPane>
      </div>
    );
  }
}

- export default connect(
-   null,
-   mapDispatchToProps
- )(App);
```

## Spinning up New Endpoints

Before we can develop navigation to move between chapters we need to load that content from our API.  Let's run through that now to refresh what we covered in the first few chapters without the interruptions of installing and configuring new packages.

I this exercise helps you appreciate how easy all this foundational work makes development once the pieces are in place.  Since we're already working client-side, let's start there. 

### Client Setup, Round 1 (Fight!)

First, define a new action in a constants file, `src/constants/chapters.js`.

``` javascript(/client/src/constants/chapters.js)
export const LOAD_CHAPTERS = "LOAD_CHAPTERS";
```

Then, create an action-creator in `src/actions/chapters.js`.

``` javascript(/client/src/actions/chapters.js)
import * as constants from '../constants/chapters';

export const loadChapters = (payload) => ({type: constants.LOAD_CHAPTERS, payload});
```

Expecting our API to pass an array of elements is working well with Nodes, so we use that same pattern with our `loadChapters` action creator.  We should set up a snapshot test though so that we at least get an alert if there's a change to this action creator's output.  Create `src/actions/chapters.spec.js` as follows.

``` javascript(/client/src/actions/chapters.spec.js)
/* global expect */
import * as actions from './chapters';

describe("Chapters actionCreators", ()=>{
  test("loadChapters(chapters)", ()=>{
    expect(actions.loadChapters([{contents: "chapter"}])).toMatchSnapshot();
  });
});
```

Next, create a reducer for this action.  Since I want our chapters stored under a different key in our store, I create a new sub-reducer in `src/reducers/chapters.js`.

``` javascript(/client/src/reducers/chapters.js)
import * as constants from '../constants/chapters';

let default_state = [];

export const sortChapters = (chapters) => {
  return chapters.sort((a,b) =>{
    return a.id - b.id;
  });
};

const chaptersReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.LOAD_CHAPTERS):
      return [...sortChapters(action.payload)];
    default:
      return state;
  }
};

export default chaptersReducer;
```

This reducer should look very similar to our nodesReducer function its load action.  We've simplified the sort function since we don't need a multi-level sort on chapters.  The amount of overlap here likely indicates an opportunity to refactor and DRY up this code.  Given the small amount of code we are talking about, I am content to let it ride until it becomes a problem.

Add some test coverage here as well by setting up `src/reducers/chapters.spec.js`.

``` javascript(/client/src/reducers/chapters.spec.js)
/* global expect */
import  chaptersReducer, { sortChapters } from './chapters';
import * as actions from '../actions/chapters';

let defaultState = [];
let newState = [{title: "Test chapter"}];
let sampleChapters = [
  {id: 7, title: "Second"},
  {id: 8, title: "Third"},
  {id: 6, title: "First"}
];

describe("chapters Reducer", ()=>{
  test("sortChapters orders by id", ()=>{
    expect(sortChapters(sampleChapters)).toMatchSnapshot();
  });
  
  test("LOAD_CHAPTERS overwrites chapters array",()=>{
    expect(
      chaptersReducer(defaultState,actions.loadChapters(newState))
    ).toEqual(newState);
  });
});
```

Be sure to look at the generated snapshot for the sortChapters function before you move on!  Testing against a snapshot of an inaccurate outcome wouldn't be any help at all.

Don't forget to add the new sub reducer to `combineReducers` in `src/reducers/store.js`.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers } from "redux";
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
  combineReducers({nodes, chapters})
);

export default store;
```

At this point, I'd turn to the browser console and quickly check that we have wire everything correctly.  We should have a new key `chapters` in our store, with a default state of `[]`.  The store should also accept a dispatched `LOAD_CHAPTERS` action to update that array.

![Test dispatches](/images/6/TestDispatches.png)

We're ready to receive chapter data from the API, so let's switch over to Rails.

### Chapters From our API

Let's start by defining a route for the new action.  As with nodes, set up an index action since we want to return all chapters from a single endpoint.

``` ruby(/api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
    get 'nodes/', to: "nodes#index"
+     get 'chapters/', to: "chapters#index"
  end
end
```

We need a matching chapters controller, so create a new file `app/controllers/api/chapters_controller.rb`.  We don't have an `fsa` scope defined in our Chapter model yet, but I'm going to write our controller on the assumption we soon will.

``` ruby(/api/app/controllers/api/chapters_controller.rb)
class Api::ChaptersController < ApplicationController
  def index
    payload = Chapter.all.fsa
    render json: payload, status: 200
  end
end
```

Now drop into our model and build out that scope.  For now, all I need client-side for our Chapter model is each title and ID.

``` ruby(/api/app/models/chapter.rb)
class Chapter < ApplicationRecord
    has_many :nodes
    
    scope :fsa, -> { order(id: :asc).select(:id, :title) }
end
```

Now, just as we did a quick smoke-test in the browser for the client side of this iteration, we can do a similar test API-side using curl.

``` bash
# curl http://localhost/api/chapters

[{"id":1,"title":"Chapter 1: Introduction"},{"id":2,"title":"Chapter 2: React, Rails, and Docker (Oh my)."},{"id":3,"title":"Chapter 3: Loading and Displaying Basic Content"}, ...]
```

If you got back an Array of chapter elements, you are in good shape.  Switch back to the client for the finishing touches.

### Calls and Containers

For the moment, we are going to build another API call for fetching chapters in a new container component.  I don't love or wish to advocate this approach, but it's our current path of least resistance.   Externalizing API calls is one of the last remaining tasks in cleaning up our components; we do just that in a coming chapter using Redux Saga.  

For now, bear with me and know that this isn't an ideal solution.

Create a new file `src/containers/chapter_menu_items.js`. We are going to echo the approach used in `FilteredNodesList` and split our store connection from the rendering of our UI.  We need a container providing the store's chapters key, and a dispatch function for our `loadChapters` action creator.

``` javascript(/client/src/containers/chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Then we can set up a component to handle the render of this area of our UI.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
  componentWillMount(){
    axios.get("/api/chapters")
    .then(
      (response) => {
        this.props.dispatchLoadChapters(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderChapterMenuItems = (chapters) => {
    let chapters_list = [];
    chapters.forEach((chapter) => {
      chapters_list.push(
        <Dropdown.Item key={"chapter_" + chapter.id} id={chapter.id}>
          {chapter.title}
        </Dropdown.Item>
      );
    });
    return chapters_list;
  }
  
  render() {
    return (
      <Dropdown text='Jump to Chapter...' className='link item'>
        <Dropdown.Menu>
          { this.renderChapterMenuItems(this.props.chapters) }
        </Dropdown.Menu>
      </Dropdown>
    );
  }
}
```

This single component contains most of the tools we have used thus far.  If you are comfortable with this code that’s a good sign you are keeping up with the concepts we have covered.

You need to update your `MenuBar` component as well to account for this new container/component.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
+ import { Container, Image, Menu } from 'semantic-ui-react';
import rrLogo from '../assets/images/reactivating-rails.png';
import ChapterMenuItems from '../containers/chapter_menu_items';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   paddingTop: "8px",
-   paddingBottom: "8px"
- };

class MenuBar extends Component {
  render() {
    return (
        <Menu borderless stackable fixed="top" style={ fixedMenuStyle }>
          <Container>
            <Menu.Item><Image width='200' src={rrLogo} /></Menu.Item>

            <Menu.Menu position='right'>
+               <ChapterMenuItems />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

That is it, we are up and running with our chapters content.  Granted this new menu doesn't **do** anything yet. To change that, we need to talk about an area of application state we've been ignoring: the URL bar.  For that, we need to configure a client-side router.  

Before that undertaking, there's one last improvement I can't resist making.

## Client Side Markdown

We've now sunk some effort into the look and feel of our application, and raw markdown syntax showing through in our nodes is beginning to bum me out.  Before entering the wonderful world of routing in chapter seven, let's take a pass at an initial markdown parser for our client.

If we get it configured now, we can noodle over how well the out-of-the-box behavior treats us.  Then decide what, if anything we might want to improve in future iterations.

I am going to take that first pass using a package called [MarkdownIt](https://github.com/markdown-it/markdown-it).

To setup, we first need to install the package with NPM, `docker-compose exec client yarn add markdown-it`.

Then, open our `NodesList` component.

``` javascript(/client/src/components/nodes_list.js)
import React, { Component } from 'react';
+ import MarkdownIt from 'markdown-it';
+ const md = new MarkdownIt();

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
+       nodes_list.push(
+         <p key={"node_" + node.id} dangerouslySetInnerHTML={
+           {__html: md.render(node.content)}
+         } />
+       );
    });
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

We're modifying `NodesList` to leverage MarkdownIt’s rendering as we loop our nodes.  We've updated our generated paragraph tags to use the `dangerouslySetInnerHTML` prop.  As the name suggests, there is some danger involved here.  By default, React/JSX escape content when we render strings within an element.  So our HTML tags would print visibly the browser `<p>some content....`.  We want the browser to render our translated HTML tags as part of the DOM.

The name of `dangerouslySetInnerHTML` is designed to be frightening; we should be very thoughtful about where and when we use this tool.  By disabling the automatic escaping of elements, we risk opening our application to Cross Site Scripting (XSS) attacks.  Loading content this way from unsafe sources could leave to your application rendering and executing malicious code.

Since we control the only API endpoint, we're rendering, and the content it serves, I believe it's an acceptable risk.  That might change if we ever begin rendering content we don't control.

Those changes made, let's check out our rendering!

![Updated layout with basic markdown rendering](/images/6/MarkdownBasicRender.png)

Not bad for such a minimal bit of work!  There are some immediate problems though.  First off, all our automatically generated image links broke.  The local file paths expect our images at `/images/...`, on our client server's address.  In production though, all content would be served from our Rails application server.  Therefore, we should move the images into `app/public/images/...` so that we are production ready.  In development, our request proxy goes looking for images there as well once they are found MIA on the client.

There is also some CSS cleanup we can do.  Our code blocks, for example, are being generated inside HTML `<pre>` tags and overflow the max line length to run off the screen.

Our images also render at their native resolutions and blow out our layout.

We can address all 3 of these issues quickly.  To start, we need to update our `rr:load_book` rake task to perform our image file move.  That's a unique enough task to justify creating a new class.  Create a new file `lib/loader/book_image_finder.rb`.

``` ruby(/api/lib/book_image_finder.rb)
class BookImageFinder
    attr_reader :entries
    
    def initialize(path)
       @path = normalize_folder(path) 
       @entries = filter_image_dirs(Dir.entries(@path))
    end
    
    def copy_files_to_public
      entries.each do |file_name|
        file_path = expand_file_path(file_name)
        FileUtils.cp_r(file_path,"#{Rails.root}/public/")
      end
    end
    
    private
      def normalize_folder(path)
        path[-1] == "/" ? path : path + "/"
      end
      
      def filter_image_dirs(raw_file_list)
          raw_file_list.select do |file|
              file_path = expand_file_path(file)
              Dir.exists?(file_path) && file != "." \
                && file != ".." && file != ".git"
          end
      end
      
      def expand_file_path(file_name)
          @path + file_name
      end
  end
```

This class is very similar to our file finder class, but it assumes that any subdirectories of our book contain image assets for our chapters.  When the class instantiates, we remove all files and the `.` and `..` directories from our array of entries.  We provide a public method for the class, `copy_files_to_public` which loops directories and performs a recursive copy into `public/ `.

We should also create a new spec, `/api/spec/lib/book_image_finder_spec.rb`.  I plan to stop tests short of actuals copying files.  I would rather avoid the headaches of cleaning up our file system between test runs.  Since copying file is an internal function of Ruby, I trust that behavior to work if we have identified the right files to relocate.

``` ruby(/api/spec/lib/book_image_finder_spec.rb)
require 'rails_helper'
require 'book_image_finder'

RSpec.describe BookImageFinder do
  it "removes files, and relative DIR paths from entries" do
    path = "spec/lib/testbook/"
    entries = BookImageFinder.new(path).entries
    expect(entries.length).to eq 1
    expect(entries[0]).to eq "images"
  end
  
  it "enforces proper file path" do
    path = "spec/lib/testbook/"
    bad_path = "spec/lib/testbook"
    expect(BookImageFinder.new(path).entries).to \
      eq BookImageFinder.new(bad_path).entries
  end
end
```

You need to add a new folder `api/spec/lib/testbook/images` to your project for your specs to pass.  We are ensuring our impoter discards the `.` and `..` entries from its targets, and limits itself to only the new `images/` directory.

Next, update our Rake task to use this new Class.

``` ruby(/api/lib/tasks/rr.rake)
require "#{Rails.root}/lib/book_file_finder"
+ require "#{Rails.root}/lib/book_image_finder"
require "#{Rails.root}/lib/chapter_file"

namespace :rr do
  desc "Import content at lib/reactivating-rails/"
  task load_book: :environment do
    puts "Loading book content..."
+     book_path = "#{Rails.root}/lib/reactivating-rails"
+     entries = BookFileFinder.new(book_path).entries
+     images = BookImageFinder.new(book_path)
+     
+     puts "Copying image files to public/images..."
+     images.copy_files_to_public
    
    entries.delete_if do |file|
      ChapterFile.new(file).invalid?
    end
    
    entries.each do |file|
      chapter = ChapterFile.new(file)
      chapter.save
      
      chapter.body.each do |node|
        chapter.record.nodes.create(
          node_type: node.type.to_s, content: node.to_commonmark
        )
      end
    end
  end

  desc "Clear content of previously loaded iterations"
  task clear_book: :environment do
    puts "Clearing book content..."
  end
end
```

Run the task to update your public directory with the required image assets.  

``` bash
docker-compose exec api bin/rails db:reset && \
docker-compose exec api bin/rails rr:load_book
```

Now, all we need is some CSS.  We can use a max-width on our `<img>` elements inside `#reader-pane` to ensure images get scaled down if they are too large for our screen area.  Also, our `<pre>` tags can be told to wrap lines when needed.

Update `App.css` as follows.

``` css(/client/src/App.css)
img {max-width: 100%;}

pre {white-space: pre-wrap}

#reader-pane {
  margin-top: 85px;
}

@media only screen and (max-width: 990px) {
  #app .banner {
    margin-left: -10px;
  }
}

@media only screen and (max-width: 767px) {
 #app #reader-pane {
   margin-top: 125px;
 }
}
```

Media-specific styles are something we can't handle directly in our components.  When I need a media-specific rule, I transition all styles for that element to the stylesheet, keeping them in one location.  That is why we now see the `#reader-pane` element styled here.

Finish up, and look at all we have accomplished.

## Wrapping Up

We made some rapid progress in this chapter, introducing a new layout, and laying the groundwork for navigation and routing.  We also iterated through the entire process of adding support for a new action, including defining our API endpoint, reducers, and tying it all together in components.

Before we move on, I would like to mention testing briefly.  As we've added tests for other areas of our application, I neglected our components.  

I tend to run light on component tests and rely on the tools I use to test their internal operations.  I only introduce component tests to validate complex UI transformations between state and prop changes on a component.  We haven’t built anything yet to warrant that effort. We'll get to this topic in a later chapter, but for now, sit tight.

In the next chapter, we introduce a client-side router, and finally, add some "pages" to our single page application.
