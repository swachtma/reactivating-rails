# Chapter 6: Layout with React & Redux

We have resisted the urge to focus on our UI for the first four chapters while we set up some internals for our application.  With most of the scaffolding in place, I think we deserve to spend an iteration making our application look more like a real piece of software and less like a raw code dump to the screen. 

In this chapter, we will be using Semantic UI for some rapid layout prototyping. We will also be refactoring our now very bloated `App.js` component into more manageable units.  Then finally, cleaning up our book’s node content rendering and introducing a chapters data model to our application.

## Semantic UI, Up and Running

There are no shortages of rapid prototyping libraries available to us in the React sphere.  Most notably we have component libraries for Material-UI, Semantic-UI, and Bootstrap, to say nothing of the I am sure dozen or of which I am not even aware.  

All have their pros and cons, though my personal preference (and it is just that), leans towards Semantic and Material UI.  I have been a longtime user of bootstrap in my Rails applications.  However, the React component migrations of the Bootstrap library have always felt like a monkey patch to me.  Bootstrap has always been very reliant on CSS classes to carry a significant share of its component formatting.  In the React world, where we tend to focus on self-contained and composable components (and less on CSS style), the migration of bootstrap has never lined up for me.

Semantic UI, and Material UI both feel like natural extensions to React.  I tend to favor Material UI for smaller scale UIs (such as mobile screens, or browser extensions).  However, I favor Semantic when I intend to support larger desktop UIs.  So, we are primarily going to use Semantic for this project.

Installing is a snap Semantic UI is a snap.

```
npm install semantic-ui-react --save
```

We also need to include the CSS assets for Semantic into our project.  The docs for Semantic gives us several approaches for this, but since I do not intend to do any custom theme work for the moment, I am going to opt for the most straightforward install method.  That is, referencing the CSS files from a CDN.  To do so, add the following to your index.html file.

``` html(/reactive-client/public/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
-     <!--
-       manifest.json provides metadata used when your web app is added to the
-       homescreen on Android. See https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
-     -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
+     <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css"></link>
-     <!--
-       Notice the use of %PUBLIC_URL% in the tags above.
-       It will be replaced with the URL of the `public` folder during the build.
-       Only files inside the `public` folder can be referenced from the HTML.
-       Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
-       work correctly both with client-side routing and a non-root public URL.
-       Learn how to configure a non-root public URL by running `npm run build`.
-     -->
    <title>React App</title>
  </head>
-   <body>
-     <noscript>
-       You need to enable JavaScript to run this app.
-     </noscript>
-     <div id="root"></div>
-     <!--
-       This HTML file is a template.
-       If you open it directly in the browser, you will see an empty page.
-       You can add webfonts, meta tags, or analytics to this file.
-       The build step will place the bundled scripts into the <body> tag.
-       To begin the development, run `npm start` or `yarn start`.
-       To create a production bundle, use `npm run build` or `yarn build`.
-     -->
-   </body>
</html>
```

Now we are ready to get started.

## Scaffolding a Layout

When I am laying out a new section of a React application, I like to do all my work in one file before I start thinking about how I am going to split out my components.  I find this lets me better decide where the logical cuts are between my components.  With that in mind, let's make some temporary changes in our App component to get us started.

We are going to lay the groundwork for our first bit of navigation.  We can create a placeholder for a control that allows our readers to flip between chapters.  We are going to be adapting a layout starter provided on the Semantic UI website.  I am not qualified to make design decisions without adult supervision, so using this start helps us get a little guidance from professionals.

Open your `src/App.js` file and let's get to work.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
+ import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import axios from 'axios';
import {loadNodes } from './actions/nodes';
+ import reactLogo from './assets/images/react-logo.svg';
+ import railsLogo from './assets/images/rails-logo.svg';
import './App.css';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

- const mapStateToProps = (state) => ({
-   book_body: state.nodes
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
-     return content_blocks;
-   }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
        <div id="reader-pane">
          <Container text>{ this.renderContentBlocks(this.props.book_body) }</Container>
        </div>
      </div>
    );
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App);
```

First, some quick housekeeping; we have moved our image files into an `assets/images` directory.  I have also taken a Rails logo from the Rails project website too.  We can fly under these React/Rails logos as a placeholder for the moment.

The rest of the additions fall into 2 categories: components provided to us by Semantic-UI, or style objects to alter their presentation.  The Semantic UI project is large, and I cannot tackle the scope of documenting these components in this book. Beyond that, documentation on these items is already available and exceptional on [the Semantic-UI React Website](https://react.semantic-ui.com).  I am covering a few of the APIs we need to use.  However, for other components, please supplement from the official documentation as you find helpful.

Luckily most of the Component names from Semantic UI are, well... semantic.

### Some Thoughts on Styles

At the top of our altered file, we are also defining several JavaScript style objects.  There are many ways to style React components, from inline styles to style objects, to traditional stylesheets.  

My opinion is going to assert itself again here, but I am still not entirely sold on the idea of abandoning traditional external CSS stylesheets.  However, the lines between presentation, structure, and behavior inside React, and indeed any front-end library is already blurred.  So, it is hard to argue that externalizing all our style information into CSS is an imperative.  Moreover, there's a real advantage gained for reusability in keeping our styles close to our components.

Setting up our component styles as constants in our components is my compromise.  It allows us to centralize our styles in one spot for each component.  The constants are reusable, similar to how we would CSS classes.  Also, if we need to reuse style beyond a single component, we can make them exportable.

### Inline Style Syntax

If you have not used JavaScript styles before, the syntax is easy to wrap your head around.  If you are already familiar with the traditional CSS style names, the transition is smooth.

Hyphenated names drop the hyphen, in favor of camel case name.  So `padding-left`, becomes `paddingLeft`.  Values for styles can pass as integers in some cases, but when you want to pass specific units for values, such as `"5px"` you can rely on a string value.

With the change to our `App.js` component in place, let's check our rendering.

![Semantic-UI Reworked Application Layout](/images/6/SemanticUILayoutRework.png)

## Slicing Up Components

It is now at long last time for an overdue refactor to our App component!

We have a **lot** going on in this one component.  We are making API calls, managing a connection to our store, and building an entire layout.  We are also making a fairly detailed data selection as we render our list of nodes.  Now that we have a foundation set, we can start making some more thoughtful decisions about how we separate these tasks.

### Container Components

Let's start with a look at our node rendering code.  Since we have the API side of the work complete(ish) for this section of content, we can begin there.

Let's create two new directories in our client project `src/components` and `src/containers`.

Now let's set up a file `src/components/reader_pane.js`.  Inside we can set up a new component, and migrate over some code from `App.js`.

``` javascript(/reactive-client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div id="reader-pane">
        <Container text>{ this.renderContentBlocks(this.props.book_body) }</Container>
      </div>
    );
  }
}

export default ReaderPane;
```

This example is about as simple as we can make a React Component.  We are externalizing a bit of styling around our reader's viewport into its own components.  This way, we can split out some of the logic around rendering our nodes from the App component, and also make our markup more readable.  Now when we call this code in our App component, it can have the more readable name `ReaderPane` to describe what we are actually rendering. At least more effectively than some divs and assorted HTML tags can.

Let's look at what our App component would look like with this change.

``` javascript((/reactive-client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import reactLogo from './assets/images/react-logo.svg';
import railsLogo from './assets/images/rails-logo.svg';
import ReaderPane from './components/reader_pane';
import './App.css'

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
- };

- const tightItem = {
-   paddingLeft: "5px",
-   paddingRight: "5px"
- };

- const mapStateToProps = (state) => ({
-   book_body: state.nodes
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
-     return content_blocks;
-   }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
+         <ReaderPane book_body={this.props.book_body} />
      </div>
    );
  }
}

- export default connect(
-   mapStateToProps,
-   mapDispatchToProps
- )(App);
```

A step in the right direction... but I still see at least two problems.  

For one thing, we are relying on a property "book_body" to be passed into the component when it renders.  That may or may not be clear from the outside.  What is clear, is that our `App` component does not really have any business orchestrating what nodes get rendered.  Right now, it is not a problem, because we are doing a wholesale printing of the entire book.  However, what does this start to look like when we only want to print one chapter, or a few sections at once?

Let's set ourselves a better foundation for handling this process in the future, and reap some extra cleanup now while we are at it.

### React Containers

Let's create a new component, `src/components/nodes_list.js`.  Set up the file as follows.

``` javascript(/reactive-client/src/components/nodes_list.j)
import React, { Component } from 'react';

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {nodes_list.push(<p key={node.id}>{node.content}</p>)});
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

We are setting up our new NodesList to have one task; it receives a list (array) of nodes and happily prints them for us.  We are also taking this time to update some of our variable names around the "node" concept we defined in our API, and dropping the use of terms like `book_contents` we were using in the wild-west day of chapters 1 and 2.

This step could let us remove the node looping/printing logic from the `ReaderPane` component.  However, we still haven't solved the problem of needing to pass in an attribute manually to render our list of nodes.  We just moved it downstream.  

That is where containers come in.  React convention is to make a distinction between components that manage state, and those that merely handle presentation.  In the case of Redux, that means giving a certain level of prestige to the components we connect to the store.  It is about separating the logic centers of our application from the presentational elements.

Go ahead and create another file `src/containers/filtered_nodes_list.js`.  

``` javascript
import { connect } from 'react-redux';
import NodesList from './components/nodes_list';

const mapStateToProps = (state) => ({
  nodes: state.nodes
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

Remember when we discussed the connect function in chapter four, we said that connect returns a function that itself gets invoked by passing in another component?  We are about to see that magic in action when we call a component we have never technically defined, `FilteredNodeList`.

mapStateToProps is going to solve the need for us to pass around our nodes property manually on our components.  Instead, we let our new container fetch them from the store.  Then the returned list of nodes will be merged with any other properties we manually tag to the component we pass into `connect()`, and we are free to let that wrapped component (`NodeList`) handle the details of rendering content.

We technically could have wrapped our `NodeList` component in the same module where we handle the rendering, and our result would be the same.  However, splitting our connect/container code into its own module/file gives us another layer of separation between how we choose what to render, and how what we render looks and behaves.  As we start adding complexity to what we choose to print, I think this separation of concerns becomes more valuable than the merged approach.

### ReaderPane Reassembled

Let's now turn back to our `ReaderPane` component and pull this all together.  As we do though, remember that I said we saw two problems?  Right now, we are simply calling `<ReaderPane />` as a static block of code and trusting it to print what we want.  What happens if we want to reuse this component again, to print something other than our nodes?  We are stuck.  We can fix that by setting up `ReaderPane` to expect to receive child components. We do this using the `children` property to access elements passed via JSX nesting, rather than hard-wiring the rendering of our Nodes.

``` javascript(/reactive-client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  render() {
    return (
      <div id="reader-pane">
        <Container text>
+         { this.props.children }
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

So finally, let's pull it all together in `App.js`.  Pay attention to our use of the `ReaderPane` component and `FilteredNodeList`.  It is also worth pointing out we have removed the `mapStateToProps` from `App.js`.  Now that we have our `FilteredNodeList` container managing the connection of that part of our store we do not need it in App any longer.  We are passing `null` through the connect function instead so that our `mapDispatchToProps` function populates the right parameter of our connect function.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import reactLogo from './assets/images/react-logo.svg';
import railsLogo from './assets/images/rails-logo.svg';
import './App.css'

import ReaderPane from './components/reader_pane';
import FilteredNodesList from './containers/filtered_nodes_list';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
- };

- const tightItem = {
-   paddingLeft: "5px",
-   paddingRight: "5px"
- };

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
});

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
+         <ReaderPane>
+           <FilteredNodesList />
+         </ReaderPane>
      </div>
    );
  }
}

export default connect(
+   null,
  mapDispatchToProps
)(App);
```

Make sure you understand the interplay between ReaderPane, FilteredNodeList, and NodeList before moving forward.  Our Nodelist
component handles the presentation of individual nodes, and build a collection of elements for us.  However, it is only called in ReaderPaner through the FilteredNodeList container, which supplies the list of nodes rendered by our application.

## Moving Towards Navigation

Let's split out our Menu bar into its own component as well so we can begin to isolate our navigation elements.

Create a new file `src/components/menu_bar.js`, and migrate the menu setup from our main layout.

``` javascript(/reactive-client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Again, you can trim down `App.js` to accommodate this new component.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import './App.css'

import ReaderPane from './components/reader_pane';
import MenuBar from './components/menu_bar';
import FilteredNodesList from './containers/filtered_nodes_list';

- const mapDispatchToProps = (dispatch) => ({
-   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
- });

class App extends Component {
-   componentWillMount(){
-     axios.get("/api/nodes")
-     .then(
-       (response) => {
-         this.props.dispatchLoadNodes(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
  render() {
    return (
      <div id="app">
        <MenuBar />
        <ReaderPane>
          <FilteredNodesList />
        </ReaderPane>
      </div>
    );
  }
}

- export default connect(
-   null,
-   mapDispatchToProps
- )(App);
```

## Spinning up New Endpoints

We have come to a point where we are ready for a new API endpoint.  Before we can move on with navigation and create an ability to move between chapters, we need to first load that associated content from our API.  Let's run through that now to refresh what we have covered in the first few chapters without all the interruptions to install and configure new packages.

My hope is this exercise gives you an appreciation of how easy all this foundational work makes development once the pieces are in place.  Since we are already working client-side, let's start there. 

### Client Setup, Round 1 (Fight!)

First, let's define the new action we are going to build support for in a constants file, `src/constants/chapters.js`.

``` javascript(/reactive-client/src/constants/chapters.js)
export const LOAD_CHAPTERS = "LOAD_CHAPTERS";
```

Then, let's create an action-creator in `src/actions/chapters.js`.

``` javascript(/reactive-client/src/actions/chapters.js)
import * as constants from '../constants/chapters';

export const loadChapters = (payload) => ({type: constants.LOAD_CHAPTERS, payload});
```

The format of expecting our API to pass back an array of elements seems to be working well with our Nodes, so we can use that same pattern with our loadChapters action creator.  We should set up a snapshot test though so that we at least get an alert if there's a significant structural change to this FSA.  Setup `src/actions/chapters.spec.js` as follows.

``` javascript(/reactive-client/src/actions/chapters.spec.js)
/* global expect */
import * as actions from './chapters';

describe("Chapters actionCreators", ()=>{
  test("loadChapters(chapters)", ()=>{
    expect(actions.loadChapters([{contents: "Test chapter"}])).toMatchSnapshot();
  });
});
```

Next, prep our reducer to handle this action.  Since we want our chapters stored under a different key in our store, we should set up a new sub-reducer for that namespace in `src/reducers/chapters.js`.

``` javascript(/reactive-client/src/reducers/chapters.js)
import * as constants from '../constants/chapters';

let default_state = [];

export const sortChapters = (chapters) => {
  return chapters.sort((a,b) =>{
    return a.id - b.id;
  });
};

const chaptersReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.LOAD_CHAPTERS):
      return [...sortChapters(action.payload)];
    default:
      return state;
  }
};

export default chaptersReducer;
```

This reducer should look very similar to our nodesReducer function, and the load action there.  The only significant change being the simplified sort function since we do not need a multi-level sort of our chapters.  The amount of overlap here is likely indicative that we have some opportunity to refactor and DRY up this code.  Given the small amount of code we are talking about though, I am content to let this ride until it becomes a problem.

Let add some test coverage here as well by setting up `src/reducers/chapters.spec.js`.

``` javascript(/reactive-client/src/reducers/chapters.spec.js)
/* global expect */
import  chaptersReducer, { sortChapters } from './chapters';
import * as actions from '../actions/chapters';

let defaultState = [];
let newState = [{title: "Test chapter"}];
let sampleChapters = [
  {id: 7, title: "Second"},
  {id: 8, title: "Third"},
  {id: 6, title: "First"}
];

describe("chapters Reducer", ()=>{
  test("sortChapters orders by id", ()=>{
    expect(sortChapters(sampleChapters)).toMatchSnapshot();
  });
  
  test("LOAD_CHAPTERS overwrites chapters array",()=>{
    expect(chaptersReducer(defaultState,actions.loadChapters(newState))).toEqual(newState);
  });
});
```

Be sure to look at the generated snapshot for your sortChapters function before you move on!  Testing against a lousy snapshot does no good at all.

Don't forget to add the new sub reducer to your `combineReducers` function in `src/reducers/store.js`.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers } from "redux";
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
  combineReducers({nodes, chapters})
);

export default store;
```

At this point, I'd probably jump into the browser console and do a quick check to make sure everything is wired-in correctly.  We should have a new key `chapters` in our store, with a default state of `[]`.  Also, the store should accept a dispatch of `LOAD_CHAPTERS`, and update our array.

![Test dispatches](/images/6/TestDispatches.png)

It looks like we are prepped to receive new data from the API.  Let's change gears and switch back to our Rails application.

### Chapters From our API

Let's start by defining a route for the new action.  As we did with nodes, defining our route as an index action seems to make the most sense for the task at hand.

``` ruby(/reactive-api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
    get 'nodes/', to: "nodes#index"
+     get 'chapters/', to: "chapters#index"
  end
end
```

Then we need a matching chapters controller, so let's create a new file `app/controllers/api/chapters_controller.rb`.  We do not have an `fsa` scope defined on our Chapter model yet, but I like that pattern for accessing model data, so let's write our controller on the assumption we can add one in just a moment.

``` ruby(/reactive-api/app/controllers/api/chapters_controller.rb)
class Api::ChaptersController < ApplicationController
  def index
    payload = Chapter.all.fsa
    render json: payload, status: 200
  end
end
```

Now we can drop into our model to build out that scope.  For now, all I am anticipating needing client-side for our Chapter model is the title and ID.

``` ruby(/reactive-api/app/models/chapter.rb)
class Chapter < ApplicationRecord
    has_many :nodes
    
    scope :fsa, -> { order(id: :asc).select(:id, :title) }
end
```

Now, just as we did a quick smoke-test in the browser for the client side of this iteration, we can do a similar test API-side using curl.  (Your host information may vary)

``` bash
curl http://localhost:8080/api/chapters

[{"id":1,"title":"Chapter 0: Introduction"},{"id":2,"title":"Chapter 1: Installing React and Rails"},{"id":3,"title":"Chapter 2: Loading and Displaying Basic Content"},{"id":4,"title":"Chapter 3: Organizing Data"},{"id":5,"title":"Chapter 4: The Client Store"}]
```

If you got back an Array of chapter elements, then we are in good shape.  Switch back to the client for the finishing touches.

### Calls and Containers

For the moment, we are going to be defining another API call for fetching chapters in a new container component in our client.  I do not love or wish to advocate this approach, but to move us forward, we are going to continue this pattern.  Externalizing these API calls is one of the last things we need to do to clean up our components, and we introduce a strategy for doing that in a coming chapter using Redux Saga.  

For now, bear with me, and know that this is not an ideal way to handle this problem when making API calls of any complexity.

Create a new file `src/containers/chapter_menu_items.js`. We are going to use the same approach here we did with our `FilteredNodesList` component/container setup and split off our store connection from the rendering of our UI.  We need our container to provide access to the store's chapters key, as well as a dispatch function for our `loadChapters` action creator (since our component is still managing this API call in the short-term).

``` javascript(/reactive-client/src/containers/chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Then we can set up a component to handle the render of this area of our UI.

``` javascript(/reactive-client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
  componentWillMount(){
    axios.get("/api/chapters")
    .then(
      (response) => {
        this.props.dispatchLoadChapters(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderChapterMenuItems = (chapters) => {
    let chapters_list = [];
    chapters.forEach((chapter) => {
      chapters_list.push(
        <Dropdown.Item key={"chapter_" + chapter.id} id={chapter.id}>{chapter.title}</Dropdown.Item>
      );
    });
    return chapters_list;
  }
  
  render() {
    return (
      <Dropdown text='Jump to Chapter...' className='link item'>
        <Dropdown.Menu>
          { this.renderChapterMenuItems(this.props.chapters) }
        </Dropdown.Menu>
      </Dropdown>
    );
  }
}
```

This single component contains most of the tools we have worked with thus far.  If you are comfortable with this code that’s a good sign you are keeping up with the concepts we have covered.  Remember you need to update your `MenuBar` component as well to account for this new container/component.

``` javascript(/reactive-client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

+ import ChapterMenuItems from '../containers/chapter_menu_items';

- const fixedMenuStyle = {
-   backgroundColor: '#fff',
-   border: '1px solid #ddd',
-   boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-   paddingTop: "13px",
-   paddingBottom: "13px"
- };

- const tightItem = {
-   paddingTop: "0",
-   paddingBottom: "0"
- }

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          stackable
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container textAlign="center">
            <Menu.Item className="banner" style={tightItem}>
              <Image size='mini' src={reactLogo} />
              <Image size='mini' src={railsLogo} />
              <Menu.Item header>Reactivating Rails: A work in progress</Menu.Item>
            </Menu.Item>

            <Menu.Menu position='right' style={tightItem}>
+               <ChapterMenuItems />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

That is it, we are up and running with our chapters content.  Granted that new menu does not **do** anything yet.  Before we can change that though, we need to talk about one area of application state we have ignored thus far, the URL bar.  For that, we need to configure a client-side router.  

Before we open that topic up though, there's one last thing I just can't pass up the chance to improve.

## Client Side Markdown

We have put a bit of effort into the look and feel of our application now.  So the raw markdown syntax showing through in our nodes is now beginning to bum me out.  Before we move into the wonderful world of routing in our next chapter, let's take a pass at an initial markdown parser for our client.

If we get it installed now, we can noodle over how well the out-of-the-box behavior of our parser treats us.  Then decide what, if anything we might want to improve in future iterations.

I am going to take the first pass using a package I found called [MarkdownIt](https://github.com/markdown-it/markdown-it).  It has an easy syntax and configuration process and appears to be reasonably extensible if needed in the future.

To setup, we first need to install the package with NPM, `npm install markdown-it --save`.

Then, let's turn to our `NodesList` component.

``` javascript(/reactive-client/src/components/nodes_list.js)
import React, { Component } from 'react';
+ import MarkdownIt from 'markdown-it';
+ const md = new MarkdownIt();

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
+       nodes_list.push(
+         <p key={"node_" + node.id} dangerouslySetInnerHTML={{__html: md.render(node.content)}} />
+       );
    });
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

We are making a quick modification to `NodesList` to leverage MarkdownIt’s rendering as we loop through our nodes.  We've updated our generated paragraph tags to use the `dangerouslySetInnerHTML` prop.  As the name suggests, there is some danger involved with this approach.  By default, React/JSX are going to escape contents when we render a string within an element.  So our HTML tags would print out to the screen `<p>some content....`.  

That is not ideal for our use case where we want the browser to parse our HTML tags as part of the DOM.  The name of `dangerouslySetInnerHTML` is purposely meant to be frightening, because we should be very thoughtful about where and when we use it.  By disabling the automatic escaping on elements, we are opening our application up to Cross Site Scripting (XSS) attacks.  Loading content from unsafe sources could lead to your application rendering and executing malicious code.

Since we control the only API endpoint we're rendering, I believe this is an acceptable level of risk.  However, should we ever need to render external content we do not control, we will need to re-evaluate this.

With these changes made, let's check out our rendering!

![Updated layout with basic markdown rendering](/images/6/MarkdownBasicRender.png)

Not bad for such a minimal bit of work!  There are some immediately apparent problems though.  First off, all our automatically generated image links broke.  The local file paths expect our images to be located at `/images/...`, off our client server's address.  However, we need to remember that in production, everything will be managed by our Rails application server.  Therefore, we should move the images into `app/public/images/...` so that we are production ready.  In development, our request proxy goes looking for images there as well once they are found missing on the client.

There is also some CSS cleanup we can do.  Our code blocks, for example, are being generated inside HTML `<pre>` tags.  They are overflowing the max line length in some cases and running off the screen.

Our images are also attempting to render at their native size and blowing out our layout.

We can address all 3 of these issues quickly.  To start, we need to update our `rr:load_book` rake task to perform our image file move.  This task is different enough from our existing book parsing classes to justify its own class.  Setup a new file `lib/loader/book_image_finder.rb`.

``` ruby(/reactive-api/lib/loader/book_image_finder.rb)
class BookImageFinder
  attr_reader :entries
  
  def initialize(path)
     @path = normalize_folder(path) 
     @entries = filter_image_dirs(Dir.entries(@path))
  end
  
  def copy_files_to_public
    entries.each do |file_name|
      file_path = expand_file_path(file_name)
      FileUtils.cp_r(file_path,"#{Rails.root}/public/images/#{file_name}")
    end
  end
  
  private
    def normalize_folder(path)
      path[-1] == "/" ? path : path + "/"
    end
    
    def filter_image_dirs(raw_file_list)
        raw_file_list.select do |file|
            file_path = expand_file_path(file)
            Dir.exists?(file_path) && file != "." && file != ".."
        end
    end
    
    def expand_file_path(file_name)
        @path + file_name
    end
end
```

This class is very similar to our Markdown file finder class but works on the assumption that any subdirectory in our book directory will be a chapter's image resources.  When the class instantiates, we remove all files, as well as the `.` and `..` directory listings from our array of entries.  We then provide a public method for the Class, `copy_files_to_public` which loops our directories and performs a recursive copy into `public/ `.

We can also adapt our `BookFileFinder` tests for use with this new class in a new file `/reactive-api/spec/lib/book_image_finder_spec.rb`.  I am going to stop short of testing the actual file copy though as I would rather not deal with the headaches of cleaning up our file system between test runs.  Since the copy process is largely built on Ruby internals anyhow, we can be confident so long as we identify the right files to copy, things go off smoothly.

``` ruby(/reactive-api/spec/lib/book_image_finder_spec.rb)
require 'rails_helper'
require 'loader/book_image_finder'

RSpec.describe BookImageFinder do
  it "removes files, and relative DIR paths from entries" do
    path = "spec/lib/testbook/"
    entries = BookImageFinder.new(path).entries
    expect(entries.length).to eq 1
    expect(entries[0]).to eq "images"
  end
  
  it "enforces proper file path" do
    path = "spec/lib/testbook/"
    bad_path = "spec/lib/testbook"
    expect(BookImageFinder.new(path).entries).to eq BookImageFinder.new(bad_path).entries
  end
end
```

Now we can update our Rake task to use this new Class (`/reactive-api/lib/tasks/rr.rake`).

``` ruby(/reactive-api/lib/tasks/rr.rake)
require "#{Rails.root}/lib/loader/book_file_finder"
+ require "#{Rails.root}/lib/loader/book_image_finder"
require "#{Rails.root}/lib/loader/chapter_file"

namespace :rr do
  desc "Import content at lib/reactivating-rails/"
  task load_book: :environment do
    puts "Loading book content..."
    book_path = "#{Rails.root}/lib/reactivating-rails"
    entries = BookFileFinder.new(book_path).entries
+     images = BookImageFinder.new(book_path)
    
    puts "Copying image files to public/images..."
+     images.copy_files_to_public
    
    entries.delete_if do |file|
      ChapterFile.new(file).invalid?
    end
    
    entries.each do |file|
      chapter = ChapterFile.new(file)
      chapter.save
      
      chapter.body.each do |node|
        chapter.record.nodes.create(node_type: node.type.to_s, content: node.to_commonmark)
      end
    end
  end

  desc "Clear content of previously loaded iterations"
  task clear_book: :environment do
    puts "Clearing book content..."
  end
end
```

Run the task to update your public directory with the required image assets.  (`bin/rails rr:load_book`)

Now all that we need is some CSS changes.  Let's also make some quick file changes to clean up our mobile rendering and make our content more responsive to small screen sizes while we are at it.  We can use a max-width on our `<img>` elements inside `#reader-pane` to ensure images get scaled down if they are too large for the screen area.  Also, our `<pre>` tags can be told to wrap lines when needed.

Update `App.css` as follows.

``` css(/reactive-client/src/App.css)
img {max-width: 100%;}

pre {white-space: pre-wrap}

#reader-pane {
  margin-top: 85px;
}

@media only screen and (max-width: 990px) {
  #app .banner {
    margin-left: -10px;
  }
}

@media only screen and (max-width: 767px) {
 #app #reader-pane {
   margin-top: 125px;
 }
}
```

Media-specific styles are something we just can't handle directly in our components.  When I need a media-specific rule, I transition all related styles for that element to the stylesheet as well, so they are all located in one place.  That is why we now see the `#reader-pane` element styled here.

Let's also make some updates to `MenuBar` to support small screen renderings more effectively.

``` javascript(/reactive-client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

import ChapterMenuItems from '../containers/chapter_menu_items'

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
  paddingTop: "13px",
  paddingBottom: "13px"
};

const tightItem = {
  paddingTop: "0",
  paddingBottom: "0"
}

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          stackable
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container textAlign="center">
            <Menu.Item className="banner" style={tightItem}>
              <Image size='mini' src={reactLogo} />
              <Image size='mini' src={railsLogo} />
              <Menu.Item header>Reactivating Rails: A work in progress</Menu.Item>
            </Menu.Item>

            <Menu.Menu position='right' style={tightItem}>
              <ChapterMenuItems />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Finish up, and look at all we have accomplished.

## Wrapping Up

We made some rapid progress this chapter, introducing a new layout for our application, and laying the groundwork to introduce navigation and routing.  We will be tackling that next chapter.  We also iterated through the entire process of adding support for a new action, including defining our API endpoint, client actions, and tying it all together.

Before we move on, I would like to touch briefly on testing.  You may have noticed that as we added tests for other areas of our application, I did not add any tests around the rendering of our components.  

I tend to run light on tests in this area and rely on the tools I am using to being thoroughly tested.  I only include my own component tests when I am introducing complex logic between a given state, and props for a component, and the treatment it gets onscreen.  We just haven’t built anything that complex yet. If you feel differently, you can certainly add some tests on your own.  

In future chapters, we will be setting up Capybara/Rspec in our API to do end-to-end testing in a simulated browser.   I find these types of tests are generally easier to implement, and more useful.  They allow us to focus on what our users can/should be able to do in our test, rather than grinding over checking how each Component renders in isolation.

