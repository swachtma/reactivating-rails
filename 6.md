# Chapter 6: Client Side Routing

We've got a basic UI in place now for displaying our book contents.  And the beginning of a navigation system in place which will allow us to cease printing out 100% of the book's contents and instead select single chapters to view.  Before we move on further in our application, we need to think about a new part of our state we've so far ignored; the URL bar.

## Jumping in here

If you haven't been following along with the code examples and want to jump in here, you can catch up with the work through Chapter 5 using the branch: https://github.com/swachtma/reactivating-rails-app/tree/Chapter6Starter


## Client Side Routing Solutions

React and by extension Redux, have many different approaches to routing; all of them seeking to solve the problem of how to handle URL state.  

The problem, if I can simplify it, is that React and more so Redux, are built of the principle of having a single point of record for your application state (your store).  But the purity of this concept is broken somewhat by the intrusion of the browser’s URL bar.  (A somewhat inescapable piece of state for our web applications)

The trick is, on the client side, thanks to search engines, and direct links to our sites, we don't know what point a user might enter our application, and moreover the user's expectation about how our application should perform will vary based on the URL they use to enter the site.

Our application **should** respond accordingly to each appropriate URL.  Setting aside the SEO implications of not supporting URL routing in our applications, it's a bad user experience to ignore this piece of the state.  Have you ever sent someone a link to a piece of content you want to share, only to realize the contents of your URL bar doesn't preserve the content/state you're trying to share?  Very annoying.

So, we need to answer this user expectation.  But that means we've suddenly gone from one record of state, to shared 2-part state system.

Let's look quickly at a few approaches to this problem

### React Router

[React Router](https://github.com/ReactTraining/react-router) is probably the best known solution for Routing in the React Ecosystem.  Their approach says that we should treat routing as another layer of components in our application.  So, we use specialized container components to conditionally render areas of our application based on the state of our URL bar.

Look at this example code from their docs and I think you'll grasp the idea pretty quickly.

``` javascript
const App = () => (
  <AppLayout>
    <Route path="/invoices" component={Invoices}/>
  </AppLayout>
)

const Invoices = () => (
  <Layout>

    {/* always show the nav */}
    <InvoicesNav/>

    <Media query={PRETTY_SMALL}>
      {screenIsSmall => screenIsSmall
        // small screen has no redirect
        ? <Switch>
            <Route exact path="/invoices/dashboard" component={Dashboard}/>
            <Route path="/invoices/:id" component={Invoice}/>
          </Switch>
        // large screen does!
        : <Switch>
            <Route exact path="/invoices/dashboard" component={Dashboard}/>
            <Route path="/invoices/:id" component={Invoice}/>
            <Redirect from="/invoices" to="/invoices/dashboard"/>
          </Switch>
      }
    </Media>
  </Layout>
)
```

We now have an additional layer of components in our application's rendering tree.  These `Route` components let us choose which components render in our application based on the state of the URL bar.  Then we're able to treat state within those components largely as we would in a route-free application.  The tradeoff is we need to now have these extra layers of component abstraction in our application.  

We also now have two disconnected state systems in our application (though there are connectors for Redux that minimize, but do not fully eliminate this drawback).

Testing, in my opinion also becomes more complicated.  Our components now have two systems they rely on for state.  That means if we want to test a component, we need to mock 2 systems of state to get a test-case built for a specific expectation.

React Router is a very popular solution, but I would also argue its coupling with Redux is also the most limited.

### Redux Little Router

With the rising popularity of Redux, there have been several other routers written to make Redux more of a first-class citizen in the application’s Router.  However, as we'll see, most of them have taken an approach that adapts concepts React-Router familiarized while trying to make them more closely tethered to Redux.

It's hard to say that there's one clear leader in this realm of blended Redux/React Routing, but I have some experience using [redux-little-router](https://github.com/FormidableLabs/redux-little-router), so let's talk through that quickly.

Redux Little Router brings your URL state into the redux store.  When you install the router, you will configure a store enhancer and reducer that add a "router" attribute to your state tree.  When the URL state changes in your browser, the application state changes in the store as well.

Similarly, when you push route changes within your application (for events such as link clicks, or form submissions) the changes are dispatched as redux actions.  This gives you a very familiar interface to manage your route changes; a page change is essentially just a reducer action that happens to update the Brower's URL bar and history as a side-effect of the larger state change.

Look at an example location change action:

``` javascript
// For a URL matching /messages/:user
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: { // if your `history` instance uses `useQueries`
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!'
    parent: { // for nested routes only
      // contains the result of the parent route,
      // which contains each other parent route's
      // result recursively
    }
  }
}
```

And the `router` attribute created in our store state.

``` javascript
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: {
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!',
    parent: { /* the parent route's result */ },
  },
  previous: {
    pathname: '/messages',
    route: '/messages',
    params: {},
    query: {},
    result: {
      more: 'arbitrary data that you defined in your routes object!'
      parent: { /* the parent route's result */ }
    }
  }
}
```

This alleviates some of the problems I highlighted above because URL state and our store’s location representation are held mirrored by redux-little-route.  
Testing is much improved in my opinion.  When I am writing tests my "location" is just another piece of the store’s state.  So rather than providing a separate mechanism to mock a URL state, I can simply mock the location attribute of my store.  Testing the outcome of a location state is no more complicated than any other test where I might provide an artificial store setup to test expectations.

When the user makes a direct request in the browser's URL bar, the config you've setup for Redux Little Router, translates that request into a "LOCATION_CHANGED" FSA.  Your application processes that action through your reducers as it would any of your custom actions.

#### Here's Where It Goes a Little Sideways

For all that Redux Little Router does to Reduxify the management of your routing, it was also written in a way that seems like a continuation of React Router.

The use of components to conditionally manage rendering according to URL route matches is still a major part of Little Router's landscape. This means we don't get to say goodbye to aspects of React Router that clutter our application's component tree.

Redux Little Router gives us access to a `Fragment` component that manages our application as we saw our Router components function with React Router.

``` javascript
<Fragment forRoute='/about'>
  <div>
    <h1>About</h1>
    <Fragment forRoute='/bio'>
      <div>
        <h2>Bios</h2>
        <Fragment forRoute='/dat-boi'>
          <div>
            <h3>Dat Boi</h3>
            <p>Something something whaddup</p>
          </div>
        </Fragment>
      </div>
    </Fragment>
  </div>
</Fragment>
```

Now we can argue about how much of a problem this really is.  But I would say that problem or not, it's probably not a necessary function of a routing library that's truly a Redux-first approach.

It’s also a shame that all our location change actions with redux-little-router use the same `type` attribute (LOCATION_CHANGED).  This minimizes the usefulness of one very power design pattern in Redux.  

Where an action is dispatched to our store it’s passed to **all** of our reducers.  Any reducer setup to respond to that action’s `type` attribute can be given instructions on how to treat its state.  Wouldn’t it be nice then if every route we triggered in Redux came with a unique type value?  That way each section of our store state could be setup to respond as needed during route changes.

### Our Routing Solution: Redux-First-Router

All that brings us to the package we'll be using for our routing; [Redux First Router](https://github.com/faceyspacey/redux-first-router).

Redux-First-First router give us the most tight-knit integration I've seen available between URL state, and application/store state.  Like Redux Little Router, Redux-First-Router will give us a branch in our store that represents the application’s location.  It also uses FSAs to push route changes in the application, so we get to use the same interface we use for all of our other state changes.

Redux-First-Router though, says goodbye to management of application routing components such as `Fragment` and `Router`.  

Think it through; if your application state has a representation of our router location, why can we not use the same tools we use to manage the rest of our application state to render the appropriate components/state?

Redux First Router accomplishes this by migrating away from a single `LOCATION_CHANGED` action we saw in Redux Little Router, and instead gives us a mechanism to map specific route patterns to specific dispatched action types using a route map:

``` javascript
const routesMap = { 
  HOME: '/home',      // action <-> url path
  USER: '/user/:id',  // :id is a dynamic segment
}
```

Referring to the previous example, requests for `/home` will dispatch an action with the type `HOME`, and routes matching `/user/:id` will alternatively dispatch an action with type `USER`.

The result gives us a lot of flexibility to take appropriate instantiation actions when a user comes into our application on one route vs. another.  For example; a user coming into a `HOME` route probably gets a simple rendering of our application.  A request for a specific `USER` though might kickoff a complex step of actions to check a user-authentication token, providing authenticated content or redirecting to an authentication route if a valid token is not found, or is found to be expired.

None of this is to say we can't do these same things with other routing tools.  But the removal of Router state from our component tree allows us to manage these concerns where we manage all our other state concerns.  And keeps our application components as simple renderings of state, exactly as they should be.  And our state remains a single point system of record.

### Author's Aside

My introduction of Redux-First-Router is a high-level attempt to explain my choice of routers, and give a bit of context surrounding other tools.  For those interested in learning more about Redux-First-Router, and the problem's it seeks to solve, I highly recommend a bit of side reading: [Redux-First Router - A Step Beyond Redux-Little-Router](https://medium.com/faceyspacey/pre-release-redux-first-router-a-step-beyond-redux-little-router-cd2716576aea)
	
## Chrome's Redux Extension

We're about to install our first package that will dispatch its own actions to our Redux store.  Up until now, all the actions we dispatched have been custom actions we've written.  Now that we are going to be leveraging tools that do their own action dispatch I think it's worth taking time to install some developer tools to help us track these actions.

[Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en) will allow us to spy on actions dispatched to our store, and provide us diffs for each change made to our application state by these dispatches.  It also offers a somewhat amazing ability to time travel through these dispatches to see how our state is influenced.  I find it to be a very helpful tool, particularly when I am trying to spy on a 3rd party package's dispatched actions.  Its use is totally optional, but I do heartily recommend it.

Begin by installing the chrome extension with the link above.  We're also going to use an NPM package to simplify our in-app setup.  `npm install --save-dev redux-devtools-extension`.  Finally, we'll need to do some setup in our store config to allow this to work.  Open `src/reducers/store.js` and make the following changes.

``` javascript
import { createStore, combineReducers } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
  combineReducers({nodes, chapters}), composeWithDevTools()
);

export default store;
```

The `redux-devtools-extension` offer us a helper `composeWithDevTools` that will include store enhancers for the devtools if the user has them available, and fall back to an alternative `compose` method provided by `redux` if this specialized version is not available.

We haven't talked about these topics yet; middleware, enhancers, or the compose method.  We'll be visiting them in a future iteration when we write some custom middleware.  For now, let's put a pin in it with this 10,000 foot summary.  Middleware exist in our Redux stack, and has visibility on every action dispatched through the store, as well as the store state itself.  

This is very similar to the way reducer’s treat middleware in that a dispatched action can pass through our entire stack of middleware, triggering several operations along the way.  One key difference though is that a middleware might be setup to block certain actions on certain conditions, or they might modify the FSA and pass an updated copy through the remainder of the middleware stack, or even dispatch entirely new actions as an outcome of another action.

Middleware is used to debounce actions, manage API communications, validate permissions, and any number of other common tasks.  If you want to position code somewhere it can conditionally be executed against any number of dispatched actions, chances are you are entering the territory of Middleware.

Enhancers are more complex implementations of middleware, and unless you set out to write major application extensions to Redux itself (such as Redux-DevTools), chances are you won't need to write them.

But if you understand the positioning of middleware, even in this simplified summary, you can begin to see how Redux Devtools is perfectly positioned to "spy" on your store actions.

Now, reload your application in Chrome, and activate the extension.

![Redux DevTools With Setup Actions](/images/6/ReduxDevTools.png)

You should see our two setup actions requesting chapters and nodes when the page loads.  You can also spy the state tree before and after each dispatch.  There's a lot here, take some time to poke around before moving on!

## Setting Up Redux-First-Router

Now let's get our router installed in our application.  `npm install --save history redux-first-router`.  We're going to need to modify our store configuration as well to finish the install.

Our store setup is going to get a bit more complex, so let's look at this in a few steps.

``` javascript
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

const history = createHistory();
const reducers = combineReducers({nodes, chapters})

const store = createStore(
  reducers, composeWithDevTools()
);

export default store;
```

First, I'm pulling our `combineReducers` function out of our `createStore` call and assigning the returned super-reducer to a constant.  We're going to be mixing in a new reducer provided by our router, so to simplify this we're breaking reducer creation off into its own section of code; then we'll provide the final value to our store.

We've also included `createHistory` from the npm `history` package, which is a dependency for Redux First Router.  History provides several methods to store history, but since our application is browser-only, we'll only be leveraging the browser-history aspect of the package.  Browser history leverages the HTML5 history API and is used among modern browsers.  The history package also offers native app solutions (createMemoryHistory).  As well as legacy browser support (`createHashHistory`).

The browser history option though is supported as early as IE 11, so that will meet our needs.

Let's jump ahead again...

``` javascript
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
};

const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

const reducers = combineReducers({location: reducer, nodes, chapters});
const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

We're now making use of `connectRoutes` and an assignment syntax we haven't seen before.  `connectRoutes()` is going to take our history API, and well as a `routeMap` object we'll be defining.  connectRoutes returns an object from which we wish to capture several keys: `reducer`, `middleware`, and `enhancer`.  We’ll be using all three of these return values to configure Redux first Router into our store.

First, our combine reducer function is getting a new key `location`, to which we are assigning the reducer function provided by Redux First Router.  I'm opting to use the namespace `location`, as that's the default suggested by Redux First Router, and I see no need to change that key.  Other than verbosely assigning a name for this section of our store, the `combineReducers` function is being used exactly as it has been with our own custom reducers.

Next we are seeing our first use of `applyMiddleware()`.  Much like `combineReducers` helps us compile our various reducers into a single unit, `applyMiddleMiddle` will allow us to define a list of middleware used in our application, as well as an order of operations about which piece of middleware sees each dispatched action first.  We'll be revisiting this in the future if we define custom middleware, but for now, it's being setup more as a point to allow future extension of our store.

And finally, we see our call to `createStore()` now invoked with `composeWithDevTools(enhancer, middlewares)` to ensure all our middleware and store enhancers are included in our application store aside our reducers.  `composeWithDevTools` was introduced when we installed Redux Devtools, as an alternative to `compose` which is the vanilla implementation that ships with `redux`.  This is simply part of how we've chosen to install the Dev Tools, if you're choosing not to run them you can instead invoke `compose` instead.

## Defining our first Routes

Now that the setup is complete, we can turn to defining our first routes inside the route map.

Right now, I only see a need for two routes.  One for a request of the homepage, which I think for the time being should result in Chapter 0 being shown as default.  In the future we might decide to add a static homepage to our application, but for now beginning with the book's introduction seems appropriate.

Then we'll also need a route to request a specific chapter.  And this route will need to accept some sort of dynamic parameter to request a specific bit of content.

Let's define the following in our `routesMap` object.

``` javascript
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  "HOME_ROUTE": "/",
  "CHAPTER_ROUTE": "/chapter/:chapter_id"
};
```

At their most basic, our routes will be defined in the form `"ACTION_NAME":"/some/route"`.  They also give us a mechanism for defining dynamic parameters in our routes, such as the use of `:chapter_id` here.

Go ahead and visit your application homepage, and look at the actions fired in your Redux Developer tools.  If everything is wired in correctly you should see an action in your dev tool history with the type, `HOME_ROUTE`.  Looking at the dispatched action in its raw form shows us the entire FSA.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
  meta: {
    location: {
      current: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

We're receiving quite a lot of information here.  At its simplest, our dispatched actions look similar to the FSAs we've created, with a `type`, and `payload` attribute.  We haven't really worked with a `meta` attribute yet, but the `meta` keyword is often used by Redux middlewares to determine which middleware should operate on each action, and how.  

But here, our meta information contains additional information about our routing, such as the previous route we are leaving, the kind of route action (`load` in this case), and details about the currently matched route.

It's worth noting that when Redux First Router builds its actions it also carefully preserves other information you might have stored in the `meta` attribute of actions.  Since as we've mentioned, `meta` is commonly used among middleware this helps ensure our routing plays nicely with other middleware we might build or install.

Let's look at a `CHAPTER_ROUTE` as well.  Visit `[your host]/chapter/1` in your browsers, and have a look at the dispatched action again.

``` javascript  
{
  type: 'CHAPTER_ROUTE',
  payload: {
    chapter_id: 1
  },
  meta: {
    location: {
      current: {
        pathname: '/chapter/1',
        type: 'CHAPTER_ROUTE',
        payload: {
          chapter_id: 1
        }
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

Anytime we write a dynamic parameter into a route, Redux First Router will add that value to the payload of our dispatched route action.  In this case, we defined the name `chapter_id` in our route, so our payload includes `chapter_id: 1` when you trigger the route `chapter/1`.

That is amazing, when you consider the fact that all this integration is provided to use with almost no setup cost from our router.

## Catching dispatched Routes

Technically, we might be able to stop there, and meet the objectives of our iteration.  We've seen in our dispatched actions that we have a marker for the requested chapter in each dispatched route action.  What we haven't looked at, is how these actions influence our state.

``` javascript
{
  location: {
    pathname: '/chapter/1',
    type: 'CHAPTER_ROUTE',
    payload: {
      chapter_id: 1
    },
    prev: {
      pathname: '',
      type: '',
      payload: {}
    },
    kind: 'load',
    routesMap: {
      HOME_ROUTE: '/',
      CHAPTER_ROUTE: '/chapter/:chapter_id'
    }
  },
  nodes: [...],
  chapters: [...]
}
```

The information our routes dispatch in action's is also preserved to our store.  We could fairly easily update our Components to connect to this location value, and determine which chapter to display.  We'd simply connect to the `location.payload.chapter_id` value and display the appropriate chapter for each route.  We could then use a default chapter value in our component to display chapter 1 on our homepage if a specific `location.chapter` value is not given.

I'm going to forego that approach though, and instead setup a different area of our state to store this information.  As our application continue to grow we will likely encounter more aspects of our state we need to preserve that fall into this settings/config spectrum.  Odds are, I won't be able to pack them all into my routes.  While it's tempting to plug into the value we already have, I think it's worth setting up a more centralized branch of our state to manage these application level settings.
We should also remember that we don't own the object structure for Redux First Router's state, or it's dispatched actions.  If we build our application directly on top of its state we might have a headache down the line if that storage mechanism changes in a later version of the router.  Upgrading might then require us to weed through many of our component/containers to align with this change.  Setting up our own state might still require some changes, but they'll at least be centralized in one location and easy to access.
And if all of that doesn’t convince you, what happens when we need to define another route down the line that also use a chapter_id value in the payload?  Now we need to suddenly determine whether the presence of a chapter-id in our payload means we should display a new chapter, or do something else.  
We’re much better off telling each route how to handle its payload, and defining a storage structure of our own to house the state we need.
Luckily, we can do this is a very Redux first way.

### A Reminder About Reducers

When we introduced reducers, we said that when an action is dispatched, it is passed through all of our reducers.  We haven't really made use of this design feature yet, but we're about to.

Redux First Router supplies its own reducer, and with it, builds its own `location` state tree for us.

But the action's it dispatches will still flow through all our other reducers each time they are dispatched.  So, we can setup our own area of the store to respond to these dispatches, and create the state we need.  All without interfering with the internal operations of Redux First Router.

Let's setup a new file `src/reducers/settings.js`, and build out a reducer that will own our high-level settings for application state.

``` javascript
import * as constants from '../constants/settings';

let default_state = {};
let default_chapter = 1;

const settingsReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.HOME_ROUTE):
      return Object.assign({},state,{active_chapter_id: default_chapter});
    case(constants.CHAPTER_ROUTE):
      return Object.assign({},state,{active_chapter_id: action.payload.chapter_id});
    default:
      return state;
  }
};

export default settingsReducer;
```

We know that Redux First Router will dispatch an action where our route name occupies the TYPE attribute of the dispatched FSA.  So, setting up a reducer to catch these actions is no more complicated than any other reducer we've produced.

We can define a variable to store our `default_chapter`, and assign it to the `settings.active_chapter_id` store value we've created when the `HOME_ROUTE` is triggered.  Otherwise we'll pull the active chapter value from the payload included with our `CHAPTER_ROUTE` action.

Note that I've setup a constants files for our route names like the pattern we've used in other reducers.

``` javascript
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
```

And finally, we'll need to include our new reducer into our store setup.

``` javascript
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import * as routes from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [routes.HOME_ROUTE]: "/",
  [routes.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

const reducers = combineReducers({location: reducer, settings, nodes, chapters});
const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

I've also transitioned my `routesMap` object to use the constants I've defined.  The bracket syntax in our object literal’s attribute names is a new ES2015 syntax you may not have seen yet.  It allows us to use variable name assignment inside the literal syntax, and avoid the bracket syntax assignment we've historically been forced to use (`routeMap[routes.HOME_ROUTE] = "/"`).

Now let's let our application reload, and look at our state after a route is dispatched for `/chapter/5`.

``` javascript
{
  location: { ... }
  },
  settings: {
    active_chapter_id: 5
  },
  nodes: [...],
  chapters: [ ... ]
}
```

A similar request for our `HOME_ROUTE` will yield `settings.active_chapter_id == 1`.  I'd say we're now ready to plug this into our UI

## Filtering FilteredNodeList

Updating our UI to limit the nodes printed to a single chapter should now be almost trivial, so let's start there.  Open your container for `FilteredNodesList` in `src/containers/filtered_nodes_list.js`.

``` javascript
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

const filtered_nodes = (nodes, chapter) => {
  return nodes.filter((node) => { return node.chapter_id === chapter });
};

const mapStateToProps = (state) => ({
  nodes: filtered_nodes(state.nodes,state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

We're adding a `filtered_nodes` function to our container, and passing it the unadulterated list of nodes from our store state, as well as the active chapter.  The function will return a new Array of only the nodes where `node.chapter_id === store.settings.active_chapter_id`.  Just like that you can revisit your application and see that requests to the homepage will now show only our first chapter.  And we can use the `chapter/:chapter_id` routes to display other chapters.

## Configuring Form Controls

Now we need to wire in our form control for chapter selection.

First though, we should do a little setup for our action dispatching.  Let's setup some action creator functions for our routes in a file `src/actions/routes.js`.

``` javascript
import * as routes from '../constants/setting';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);
```

Nothing much new here, but there is one more bit of Redux First Router magic I want to point out.  Open your app's browser console and dispatch one of these new actions to the store and you'll find someone's done a lot of heavy lifting for you.  Look at our dispatched `HOME_ROUTE`.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
  meta: {
    location: {
      current: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      prev: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      kind: 'push'
    }
  }
}
```

Despite only populating our action's type in our action creator function, Redux First Router appended all the additional context information available about the route change, including our previous page, matched routes, and payload.  You can test out the `routeChapter` function in your stores dispatch and see it gets similar treatment.

Now that we have action creators let's update our `ChapterMenuItems` component and its container to leverage these functions.  Let's start in the container (`src/containers/controlled_chapter_menu_items.js`).

``` javascript
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

We need some new props available in our connected component.  The first and most obvious is a prop for our dispatch of `routeChapter`, which we've created using the name `dispatchRouteChapter`.  This function's signature is matched to the signature used by our Semantic UI component's `onChange` events.  This event is going to expect a handler function that accepts two parameters when invoked, a copy of the event itself, as well as an object detailing the target where the action originated.

We’ll use that target object passed to our handler to pass the value of each menu item into our dispatched store action (in this case, the ID of the specific chapter selected from the menu).

Now let's retool the `ChapterMenuItems` component to leverage this.  As I do I'm also going to rework the component a bit to use a simplified implementation of Semantic UI's `Dropdown` component.  Our original implementation used the sub-components `Dropdown.Menu` and `Dropdown.Item`.  But given the level of control we need on the component, this now seems overkill.  Instead we'll be using only the top-level component and passing it an options array that will populate our menu items.

``` javascript
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
  componentWillMount(){
    axios.get("/api/chapters")
    .then(
      (response) => {
        this.props.dispatchLoadChapters(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
        }
      );
    });
    return chapters_list;
  }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Our updated `Dropdown` component will now call `dispatchRouteChapter` when the `onChange` handler is invoked on the menu.  Our `renderChapterOptions` function is an update to the function that was producing our `Dropdown.Item` components, now producing the simplified options array instead.

If you look at what we've got so far, we've now got a functioning control in our dropdown to change to a specific chapter.  Go give it a test drive before you move on.  See if you can spot some of the areas we need to brush up yet...

## Polishing Our Navigation UI

We've got a basic control functioning, but the user experience is a little lacking.  For one, when we route directly to a chapter by URL, we're not showing the selected chapter in the dropdown's active pane.   That robs our users of some information scent to help them know where they are in our navigation schema.  To do this, we'll need to have access to our current active chapter inside our component.  Then we can populate our `Dropdown` component with some additional placeholder values.

There's also a moment in time after page-load when our control is written to the screen, but is nonfunctional.

Without meaning to, I've lead you into a beautiful example of why managing our API calls out of our component's lifecycle method's is less than ideal.  (To be fair, I've mentioned we need to clean up this code ever since we wrote it.)  But this is a good opportunity to demonstrate the problem.

Let's make another round of changes to our container.

``` javascript
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  active_chapter: state.chapters.find(
   (chapter) => chapter.id === state.settings.active_chapter_id
  ),
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Look at our new `active_chapter` prop.  Keep in mind your containers can do a lot more that simply map store values verbatim into your components.  In this case, it would be helpful for us to have access to both our active chapter's title and ID value.  Rather than passing in these simple values, we can traverse our full listing of chapters, and use `filter` to isolate just the active chapter.

Now we have access to the active chapter as a full object inside our connected components, rather than just the simple ID value.

Let's now update our `ChapterMenuItems` component to leverage this.

``` javascripte
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
  // API Call redacted
  
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
          active: chapter.id === this.props.active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
          value={this.props.active_chapter.id}
          text={this.props.active_chapter.title}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
    }
}
```

I now invite you to render this code, **so that you can watch it choke**.  Can you spot what happened?

We never fire an API call to fetch of list of chapters until the first time the component is rendered.  And we don't dispatch an action to load those chapters until the API call is returned.  

That means, the first time the component renders, our `store.chapters` value is guaranteed to be our default `[]` value.  We're then attempting to filter that empty array for a specific `chapter.id` id value to instantiate our `active_chapter` prop.  That of course helpfully returns `undefined`.  And when our component goes digging in that undefined value for `title` and `id` values in our component... **BOOM!**

Here's the monkey patch solution.  Update the render function of `ChapterMenuItems` as follows.

``` javascript
render() {
  if(this.props.chapters !== [] && this.props.active_chapter){
    return( 
      <Dropdown 
        tabIndex="1"
        placeholder="Jump to Chapter..."
        className="link item"
        selectOnNavigation={false}
        value={this.props.active_chapter.id}
        text={this.props.active_chapter.title}
        onChange={this.props.dispatchRouteChapter}
        options={this.renderChapterOptions()} 
      />
    );
  } else {
    return null;
  }
}
```

Your components don't have to render anything, they can instead just return null.  So, we can short-circuit rendering the dropdown menu if we've not yet populated our chapters into the store with an if statement to check our status.  This also prevent our error.

What it does not do is stop a bad situation where we are guaranteed to go through at least one wasted render cycle on this component just to dispatch our API calls.  Luckily, we'll be dealing with this long-standing issue in our next chapter.

## Scroll Restoration with Navigation

One more creature comfort I think we need to address before moving forward is scroll restoration.

You might have noticed if you've been testing out or chapter navigation that if you scroll into a chapter before making a new chapter selection from our dropdown that you load the updated content requested, but your scroll remains mid-way down the page.

That's likely not what our user's will anticipate happening, and it might lead them to believe our navigation is broken entirely if they don't notice the content on the page change.  We should add something to ensure they return to the top of the page.

Luckily, Redux First Router provides an associated package that handles this for us easily.  It's worth mentioning that Redux First Router provides Many such modules for the base router.  They are split into separate packages to minimize installing features not all user's might need/want.  But the github repo for the project is worth exploring when you have time, as there's much we simply won't cover in our work together.

Go ahead and install the scroll restoration module; `npm install --save redux-first-router-restore-scroll`.  Then open your store config at `src/reducers/store.js` and make the following changes.

``` javascript
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

const { reducer, middleware, enhancer } = connectRoutes(
  history,
  routeMap,
  { restoreScroll: restoreScroll() }
);

const reducers = combineReducers({location: reducer, settings, nodes, chapters});
const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

We're going to pass an optional parameter of options to `connectRoutes` and enable automatic scroll restoration.  There are other options that would allow us to manually trigger scroll restoration, or trigger it only in a response to certain routes.  But for now, the automatic pattern fits our needs just fine.

## Wrapping Up

We've accomplished a lot in this iteration, and introduced our first navigation functionality into what has previously been a single unbroken stream of content.  We talked through some routing options available, and settled on the use of Redux First Router.  We upgraded some of our container components to support this new functionality, and made it painfully clear we need to address some long-standing issues in our components.  

We'll be doing just that in our next chapter, as we introduce Sagas to manage our API interactions.

## What About Tests

I skipped a few test files this chapter for the sake of presenting all our router content in one cohesive stream.  Nothing we introduced this chapter really requires a new testing strategy so feel free to go through and add them in if you'd like.

I'm also including the new tests I've included here for those that need help, or somewhere to copy/paste form.

From `src/reducers/settings.spec.js`:

``` javascript
/* global expect */
import  settingsReducer from './settings';
import * as actions from '../actions/routes';

let defaultState = {};

describe("Chapter & Home Routes", ()=>{
  test("Assign default chapter of one on HOME_ROUTE", ()=>{
    expect(settingsReducer(defaultState,actions.routeHome())).toMatchSnapshot();
  });
  
  test("assign payload chapter on CHAPTER_ROUTE",()=>{
    expect(settingsReducer(defaultState,actions.routeChapter(5))).toMatchSnapshot();
  });
});
```

From `src/actions/routes.spec.js`:

``` javascript
/* global expect */
import * as actions from './routes';

describe("Routes actionCreators", ()=>{
  test("routeHome()", ()=>{
    expect(actions.routeHome()).toMatchSnapshot();
  });
  
  test("routeChapter(chapter_id)", ()=>{
    expect(actions.routeChapter(5)).toMatchSnapshot();
  });
});
```