# Chapter 13: Elegant Error Handling

Now that our authentication system is functional for our first secured actions, its time to revisit the way we manage errors, so our application is prepared for when thing do not go as planned.  Until this point, we have managed error handling on a case by case.  In some instances, we have passed over error handling entirely to focus on other topics of a given chapter.

It is time to amend all of that.  In this chapter, we introduce custom error handling on our API to standardize the way we respond to and recover from errors.

## Credit Where it is Due

In my search for a solution to this problem, I encountered an excellent article by Sophie DeBenedetto on the subject of error handling with Rails APIs.  Her work heavily influenced this chapter, and I would like to say thank you.  I also highly recommend her original article, [Rails API Painless Error Handling and Rendering](http://www.thegreatcodeadventure.com/rails-api-painless-error-handling-and-rendering-2/) for her clear and concise coverage of this topic.

## Iteration Objectives

There are two goals I am hoping to accomplish with this iteration.

The first is to move as much custom code as possible related to error handling out of our controllers.  Reporting and recovering from errors is going to have many standard architectural features shared across all the errors our API might encounter.  Our basic needs involve recognizing something has gone awry, forming an error message, and reporting the error status to our client.  I want to move as much of this logic as possible into a custom error class so that our controllers do not have to manage errors on an individual basis.  Instead, we can limit our controller to raising errors when appropriate, and rely on shared architecture to form a response to our client.

I also want to keep most of the error recovery process client-side, to be managed in our sagas.  This approach makes sense to me because our sagas already manage mutations of our state.  If an API error derails a saga server-side, our client needs to know that.  However since our server-side code does not have visibility on the majority of the client-state, recovering from error conditions belongs to our client, which can better decide what actions to take to give our users as little frustration as possible.  Our API should limit its error recovery to tasks that maintain our server-side data integrity.

## Autoloading Modules

We are going to build our error handling support as a module inside our API's `lib/` directory.  Before we get started though, we want to modify Rail's autoload paths so that the classes we define for error handling get automatically loaded with rails.  Open your application.rb file and modify as below.

``` ruby(/reactive-api/config/application.rb)
require_relative 'boot'

require "rails"
# Pick the frameworks you want:
require "active_model/railtie"
require "active_job/railtie"
require "active_record/railtie"
require "action_controller/railtie"
require "action_mailer/railtie"
require "action_view/railtie"
require "action_cable/engine"
# require "sprockets/railtie"
require "rails/test_unit/railtie"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module ReactiveApi
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 5.1

    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration should go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded.

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
+     config.autoload_paths << "#{Rails.root}/lib/api_exceptions"
  end
end

```

This new autoload path ensures files in `lib/api_exceptions` are available at runtime. 

## Creating a BaseException Class

We are going to build a common ancestor from which all our custom errors can descend. Each custom error can inherit a standard interface from this ancestor, and we can use this commonality to handle our responses to exceptions in mass.

Let's talk about this base class first.  Set up the file below.

``` ruby(/reactive-api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
+   attr_reader :status, :code, :message

+   ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
  }

  def initialize(e)
    error_type = self.class.name
    BaseException::ERROR_CODE_MAP
      .fetch(error_type, {}).each do |attr, value|
        instance_variable_set("@#{attr}".to_sym, value)
    end
  end
end
```

Our attribute readers give us the best guide for understanding the interface of this class.  We are expecting any errors that inherit from `BaseException` to provide attributes for a message, code, and status.

How do we define these values?  If you look at the initialize method, we access the class name of the error through self-inspection; this means if a new instance of `BookmarkErrors::BookmarkUnavailable` is raised, we capture that class name in our `error_type` variable.  This captured name is then used to fetch a key from the `ERROR_CODE_MAP` constant, which contains an entry for each of our custom error types.

Each error type in the `ERROR_CODE_MAP` invokes a Proc that sets up an object containing status, code, and message keys.  If you have not worked with Procs before, think of them as you would blocks assigned to functions; the critical difference being that Procs can be assigned to variables, and invoked in different contexts.  In this case, we call the proc to generate a return object each time something accesses our error map.  

Finally using the object returned from our error map, we assign instance variables for each of the keys.  This step completes setup for our three attribute readers defined by the `BaseException` class.

So now let's look at an actual error class for `BookmarkErrors::BookmarkUnavailable`.

``` ruby(/reactive-api/lib/api_exceptions/bookmark_errors.rb)
class BookmarkErrors < BaseException
  class BookmarkUnavailable < BookmarkErrors
  end
end
```

All we need to do to define our custom error is define the class itself.  So long as we do not override the `initialize` method, our custom error inherits this functionality from its parent class `BaseException`.  
We also gain access to the readable attributes defined by the parent class.

## Catching Custom Errors

Now we need to setup code to catch these errors.  We are going to centralize as much of this process as we can by handling our exceptions through our application controller.

``` ruby(/reactive-api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
+   rescue_from BaseException, 
+     :with => :render_error_response
    
  def authenticate_request!
      fail StandardError unless user_id_in_token?
      @current_user = User.find(@decoded_token["id"])
  end
  
  private
+     def render_error_response(error)
+       render json: {name: error, message: error.message, status: error.code}, status: error.code
+     end
  
    # Decode the authorization header token and return the payload
-     def user_id_in_token?
-       auth_token && decoded_token && @decoded_token["id"]
-     end
    
-     def decoded_token
-       @decoded_token ||= TokenOps.decode(auth_token)[0]
-     end
  
-     def auth_token
-       @http_auth_token ||= request.headers['Authorization']
-     end
end
```

Using a `rescue_from` hook, we listen for any instances of our `BaseException` class to be raised.  Since all our custom errors inherit from this parent class, our application controller catches any of our custom errors, and use the `render_error_response` method to form a response for our client.  Moreover, just like all our custom errors inherit their behavior from `BaseException`, all of our controllers inherit from our `ApplicationController`, meaning we just introduce a default behavior that gives us coverage across all our controller actions.

The `render_error_response` method itself is simple; we rescue any actions that raise a `BaseException` by rendering a JSON response containing our error message, code, and status.  We also use the error's code to set the response code for the HTTP request.

## Raising Errors

Now let's modify our `BookmarksController` to leverage the custom error we have created.  Since we will be testing this error behavior incrementally throughout this chapter, I want to make it temporarily easier to get an error response from our controller.  With that in mind, make the following changes.

``` ruby(/reactive-api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
  before_action :authenticate_request!, only: [:index, :create]
  
+   def index
+     # if(bm = @current_user.bookmark)
+     #   render json: bm.fsa, status: 200
+     # else
+       raise BookmarkErrors::BookmarkUnavailable
+     # end
+   end
  
-   def create
-     ch_id = params[:chapter_id]
-     
-     bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
-     bookmark.update(last_read: ch_id, furthest_read: ch_id)
-     render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
-   end
end
```

We are commenting out the majority of our `BookmarksController#index` action to ensure the response always raises an error.  We can undo this change once we are happy with our error handling setup in the client, but for now, this saves us needing to engineer error conditions while testing.

Finally, let's modify our client to receive these error responses.  We can do this in our `retrieve_bookmark` saga utility.

``` javascript(/reactive-client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
    } catch (e) {
      console.log(e.response.data);
      return false;
    }
  } else { return false; }
}
```


We introduce a try/catch block around our API call to catch error responses from our requests.  For now, let's log error responses to the console as-is.  We are also modifying the function a bit so that it returns false if the request failed, or our client was unauthorized.  I am going to keep this pattern consistent with our saga utility functions going forward; returning a truthy value if the function succeeded, and a false or falsey value on failures.  This convention will allow our parent sagas to quickly know how to proceed after passing off work to one of our utilities.

Open your browser, and log into an account.  You should now see an error response for the request logged to your console.

![First Custom Error Response: {name: "BookmarkErrors::BookmarkUnavailable", message: "No bookmarks were available at login, skipping bookmark prompt.", status: 500}](/images/13/BookmarkUnavailableErrorResponse.png)

## Standardizing Client Responses 

We have a foundation in place now on the server side for our error handling.  Let's try to give the client similar treatment.

 Ideally, we would have a way to ensure that errors returned from our API get raised in the client execution as well so we can rescue and manage outcomes as needed throughout our sagas.  

I also have one other small design complaint.  If you look at the screenshot above, you might notice a console log generated by the browser for our request against the API's `api/bookmarks` route.  Since our route returned a 500 error, chrome is highlighting this request as failed in our console output.  In my opinion, that is a false report.  Our route did not fail; it did precisely what it was supposed to do when it encounters this particular edge case.  The first time a user signs into their account, they have no server-side bookmarks to fetch.

Logging this in the user's console as a failure might give the false impression that something broke in our application.  I would like to change this console messaging, so any nosey users that happen to be snooping in their console get more realistic feedback about what happened.

Since we are standardizing our error handling for API interactions, the best place to start seems to be our `axiosCreateClient` utility function.

``` javascript(/reactive-client/src/sagas/utils/axios_client.js)
import axios from 'axios';
import {  select } from 'redux-saga/effects';

+ const axios_config = {
+   transformResponse: [(data) => {
+     let jdata = JSON.parse(data);
+     if(jdata.type === "ERROR|FAILURE"){ throw jdata.payload }
+     return data;
+   }]
+ };

export default function* axiosCreateClient(req_auth = true){
  let token = yield select((s) => s.user.token);
  let client = axios.create(axios_config);
  
  if(token){
    client.defaults.headers.common['Authorization'] = token;
    return client;
  } else {
    return req_auth ? null : client;
  }
}
```

When creating an Acios client, we have the option of passing a configuration block.  One of these configuration options allows us to define a chain of methods our response data passes through upon receipt.  This method chain can modify the returned data as needed before providing the resolution of our promise.

In the example above, we are inspecting the data passed back from our API, and looking for a `data.type` value that matches our `BaseException` format of "ERROR|FAILURE".  When found, we are going to throw an exception containing the payload of the received action.  Otherwise, we return the unaltered data.  

This change does two things for us.  First, we now can receive errors from our API without sending our responses back with an error status code.  This recoding prevents the browser's default messaging for a 500 response from appearing in our console.  We are also using JavaScript's `throw` method to ensure that these errors still get raised as exceptions on our client.  Let's make a few changes in our API to support what we just did.

``` ruby(/reactive-api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
  rescue_from BaseException, 
    :with => :render_error_response
    
-   def authenticate_request!
-       fail StandardError unless user_id_in_token?
-       @current_user = User.find(@decoded_token["id"])
-   end
  
  private
+     def render_error_response(error)
+       payload = {name: error, message: error.message, status: error.code}
+       render json: {type: error.status, payload: payload}, status: 200
+     end
  
    # Decode the authorization header token and return the payload
-     def user_id_in_token?
-       auth_token && decoded_token && @decoded_token["id"]
-     end
    
-     def decoded_token
-       @decoded_token ||= TokenOps.decode(auth_token)[0]
-     end
  
-     def auth_token
-       @http_auth_token ||= request.headers['Authorization']
-     end
end
```

First, we are reformatting our `render_error_response` output, it takes the form of an FSA, with a type value "ERROR|FAILURE", and a payload containing the details of our error.  Notice that we are also sending the response with 200 (success) status, and sending our error code (500), in the FSA payload.  This change gives us the ability to prevent the browsers default error messaging, while still making the status code available in our action should we need it.

Let's bring this all together by updating our `retrieveUserBookmark` saga utility.

``` javascript(/reactive-client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
    } catch (e) {
+       // fails silently without throwing further errors to parent sagas
+       console.log(e.message);
+       return false;
    }
  } else { return false; }
}
```

When our Axios client receives an error back from our API, it now throws an exception which triggers the `catch` block of our utility function.  In this case, having a bookmark request fail requires no recovery, so I am going to opt to log the message to the console.  We are also returning `false` from our catch block in case we need to indicate to something outside this utility function that we were unable to fetch the resource.

Look at this in your browser again, and you should now see trimmed down logging for our exception; the browser's squawking about a 500 response is gone, leaving behind only our custom error message.

![Console message: No bookmarks were available at login, skipping bookmark prompt.](/images/13/BookmarkSilentError.png)

However, we do have other options.  For more disastrous outcomes, we might want the error to propagate further through our application.  In this instance, our catch block might itself raise further errors.  Imagine for a moment that if a user's bookmarks were unavailable that we wanted to stop their account hydration entirely.

We could do the following to propagate the error further.

``` javascript(/reactive-client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
    } catch (e) {
      // catch block throws additional error to propigate exception through parent saga
      console.log(e.message);
+       throw e;
    }
  } else { return false; }
}
```

Now that our `retrieveUserBookmark` utility is throwing an error as well let's look at our `hydrateUser` saga.

``` javascript(/reactive-client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
    yield call(retrieveUserBookmark);
  } catch(e){
+     console.log("Error propagated to hydrateUser");
+     console.log(e);
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

Take a look at this on your console, and you should see a message logged that our error propagated to this level.

![Bookmark error propagated to hydrateUser saga, displaying message: "Error propagated to hydrateUser" ](/images/13/BookmarkErrorPropigation.png)

** If you have made the changes above for the error propagation example in your code, remove them now.  We will be using the "silent" error going forward for this saga/utility function.**

## Handling Model Validation Errors

Now that we have a scaffold in place let's finish out error handling for our `BookmarksController`.  Our `create` action does not have a natural failure case we need to manage as we did in our `index` action.  However, we should consider that we nothing standing between the `chapter_id` parameter passed to our route, and our database.  Right now, if we try to create a bookmark for the last read chapter with an ID of "tuna fish," our controller happily passes that value along to our model, and by extension our database.

We should change that in case someone gets creative with the parameters passed our API.  Data validation, however, is a Model's job.

``` ruby(/reactive-api/app/models/bookmark.rb)
# == Schema Information
#
# Table name: bookmarks
#
#  id            :integer          not null, primary key
#  last_read     :integer
#  furthest_read :integer
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  user_id       :integer
#

class Bookmark < ApplicationRecord
  belongs_to :user
+   validates :furthest_read, :last_read, 
+     numericality: { integer: true, strict: BookmarkErrors::BookmarkChapterInvalid }
  before_save :ensure_furthest_location
  
-   def fsa
-     {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
-   end
  
-   def ensure_furthest_location
-     if(bm = Bookmark.where(user_id: self.user_id).first)
-       self.furthest_read = bm.furthest_read unless self.furthest_read > bm.furthest_read
-     end
-   end
end
```

We are adding standard Rails validators to ensure our model enforces an integer value on both our `last_read` and `furthest_read` foreign keys.  Normally, a validation error would prevent our model from persisting a transaction to the database, but would not raise an exception.  However, we can change this behavior by passing a key `strict` to the validator, and even provide a custom error we would like it to raise.  Now, anytime our model gets passed a bad ID, it raises  `BookmarkErrors::ChapterInvalid`.

Now, we can define that error.

``` ruby(/reactive-api/lib/api_exceptions/bookmark_errors.rb)
class BookmarkErrors < BaseException
  class BookmarkUnavailable < BookmarkErrors
  end
  
  class BookmarkChapterInvalid < BookmarkErrors
  end
end
```

Moreover, we also want to add an entry to our `ERROR_CODE_MAP` constant inside our `BaseException` class.

``` ruby(/reactive-api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
+     "BookmarkErrors::BookmarkChapterInvalid" =>
+       ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid.")
  }

  def initialize(e)
    error_type = self.class.name
    BaseException::ERROR_CODE_MAP
      .fetch(error_type, {}).each do |attr, value|
        instance_variable_set("@#{attr}".to_sym, value)
    end
  end
end
```

Finally, a small change to our `setBookmarks` saga so that it log's our limited error message to the console.

``` javascript(/reactive-client/src/sagas/set_bookmarks.js)
import { takeEvery, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setBookmarkLocations } from '../actions/bookmarks';

export function* setBookmarks(action){
  let ch_id = action.payload.chapter_id;
  const auth_client = yield axiosCreateClient();
  //Set bookmarks locally
  yield put(setBookmarkLocations(ch_id));
  
  if(auth_client){
    try{
      let response = yield call(auth_client.post,'/api/bookmarks',{chapter_id: ch_id});
      console.log(response.data.message);
    } catch(e){
+       console.log(e.message);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

## Managing Client Error States

So far all our errors client-side have been managed with quiet console logging.  This pattern worked for our bookmarking behavior, which runs silently in the background of our application.  What about more catastrophic errors?  What if our entire book fails to hydrate from the API?

Let's modify our `instantiateBook` saga to handle this hopefully rare case.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
import { takeEvery, select, put, call, all } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';
import { addAlert } from '../actions/alerts';
import { routeError } from '../actions/routes';

export const checkBookHydration = (state) => {
  return !(state.chapters.length && state.nodes.length);
};

export function* instantiateBook(){
  const dehydrated = yield select(checkBookHydration);
  
  if(dehydrated){
    try{
+       const pub_client = yield axiosCreateClient(false);
+       const [nodes, chapters] = yield all([
+         call([pub_client,"get"],'/api/nodes'),
+         call([pub_client,"get"],'/api/chapters')
+       ]);
      
      yield all([
        put(loadNodes(nodes.data)),
        put(loadChapters(chapters.data))
      ]);
    }
    catch(e){
+       yield put(routeError());
+       yield put(addAlert(e.message,"danger"));
    }
  }
} 

export function* watchBookRoutesSaga(){
  yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
}
```
We need minor changes on the client saga to prepare our book hydration methods for errors.  First, we are swapping the generic Axios client for the custom client creation function.  However, in this instance, we are passing it an attribute `false` to override the need for an authentication token.  

Also, notice that we are using a variation of the `call` effect for Redux Saga we have not seen previously.  Passing an array as the first parameter allows us to send in function which sets the context for the method we wish to call, followed by a string of the method names we wish to invoke; in this instance `get`.  This distinction does not matter to us when we are executing this code.  However, when we return here to test this modified saga, this change allows us to pass in a mocked function as the context for `call`, and test that a `get` method is invoked.

Since a failure of this saga means that our book is unavailable we should route to the page we created to handle catastrophic errors, and display an alert message detailing the failure.

Now we can define custom errors for these API routes.  We want to handle errors for our chapters endpoint, as well as the nodes endpoint.

``` ruby(/reactive-api/lib/api_exceptions/chapter_errors.rb)
class ChapterErrors < BaseException
  class ChaptersUnavailable < ChapterErrors
  end
end
```

``` ruby(/reactive-api/lib/api_exceptions/node_errors.rb)
class NodeErrors < BaseException
  class NodesUnavailable < NodeErrors
  end
end
```

Next, define some custom messaging for these exceptions which will also ultimately populate our errors messages on the client.

``` ruby(/reactive-api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
    "BookmarkErrors::BookmarkChapterInvalid" =>
      ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid."),
+     "ChapterErrors::ChaptersUnavailable" =>
+       ERROR_DESCRIPTION.call(500, "Unable to load book's chapters."),
+     "NodeErrors::NodesUnavailable" =>
+       ERROR_DESCRIPTION.call(500, "Unable to load the book's content nodes.")
}

-   def initialize(e = nil)
-     error_type = self.class.name
-     BaseException::ERROR_CODE_MAP
-       .fetch(error_type, {}).each do |attr, value|
-         instance_variable_set("@#{attr}".to_sym, value)
-     end
-   end
end
```
Now we're ready for the controller actions themselves.  Our error cases are simple; if an api action produces an empty payload of either chapters or nodes, we will raise an exception.

``` ruby(/reactive-api/app/controllers/api/chapters_controller.rb)
class Api::ChaptersController < ApplicationController
  def index
    payload = Chapter.all.fsa
+     raise ChapterErrors::ChaptersUnavailable if payload.empty?
    render json: payload, status: 200
  end
end
```

``` ruby(/reactive-api/app/controllers/api/nodes_controller.rb)
class Api::NodesController < ApplicationController
  def index
    payload = Node.all.fsa
+     raise NodeErrors::NodesUnavailable if payload.empty?
    render json: payload, status: 200
  end
end
```
Now I am going to manually change my `NodesController#index` action to return an empty array for its payload.  When you load the application again, you should see our error page and message waiting to greet you.

![Catastrophic error page with the alert message "Unable to load the book's content nodes."](/images/13/CatastrophicErrorPage.png)

## Handling Authentication Errors

The last area we need to add error coverage to is our authentication controller. 

I see two main points of failure in our authentication routes.  The first step of our sign in flow handles the communication with Github and is the more challenging to handle.  At this stage, we have completely torn down our client, redirecting our users onto Github's site to validate tokens and handle our OAuth.  That leaves us disconnected from all the architecture we built into our client to handle error conditions.

If we can make it past this first step, our `AuthenticationController#show` action is easier to manage, because we have redirected the user back to our client application. 

Before we look at our controller, I am going to set up two new error classes.

``` ruby(/reactive-api/lib/api_exceptions/authentication_errors.rb)
class AuthenticationErrors < BaseException
  class GithubFailure < AuthenticationErrors
  end
  
  class BadToken < AuthenticationErrors
  end
end
```

We also need to define our message for each error.

``` ruby(/reactive-api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
    "BookmarkErrors::BookmarkChapterInvalid" =>
      ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid."),
    "ChapterErrors::ChaptersUnavailable" =>
      ERROR_DESCRIPTION.call(500, "Unable to load book's chapters."),
    "NodeErrors::NodesUnavailable" =>
      ERROR_DESCRIPTION.call(500, "Unable to load the book's content nodes."),
+     "AuthenticationErrors::GithubFailure" =>
+       ERROR_DESCRIPTION.call(500, "We are unable to communicate with Github to complete your sign-in.  Please try again later."),
+     "AuthenticationErrors::BadToken" =>
+       ERROR_DESCRIPTION.call(500, "Your session has expired or is no longer valid, please sign in again.")
  }

-   def initialize(e = nil)
-     error_type = self.class.name
-     BaseException::ERROR_CODE_MAP
-       .fetch(error_type, {}).each do |attr, value|
-         instance_variable_set("@#{attr}".to_sym, value)
-     end
-   end
end
```

Now let's consider the first step of our authentication, handled on Github's environments.

``` ruby(/reactive-api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    begin
      code = params[:code]
      bounce_path = ERB::Util.url_encode(params[:bounce_path])
      github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
      token = github.get_token(code).token
      
      github_users = Github::Client::Users.new oauth_token: token
      user = User.create_or_fetch(github_users.get)
      jwt = TokenOps.encode_short(user)
      
      redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
+     rescue
+       redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
+     end
  end
  
-   def show
-     token = params[:token]
-     user_id = TokenOps.decode(token)[0]["id"]
-     user = User.find(user_id)
-     long_token = TokenOps.encode_long(user)
-     
-     render json: user.fsa(long_token), status: 200
-   end
end
```

First, we are wrapping this entire action in a `begin` and `rescue` block.  When we opt not to pass a specific error type to `rescue`, it tries to step in and handle any exceptions raised.  I prefer this pattern when working with external libraries where I do not have control over the specific exceptions raised.  Several things could go wrong here; GitHub might be offline, our client key/secret could be invalid, or we might fail to find a user at all.

It does not matter, all we need to know is whether the process as a whole finished without exception.  If we do have a failure in this process, we rescue that exception and then redirect our user to the next step of the login process.  As we do so, we pass "githubfailure" instead of a valid JWT token.  We also pass along the `bounce_path` parameter, so it is available in the next step of our process.

Why are we doing this?  We cannot raise an exception right now, or at least we should not.  We are sitting on an API route in our browser, which means if I were to raise `AuthenticationErrors::GithubFailure` in this controller action we would end up rendering that JSON error message to the screen, and none of our other UI.

Instead, we pass the user deeper into our sign-in process and handle errors once we have a client restored.  Let's set that up now.

``` ruby(/reactive-api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
-   def github
-     begin
-       code = params[:code]
-       bounce_path = ERB::Util.url_encode(params[:bounce_path])
-       github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
-       token = github.get_token(code).token
-       
-       github_users = Github::Client::Users.new oauth_token: token
-       user = User.create_or_fetch(github_users.get)
-       jwt = TokenOps.encode_short(user)
-       
-       redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
-     rescue
-       redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
-     end
-   end
  
  def show
    begin 
      token = params[:token]
      user_id = TokenOps.decode(token)[0]["id"]
      user = User.find(user_id)
      long_token = TokenOps.encode_long(user)
      
      render json: user.fsa(long_token), status: 200
+     rescue
+       raise token == "githubfailure" ? AuthenticationErrors::GithubFailure : AuthenticationErrors::BadToken
+     end
  end
end
```

Our show action now receives the users who failed in the Github portion of our authentication and has a preset token value "githubfailure" to identify them.  When our `show` action attempts to decode this string, it raises further exceptions as it is not a valid JSON Web Token.

We can then check the token value given, and if it is our preset "githubfailure" value we know the failure occurred on Github's end of the process, and we can raise an error to this effect.

For all other exceptions, we raise `AuthenticationErrors::BadToken` to cover issues related to decoding our JWT such as expired or invalid tokens.

Now all that is left to do is upgrade our `hydrateUser` saga to leverage this new error handling capability on our API.  These changes are identical to what we have seen in previous examples.  We need to change the saga to use our custom Axios client and decide what to do on error states.  In this case, we print an alert with the failure message and allow the redirect to our `bounce_path` to continue uninterrupted.  The user lands back where they started even if their login failed.

``` javascript(/reactive-client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
+     const pub_client = yield axiosCreateClient(false);
+     let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
    yield call(retrieveUserBookmark);
  } catch(e){
+     yield put(addAlert(e.message,"warning"));
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
}
```

## Token Expiration & Application Controller Errors

We now have error handling built into all our API endpoints.  You might be noticing one significant gap in our coverage though.  Our application controller handles a fair bit of heavy lifting for any actions that require user authentication, and there are some error conditions we still really need to handle.

Most notable among these is how we deal with expired, and to a lesser extent, invalid JWT tokens.  We need to be prepared for a token to be sent that has outlived its expiration, and know how to handle these requests.  With our current setup, I am frankly not sure how to handle this. 

As we add authenticated actions in the future, I do not particularly want to build logic into each of our actions to handle token expiration and redirecting a user back through a login flow.  That is going to be both disruptive to our users, and a pain for us to maintain without repetition in our codebase. 

We are going to put error coverage for this area on hold for the moment, and revisit the topic in the next chapter while doing a more extensive refactor on our login & session rehydration processes.

## Error Path Test Coverage

Before we close out this chapter, we should add tests for our error states to each of the controllers we updated this chapter and their matching sagas.  We can begin by adding tests to our controllers themselves.

``` ruby(/reactive-api/spec/controllers/api/bookmarks_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::BookmarksController, type: :controller do
  before(:each) do
    @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
    @user.bookmark = Bookmark.create(last_read: 1, furthest_read: 1)
    request.headers.merge! request_as(@user)
  end
  
  describe "post #create" do
-     it "returns http successfor numeric chapter_id" do
-       post :create, params: {chapter_id: 2}
-       expect(response).to have_http_status(:success)
-       @user.reload
-       expect(@user.bookmark.last_read).to eq 2
-       expect(@user.bookmark.furthest_read).to eq 2
-     end
    
+     it "returns an error on non-numeric chapter_id" do
+       post :create, params: {chapter_id: "badvalue"}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
  
  describe "GET #idex" do
-     it "returns a user bookmark if available" do
-       get :index
-       expect(response).to have_http_status(:success)
-       expect(response.body).to eq "{\"user_id\":1,\"last_read\":1,\"furthest_read\":1}"
-     end
    
+     it "returns and error if no bookmark is available" do
+       @user.bookmark.destroy
+       get :index
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
end 
```

``` ruby(/reactive-api/spec/controllers/api/nodes_controller_spec.rb)
RSpec.describe Api::NodesController, type: :controller do
  describe "GET #idex" do
    it "returns nodes if available" do
      chapter = Chapter.create(title: "test run")
      chapter.nodes.create(node_type: "paragraph", content: "hello world")
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)[0]["content"]).to eq "hello world"
    end
    
    it "raises error if node unavailable" do
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
    end
  end
end 
```

``` ruby(/reactive-api/spec/controllers/api/chapters_controller_spec.rb)
RSpec.describe Api::ChaptersController, type: :controller do
  describe "GET #idex" do
    it "returns nodes if available" do
      Chapter.create(title: "test run")
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)[0]["title"]).to eq "test run"
    end
    
    it "raises error if node unavailable" do
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
    end
  end
end 
```

Now we also need to update our saga tests, as several areas we refactored are now failing in our test suite.

``` javascript(/reactive-client/src/sagas/instantiate_book.spec.js)
/* global expect, jest */
import { instantiateBook, checkBookHydration } from './instantiate_book';
import { cloneableGenerator } from 'redux-saga/utils';
import { select, all, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';
import { addAlert } from '../actions/alerts';

- describe("checkBookHydration", ()=> {
-   const cases = [
-     {state: {nodes: [], chapters: [] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: [] }, outcome: true},
-     {state: {nodes: [], chapters: ["populated"] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: ["populated"] }, outcome: false}
-   ];
-   
-   cases.forEach((test_case) => {
-     test("provides expected outcome", () => {
-       expect(checkBookHydration(test_case.state)).toEqual(test_case.outcome);
-     });
-   });
- });

describe("instantiateBook", () => {
  var saga = {};
  saga.gen = cloneableGenerator(instantiateBook)();
  
  test("begins by checking hydration of book nodes/chapters",() => {
    expect(saga.gen.next().value).toMatchObject(select(checkBookHydration));
    saga.dehydrated = { gen: saga.gen.clone() };
    saga.hydrated = saga.gen.clone();
  });
  
  describe("BRANCH dehydration === false ", ()=> {
    test("ends saga",() => {
      expect(saga.hydrated.next(false).done).toEqual(true);
    });
  });
  
  describe("BRANCH dehydration === true", ()=> {
+     test("begin by setting up a non-authenticate axios client", ()=>{
+       expect(saga.dehydrated.gen.next(true).value).toEqual(call(axiosCreateClient,false));
+     });
    
+     test("begins /api/nodes && api/chapters requests", ()=> {
+       let pub_client = {"get": jest.fn()};
+       expect(saga.dehydrated.gen.next(pub_client).value).toEqual(
+         all([
+           call([pub_client,"get"],'/api/nodes'),
+           call([pub_client,"get"],'/api/chapters')
+         ])
+       );
      
      saga.dehydrated = {
        red: saga.dehydrated.gen.clone(),
        green: saga.dehydrated.gen.clone()
      };
    });
    
    describe("BRANCH try/catch === green", () => {
      test("dispatches loadNodes and loadChapters with returned data", ()=> {
        let [nodes, chapters] = [
          {data: [{content: "Test node"}]},
          {data: [{title: "Test Chapter"}]}
        ];
        
        expect(saga.dehydrated.green.next([nodes, chapters]).value).toEqual(all([
          put(loadNodes(nodes.data)),
          put(loadChapters(chapters.data))
        ]));
      });
    });
    
    describe("BRANCH try/catch === red", () => {
      test("dispatches ADD_ALERT with message of failed load", () =>{
        let red_case = saga.dehydrated.red.next(new Error("awww shiiit."));
+         expect(red_case.value.PUT.action.type).toEqual("ERROR_ROUTE");
      });
    });
  });
});
```

We need to add a step in our saga test to set up the public axios client using our utility function.  Here's where things get a little tricky.  Remember earlier in this chapter we refactored our `call` effect for communicating with the API to take the form `call([pub_client,"get"],'path...')`.  At the time we said this was done to allow testing.

Our saga tests are designed to check that the saga middleware receives the correct instructions as each step of our saga executes.  We advance the generator each test by invoking `next` again and passing in the value from our previous step.

With our `axiosCreateClient` function though, the outcome of the previous step should be a client object, on which, we want to invoke the `get` method.  With the old `call` syntax, we had no way to properly seed a client to the next step of our saga short of actually executing our create client function.  However, we do not actually need a client.  We just need to know that our generator takes the previously yielded value of our saga, and attempts to access a `get` method on the object received.  

With the altered call syntax, we can create a mock to do just that, and pass it in with our invocation of `next`.  Then our testing proceeds as usual, and we merely test that the saga calls the appropriate methods on our mock in its next instruction to the middleware.

You can see this again in the following example for `hydrateUser`.

``` javascript(/reactive-client/src/sagas/hydrate_user.spec.js)
/* global expect, jest */
import { call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';
import axios from 'axios';

import { hydrateUser } from './hydrate_user';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import retrieveUserBookmark from './utils/retrieve_bookmark';

describe("hydrateUser GREEN path", () => {
  let path = encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
+   test("then sets up a public axios client",() =>{
+     expect(saga.next().value).toEqual(call(axiosCreateClient,false));
+   });
  
+   test("saga then trades temp token for long-term",() => {
+     let pub_client = {"get": jest.fn()};
+     expect(saga.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token));
+   });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});

+ describe("hydrateUser RED path", () => {
+   let saga = hydrateUser();
+ 
+   test("begins by redirecting if path provided",() => {
+     let error = saga.next(new Error()).value;
+     expect(error["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
+   });
}); 
```

## Summary

This chapter we set up an error handling system for our API that should cover 90% of our needs.  The most glaring gap it leaves us is coverage of our ApplicationController and the management of our authentication tokens.

In the next chapter, we handle the remaining error states we need to address by revisiting our authentication and signout process.  We will be using some advanced concurrency patterns offered by Redux Saga to manage our tokens throughout their lifespan, and ensure we have a graceful way of handling our state if the user unexpectedly passes an expired or invalid token in the midst of a secure controller action.