# Chapter 13: Elegant Error Handling

It's time to revisit how we manage errors and ensure our application can handle the unexpected.  We've been managing errors conditions case by case, and sometimes, we have ignored them entirely to focus on other topics.  In this chapter, we introduce custom error handling on our API, standardizing the way we respond to and recover from errors.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch13-starter
```

## Credit Where it is Due

Searching for a solution, I encountered an excellent article by Sophie DeBenedetto on error handling within Rails APIs.  Her work heavily influenced this chapter, and I would like to say thank you by recommending her original article, [Rails API Painless Error Handling and Rendering](http://www.thegreatcodeadventure.com/rails-api-painless-error-handling-and-rendering-2/) for her clear and concise coverage of this topic.

## Iteration Objectives

There are two goals for this iteration.

The first is removing as much error handling as possible out of our controllers.  Our controllers should raise errors when appropriate but rely on a shared external class to manage responses to our client.

I also want to keep error recovery client-side, and managed in our sagas.  If an API error derails a saga, our client needs to know.  However, since our API lacks visibility into the store's complete state, our client can better decide what recovery steps to take.

## Autoloading Modules

We are going to build error handling as a module inside our API's `lib/` directory.  We should modify Rail's autoload paths, ensuring classes we define load automatically with rails.  Open `application.rb` and modify it as shown below.

``` ruby(/api/config/application.rb)
require_relative 'boot'

require "rails"
# Pick the frameworks you want:
require "active_model/railtie"
require "active_job/railtie"
require "active_record/railtie"
require "action_controller/railtie"
require "action_mailer/railtie"
require "action_view/railtie"
require "action_cable/engine"
# require "sprockets/railtie"
require "rails/test_unit/railtie"

# Require the gems listed in Gemfile, including any gems
# you've limited to :test, :development, or :production.
Bundler.require(*Rails.groups)

module ReactiveApi
  class Application < Rails::Application
    # Initialize configuration defaults for originally generated Rails version.
    config.load_defaults 5.1

    # Settings in config/environments/* take precedence over those specified here.
    # Application configuration should go into files in config/initializers
    # -- all .rb files in that directory are automatically loaded.

    # Only loads a smaller set of middleware suitable for API only apps.
    # Middleware like session, flash, cookies can be added back manually.
    # Skip views, helpers and assets when generating a new resource.
    config.api_only = true
+     config.autoload_paths << "#{Rails.root}/lib/api_exceptions"
  end
end

```

This new autoload path ensures files in `lib/api_exceptions` are available at runtime. 

## Creating a BaseException Class

We are going to build a common ancestor from which all our custom errors can inherit behaviors. This ancestor provides a standard interface for all our errors, and this commonality simplifies managing exception responses in mass.

Let's talk about this base class first.  Set up the file below.

``` ruby(/api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
+   attr_reader :status, :code, :message

+   ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
  }

  def initialize(e)
    error_type = self.class.name
    BaseException::ERROR_CODE_MAP
      .fetch(error_type, {}).each do |attr, value|
        instance_variable_set("@#{attr}".to_sym, value)
    end
  end
end
```

Our attribute readers provide the best guide to the interface on this class.  We are expecting errors that inherit from `BaseException` to provide attributes for a message, code, and status.

If you look at the initialize method, we access the class name of the error through self-inspection.  If an instance of `BookmarkErrors::BookmarkUnavailable` is raised, we capture that class name in our `error_type` variable.  This captured name is then used to fetch a key from the `ERROR_CODE_MAP` constant, which contains an entry for each of our custom error types.

Each error type in the `ERROR_CODE_MAP` invokes a Proc that sets up an object containing status, code, and message keys.  If you haven't worked with Procs before, think of them as blocks assigned to functions; the critical difference is that you can assign Procs to variables, and invoke them in different contexts.  In this case, we call the Proc to build a return object each time something accesses our error map.  

Using the object returned from our error map, we assign instance variables for each of the keys.  This approach creates the three attribute readers defined by the `BaseException` class.

Let's look at an actual error class for `BookmarkErrors::BookmarkUnavailable`.

``` ruby(/api/lib/api_exceptions/bookmark_errors.rb)
class BookmarkErrors < BaseException
  class BookmarkUnavailable < BookmarkErrors
  end
end
```

All we need to do is define the class itself.  So long as we don't override the `initialize` method, our custom error inherits this functionality from its parent class `BaseException`.  We also gain access to the readable attributes defined by the parent class.

## Catching Custom Errors

Now we need catch errors; centralizing this process in `ApplicationController`.

``` ruby(/api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
+   rescue_from BaseException, 
+     :with => :render_error_response
    
  def authenticate_request!
      fail StandardError unless user_id_in_token?
      @current_user = User.find(@decoded_token["id"])
  end
  
  private
+     def render_error_response(error)
+       render json: {name: error, message: error.message, status: error.code}, status: error.code
+     end
  
    # Decode the authorization header token and return the payload
-     def user_id_in_token?
-       auth_token && decoded_token && @decoded_token["id"]
-     end
    
-     def decoded_token
-       @decoded_token ||= TokenOps.decode(auth_token)[0]
-     end
  
-     def auth_token
-       @http_auth_token ||= request.headers['Authorization']
-     end
end
```

Using a `rescue_from` hook, we listen for instances of `BaseException` to be raised.  Since all our custom errors inherit from `BaseException`, our application controller catches all custom errors and uses `render_error_response` to create responses for our client.  Since all of our controllers inherit from our `ApplicationController`, we just added this coverage across all our controller actions.

`render_error_response` itself is simple; we rescue any actions that raise a `BaseException` by rendering JSON containing our error message, code, and status.  The error's code also sets the code for the response.

## Raising Errors Client-Side

With our API raising errors, we're ready to catch problems client-side.  Before we begin, I want to temporarily force error responses from our controller to simplify testing our work.  Make the following changes to `BookmarksController`.

``` ruby(/api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
  before_action :authenticate_request!, only: [:index, :create]
  
+   def index
+     # if(bm = @current_user.bookmark)
+     #   render json: bm.fsa, status: 200
+     # else
+       raise BookmarkErrors::BookmarkUnavailable
+     # end
+   end
  
-   def create
-     ch_id = params[:chapter_id]
-     
-     bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
-     bookmark.update(last_read: ch_id, furthest_read: ch_id)
-     render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
-   end
end
```

We are commenting out the majority of `BookmarksController#index`, forcing it to raise an error.  We can revert these changes later.

Next, modify our `retrieve_bookmark` saga utility.

``` javascript(/client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
+     } catch (e) {
+       console.log(e.response.data);
+       return false;
+     }
  } else { return false; }
}
```

A try/catch block around our API call now manages error responses from our requests.  For now, let's log error responses to the console as-is and return false if the request failed.

Open your browser, and log into an account.  You should now see an error response for the request logged to your console.

![First Custom Error Response: {name: "BookmarkErrors::BookmarkUnavailable", message: "No bookmarks were available at login, skipping bookmark prompt.", status: 500}](/images/13/BookmarkUnavailableErrorResponse.png)

## Standardizing Client Responses 

We have a foundation in place now standardizing server-side error handling.  Let's try to give the client a similar treatment.

I also have one other small design complaint.  Look at the console log generated by the browser request for the `api/bookmarks` route.  Since our route returned a 500 error, chrome is highlighting this request as failed in our console output.  However, our route didn't fail; it behaved precisely as we hoped when encountering this particular edge case.  The first time a user signs into their account, they have no server-side bookmarks to fetch.

Logging this as an error might give the false impression something broke in our application.  I want to change this logging to give more realistic feedback.

Since we are standardizing error handling for API requests, the best place to work seems like our `axiosCreateClient` generator.

``` javascript(/client/src/sagas/utils/axios_client.js)
import axios from 'axios';
import {  select } from 'redux-saga/effects';

+ const axios_config = {
+   transformResponse: [(data) => {
+     let jdata = JSON.parse(data);
+     if(jdata.type === "ERROR|FAILURE"){ throw jdata.payload }
+     return data;
+   }]
+ };

export default function* axiosCreateClient(req_auth = true){
  let token = yield select((s) => s.user.token);
  let client = axios.create(axios_config);
  
  if(token){
    client.defaults.headers.common['Authorization'] = token;
    return client;
  } else {
    return req_auth ? null : client;
  }
}
```

When creating an Acios client, we can define methods to parse response data or arrival.  These methods can modify the returned data before resolving Axios' promise.

In the example above, we inspect the data passed from our API, looking for a `data.type` value that matches our `BaseException` type value: "ERROR|FAILURE".  When found, throw an exception containing the payload of the error.  Otherwise, we return the unaltered data.  

This change does two things for us.  We can receive errors from our API without sending responses with an error status code.  This change prevents the browser's default messaging for 500 responses from appearing in our console.  However, using JavaScript's `throw` method ensures these errors still get raised as exceptions on our client.  Let's make a few changes in our API to support what we just did.

``` ruby(/api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
  rescue_from BaseException, 
    :with => :render_error_response
    
-   def authenticate_request!
-       fail StandardError unless user_id_in_token?
-       @current_user = User.find(@decoded_token["id"])
-   end
  
  private
+     def render_error_response(error)
+       payload = {name: error, message: error.message, status: error.code}
+       render json: {type: error.status, payload: payload}, status: 200
+     end
  
    # Decode the authorization header token and return the payload
-     def user_id_in_token?
-       auth_token && decoded_token && @decoded_token["id"]
-     end
    
-     def decoded_token
-       @decoded_token ||= TokenOps.decode(auth_token)[0]
-     end
  
-     def auth_token
-       @http_auth_token ||= request.headers['Authorization']
-     end
end
```

First, we are reformatting `render_error_response` as an action with a type value "ERROR|FAILURE", and a payload containing our error.  We are now sending the response with a 200 (success) status, and sending our error code (500), in the FSA payload, so the status code is available in our action should we need it.

Let's bring this all together by updating our `retrieveUserBookmark` saga utility.

``` javascript(/client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
    } catch (e) {
+       // fails silently without throwing further errors to parent sagas
+       console.log(e.message);
+       return false;
    }
  } else { return false; }
}
```

When our Axios client receives an error from our API, it throws an exception, triggering the `catch` block of our utility function.  We are also returning `false` from our catch block in case we need to indicate to something outside this utility function that we were unable to fetch the resource.

Look at this in your browser again; the browser's squawking about a 500 response is gone, leaving behind only our custom error message.

![Console message: No bookmarks were available at login, skipping bookmark prompt.](/images/13/BookmarkSilentError.png)

However, we do have other options.  For more disastrous outcomes, we might want the error to propagate further through our application.  In that instance, our catch block might itself raise further errors.  

Looking at the example below, imagine that if a user's bookmarks were unavailable, we wanted to stop account hydration entirely.

``` javascript(/client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    try{
      let response = yield call(auth_client.get, "/api/bookmarks");
      let lr = response.data.last_read || 0;
      let fr = response.data.furthest_read || 0;
      
      yield put(setBookmarkLocations(fr));
      yield put(setBookmarkLocations(lr));
      
      yield put(setBookmarkOffered(false));
      
      return true;
    } catch (e) {
      // catch block throws additional error to propigate exception through parent saga
      console.log(e.message);
+       throw e;
    }
  } else { return false; }
}
```

Now that our `retrieveUserBookmark` utility is throwing an error as well, let's look at what happens inside our `hydrateUser` saga.

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
    yield call(retrieveUserBookmark);
  } catch(e){
+     console.log("Error propagated to hydrateUser");
+     console.log(e);
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

Take a look at this on your console, and you should see that our error propagated to our saga.

![Bookmark error propagated to hydrateUser saga, displaying message: "Error propagated to hydrateUser" ](/images/13/BookmarkErrorPropigation.png)

** If you have made the changes above for the error propagation example in your code, remove them now. **

## Handling Model Validation Errors

Let's finish out error handling for our bookmarking workflow.

There's currently nothing validating the `chapter_id` parameter passed in our bookmark route and our database.  Right now, if we try to create a bookmark for the last read chapter with an ID of "tuna fish," our controller happily passes that value to our model, and by extension our database.

We should change that in case someone gets creative with the parameters passed our API.  Data validation, however, is a Model's job.

``` ruby(/api/app/models/bookmark.rb)
# == Schema Information
#
# Table name: bookmarks
#
#  id            :integer          not null, primary key
#  last_read     :integer
#  furthest_read :integer
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  user_id       :integer
#

class Bookmark < ApplicationRecord
  belongs_to :user
+   validates :furthest_read, :last_read, 
+     numericality: { integer: true, strict: BookmarkErrors::BookmarkChapterInvalid }
  before_save :ensure_furthest_location
  
-   def fsa
-     {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
-   end
  
-   def ensure_furthest_location
-     if(bm = Bookmark.where(user_id: self.user_id).first)
-       self.furthest_read = bm.furthest_read unless self.furthest_read > bm.furthest_read
-     end
-   end
end
```

Adding Rails validators ensures our model enforces an integer value on both our `last_read` and `furthest_read` foreign keys.  Normally, validation errors prevent our model from persisting a transaction to the database but don't raise exceptions.  We can change that behavior by adding a key `strict` to the validator and providing an error we would like raised.  Now, anytime our model gets passed a bad ID, it raises  `BookmarkErrors::ChapterInvalid`.

Now, we can define that error.

``` ruby(/api/lib/api_exceptions/bookmark_errors.rb)
class BookmarkErrors < BaseException
  class BookmarkUnavailable < BookmarkErrors
  end
  
  class BookmarkChapterInvalid < BookmarkErrors
  end
end
```

We also need an entry in our `ERROR_CODE_MAP` constant inside our `BaseException` class.

``` ruby(/api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
+     "BookmarkErrors::BookmarkChapterInvalid" =>
+       ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid.")
  }

  def initialize(e)
    error_type = self.class.name
    BaseException::ERROR_CODE_MAP
      .fetch(error_type, {}).each do |attr, value|
        instance_variable_set("@#{attr}".to_sym, value)
    end
  end
end
```

Finally, make a small change to our `setBookmarks` saga so it log's our error message to the console.

``` javascript(/client/src/sagas/set_bookmarks.js)
import { takeEvery, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setBookmarkLocations } from '../actions/bookmarks';

export function* setBookmarks(action){
  let ch_id = action.payload.chapter_id;
  const auth_client = yield axiosCreateClient();
  //Set bookmarks locally
  yield put(setBookmarkLocations(ch_id));
  
  if(auth_client){
    try{
      let response = yield call(auth_client.post,'/api/bookmarks',{chapter_id: ch_id});
      console.log(response.data.message);
    } catch(e){
+       console.log(e.message);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

## Managing Client Error States

So far all our errors client-side have been managed with quiet console logging.  This design worked for bookmarking, which runs silently in the background of our application.  What about more visible or catastrophic errors?  What if our entire book fails to hydrate from the API?

Let's modify our `instantiateBook` saga to handle this hopefully rare case.

``` javascript(/client/src/sagas/instantiate_book.js)
import { takeEvery, select, put, call, all } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';
import { addAlert } from '../actions/alerts';
import { routeError } from '../actions/routes';

export const checkBookHydration = (state) => {
  return !(state.chapters.length && state.nodes.length);
};

export function* instantiateBook(){
  const dehydrated = yield select(checkBookHydration);
  
  if(dehydrated){
    try{
+       const pub_client = yield axiosCreateClient(false);
+       const [nodes, chapters] = yield all([
+         call([pub_client,"get"],'/api/nodes'),
+         call([pub_client,"get"],'/api/chapters')
+       ]);
      
      yield all([
        put(loadNodes(nodes.data)),
        put(loadChapters(chapters.data))
      ]);
    }
    catch(e){
+       yield put(routeError());
+       yield put(addAlert(e.message,"danger"));
    }
  }
} 

export function* watchBookRoutesSaga(){
  yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
}
```

First, we are upgrading this saga to use our `axiosCreateClient` utility; passing it an attribute `false` to override the need for an authentication token.  This setup ensures we have access to the error response handling we wrote earlier this chapter.

We are using a variation of the `call` effect we haven't seen previously.  Passing an array as the first parameter allows us to send in function which sets the context for the method we wish to call, followed by a string of the method names we wish to invoke; in this instance `get`.  This distinction does not matter to us when we are executing this code.  However, when we return here to test this modified saga, this change allows us to pass in a mocked function as the context for `call`, and test the invocation of a `get` method on that context.

Since a failure in this saga leaves our book completely unavailable, we route to our error page, and display an alert message detailing the failure.

Next, let's define custom errors for our node and chapter routes so we can provide detail about what went wrong in our UI alert.

``` ruby(/api/lib/api_exceptions/chapter_errors.rb)
class ChapterErrors < BaseException
  class ChaptersUnavailable < ChapterErrors
  end
end
```

``` ruby(/api/lib/api_exceptions/node_errors.rb)
class NodeErrors < BaseException
  class NodesUnavailable < NodeErrors
  end
end
```

Next, define custom messages for these exceptions to populate our alerts client-side.

``` ruby(/api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
    "BookmarkErrors::BookmarkChapterInvalid" =>
      ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid."),
+     "ChapterErrors::ChaptersUnavailable" =>
+       ERROR_DESCRIPTION.call(500, "Unable to load book's chapters."),
+     "NodeErrors::NodesUnavailable" =>
+       ERROR_DESCRIPTION.call(500, "Unable to load the book's content nodes.")
}

-   def initialize(e = nil)
-     error_type = self.class.name
-     BaseException::ERROR_CODE_MAP
-       .fetch(error_type, {}).each do |attr, value|
-         instance_variable_set("@#{attr}".to_sym, value)
-     end
-   end
end
```
Now we're ready to upgrade our controller actions.  Our error cases are simple; given an empty payload of either chapters or nodes, we should raise an exception.

``` ruby(/api/app/controllers/api/chapters_controller.rb)
class Api::ChaptersController < ApplicationController
  def index
    payload = Chapter.all.fsa
+     raise ChapterErrors::ChaptersUnavailable if payload.empty?
    render json: payload, status: 200
  end
end
```

``` ruby(/api/app/controllers/api/nodes_controller.rb)
class Api::NodesController < ApplicationController
  def index
    payload = Node.all.fsa
+     raise NodeErrors::NodesUnavailable if payload.empty?
    render json: payload, status: 200
  end
end
```

Changing my `NodesController#index` action to return an empty array, causes our error page and message to display when the application reloads.

![Catastrophic error page with the alert message "Unable to load the book's content nodes."](/images/13/CatastrophicErrorPage.png)

## Handling Authentication Errors

The last area we need to add error coverage on is our authentication process. I see two main points of failure during authentication.  

The first step of sign-in is communicating with Github.  During this step, we have completely torn down our client, redirecting our users to Github to validate OAuth credentials.  That leaves us disconnected from all the application architecture we built to handle error conditions.

If we can make it past this first step, our `AuthenticationController#show` action is easier to manage, because we have redirected the user back into our client application. 

Before we look at our controller, I am going to set up two new error classes.

``` ruby(/api/lib/api_exceptions/authentication_errors.rb)
class AuthenticationErrors < BaseException
  class GithubFailure < AuthenticationErrors
  end
  
  class BadToken < AuthenticationErrors
  end
end
```

We also need to define a message for each error.

``` ruby(/api/lib/api_exceptions/base_exception.rb)
class BaseException < StandardError
  include ActiveModel::Serialization
  attr_reader :status, :code, :message

  ERROR_DESCRIPTION = Proc.new {|code, message| {status: "ERROR|FAILURE", code: code, message: message}}
  ERROR_CODE_MAP = {
    "BookmarkErrors::BookmarkUnavailable" =>
      ERROR_DESCRIPTION.call(500, "No bookmarks were available at login, skipping bookmark prompt."),
    "BookmarkErrors::BookmarkChapterInvalid" =>
      ERROR_DESCRIPTION.call(500, "Bookmark update failed, chapter was invalid."),
    "ChapterErrors::ChaptersUnavailable" =>
      ERROR_DESCRIPTION.call(500, "Unable to load book's chapters."),
    "NodeErrors::NodesUnavailable" =>
      ERROR_DESCRIPTION.call(500, "Unable to load the book's content nodes."),
+     "AuthenticationErrors::GithubFailure" =>
+       ERROR_DESCRIPTION.call(500, "We are unable to communicate with Github to complete your sign-in.  Please try again later."),
+     "AuthenticationErrors::BadToken" =>
+       ERROR_DESCRIPTION.call(500, "Your session has expired or is no longer valid, please sign in again.")
  }

-   def initialize(e = nil)
-     error_type = self.class.name
-     BaseException::ERROR_CODE_MAP
-       .fetch(error_type, {}).each do |attr, value|
-         instance_variable_set("@#{attr}".to_sym, value)
-     end
-   end
end
```

Let's consider the first step of our authentication, handled on Github's environments.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    begin
      code = params[:code]
      bounce_path = ERB::Util.url_encode(params[:bounce_path])
      github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
      token = github.get_token(code).token
      
      github_users = Github::Client::Users.new oauth_token: token
      user = User.create_or_fetch(github_users.get)
      jwt = TokenOps.encode_short(user)
      
      redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
+     rescue
+       redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
+     end
  end
  
-   def show
-     token = params[:token]
-     user_id = TokenOps.decode(token)[0]["id"]
-     user = User.find(user_id)
-     long_token = TokenOps.encode_long(user)
-     
-     render json: user.fsa(long_token), status: 200
-   end
end
```

We have wrapped this entire action in a `begin` and `rescue` block.  When `rescue` isn't given a specific error to catch, it steps in, attempting to handle any exceptions raised.  That catchall design is ideal when working with external libraries where several things could go wrong; GitHub might be offline, our client key/secret could be invalid, or any number of problems outside our control.

All we need to know is whether the process as a whole finished without exception.  If we fail, we rescue that exception and redirect our user to the next step of the login process.  As we do so, we pass "githubfailure" in our route, instead of a valid token.  We also continue passing the `bounce_path` parameter, so it remains available for our client.

Why are we doing this?  We can't raise an exception right now, or we shouldn't.  We are sitting on an API route in our browser, which means if I were to raise `AuthenticationErrors::GithubFailure` in this controller action we would render that JSON error message to the screen, and none of our other UI.

We need to pass the user deeper into our sign-in process and handle errors once we have a client restored in their browser.  Let's set that up now.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
-   def github
-     begin
-       code = params[:code]
-       bounce_path = ERB::Util.url_encode(params[:bounce_path])
-       github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
-       token = github.get_token(code).token
-       
-       github_users = Github::Client::Users.new oauth_token: token
-       user = User.create_or_fetch(github_users.get)
-       jwt = TokenOps.encode_short(user)
-       
-       redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
-     rescue
-       redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
-     end
-   end
  
  def show
    begin 
      token = params[:token]
      user_id = TokenOps.decode(token)[0]["id"]
      user = User.find(user_id)
      long_token = TokenOps.encode_long(user)
      
      render json: user.fsa(long_token), status: 200
+     rescue
+       raise token == "githubfailure" ? AuthenticationErrors::GithubFailure : AuthenticationErrors::BadToken
+     end
  end
end
```

Our show action now receives users who failed in the Github portion of our authentication, identified by a token value "githubfailure".  When our `show` action attempts to decode the string "githubfailure", it raises further exceptions since that's not a valid JSON Web Token.

Inside our `rescue`, we check the token value. When the token equals "githubfailure", we know authentication failed in Github's services, and we can raise that error.  All exceptions raise `AuthenticationErrors::BadToken` to cover issues with decoding our JWT, such as expired or invalid tokens.

All that is left is upgrading `hydrateUser` to leverage error handling provided by our API.  We need to change the saga to use our custom Axios client and decide what to do on error conditions.  The change below print an alert with our error message, and redirect to our `bounce_path`.  The user lands back where they started even if their login failed.

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
+     const pub_client = yield axiosCreateClient(false);
+     let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
    yield call(retrieveUserBookmark);
  } catch(e){
+     yield put(addAlert(e.message,"warning"));
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
}
```

## Token Expiration & Application Controller Errors

It might be occurring to you that `ApplicationController` assists with any actions requiring user authentication, and there are error conditions we need to manage.  When our application inevitably receives expired tokens, we need to handle these requests gracefully and minimize user frustrations.

We are putting error coverage for this area on hold for the moment.  We revisit the topic next chapter while doing a more extensive refactor on our login & session rehydration processes.  For now, let's close out this chapter with updates to our test suite.

## Error Path Test Coverage

Before closing this chapter, we should add error path tests to each controller and saga we updated this chapter.  Begin by adding the tests below to your controllers.

``` ruby(/api/spec/controllers/api/bookmarks_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::BookmarksController, type: :controller do
  before(:each) do
    @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
    @user.bookmark = Bookmark.create(last_read: 1, furthest_read: 1)
    request.headers.merge! request_as(@user)
  end
  
  describe "post #create" do
-     it "returns http successfor numeric chapter_id" do
-       post :create, params: {chapter_id: 2}
-       expect(response).to have_http_status(:success)
-       @user.reload
-       expect(@user.bookmark.last_read).to eq 2
-       expect(@user.bookmark.furthest_read).to eq 2
-     end
    
+     it "returns an error on non-numeric chapter_id" do
+       post :create, params: {chapter_id: "badvalue"}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
  
  describe "GET #idex" do
-     it "returns a user bookmark if available" do
-       get :index
-       expect(response).to have_http_status(:success)
-       expect(response.body).to eq "{\"user_id\":1,\"last_read\":1,\"furthest_read\":1}"
-     end
    
+     it "returns and error if no bookmark is available" do
+       @user.bookmark.destroy
+       get :index
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
end 
```

``` ruby(/api/spec/controllers/api/nodes_controller_spec.rb)
RSpec.describe Api::NodesController, type: :controller do
  describe "GET #idex" do
    it "returns nodes if available" do
      chapter = Chapter.create(title: "test run")
      chapter.nodes.create(node_type: "paragraph", content: "hello world")
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)[0]["content"]).to eq "hello world"
    end
    
    it "raises error if node unavailable" do
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
    end
  end
end 
```

``` ruby(/api/spec/controllers/api/chapters_controller_spec.rb)
RSpec.describe Api::ChaptersController, type: :controller do
  describe "GET #idex" do
    it "returns nodes if available" do
      Chapter.create(title: "test run")
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)[0]["title"]).to eq "test run"
    end
    
    it "raises error if node unavailable" do
      get :index
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
    end
  end
end 
```

Next update your saga tests; several areas we refactored are failing our test suite.

``` javascript(/client/src/sagas/instantiate_book.spec.js)
/* global expect, jest */
import { instantiateBook, checkBookHydration } from './instantiate_book';
import { cloneableGenerator } from 'redux-saga/utils';
import { select, all, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';
import { addAlert } from '../actions/alerts';

- describe("checkBookHydration", ()=> {
-   const cases = [
-     {state: {nodes: [], chapters: [] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: [] }, outcome: true},
-     {state: {nodes: [], chapters: ["populated"] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: ["populated"] }, outcome: false}
-   ];
-   
-   cases.forEach((test_case) => {
-     test("provides expected outcome", () => {
-       expect(checkBookHydration(test_case.state)).toEqual(test_case.outcome);
-     });
-   });
- });

describe("instantiateBook", () => {
  var saga = {};
  saga.gen = cloneableGenerator(instantiateBook)();
  
  test("begins by checking hydration of book nodes/chapters",() => {
    expect(saga.gen.next().value).toMatchObject(select(checkBookHydration));
    saga.dehydrated = { gen: saga.gen.clone() };
    saga.hydrated = saga.gen.clone();
  });
  
  describe("BRANCH dehydration === false ", ()=> {
    test("ends saga",() => {
      expect(saga.hydrated.next(false).done).toEqual(true);
    });
  });
  
  describe("BRANCH dehydration === true", ()=> {
+     test("begin by setting up a non-authenticate axios client", ()=>{
+       expect(saga.dehydrated.gen.next(true).value).toEqual(call(axiosCreateClient,false));
+     });
    
+     test("begins /api/nodes && api/chapters requests", ()=> {
+       let pub_client = {"get": jest.fn()};
+       expect(saga.dehydrated.gen.next(pub_client).value).toEqual(
+         all([
+           call([pub_client,"get"],'/api/nodes'),
+           call([pub_client,"get"],'/api/chapters')
+         ])
+       );
      
      saga.dehydrated = {
        red: saga.dehydrated.gen.clone(),
        green: saga.dehydrated.gen.clone()
      };
    });
    
    describe("BRANCH try/catch === green", () => {
      test("dispatches loadNodes and loadChapters with returned data", ()=> {
        let [nodes, chapters] = [
          {data: [{content: "Test node"}]},
          {data: [{title: "Test Chapter"}]}
        ];
        
        expect(saga.dehydrated.green.next([nodes, chapters]).value).toEqual(all([
          put(loadNodes(nodes.data)),
          put(loadChapters(chapters.data))
        ]));
      });
    });
    
    describe("BRANCH try/catch === red", () => {
      test("dispatches ADD_ALERT with message of failed load", () =>{
        let red_case = saga.dehydrated.red.next(new Error("awww shiiit."));
+         expect(red_case.value.PUT.action.type).toEqual("ERROR_ROUTE");
      });
    });
  });
});
```

We're adding a step to our saga test creating a public Axios client using our utility function.  Here's where things get tricky.  Earlier this chapter  we refactored our `call` effects to take the form `call([pub_client,"get"],'path...')`.  At the time, I said this was done to allow easier testing.

Our saga tests are designed to ensure the saga middleware receives accurate instructions during every stage of execution.  We advance the generator each test by invoking `next` and passing in the value from our previous step.

For `yield axiosCreateClient`, the outcome should be a client object, on which we need to invoke a `get` method.  With the old `call` syntax, we had no way to properly mock a client for the next step of our saga without actually executing the function.  That's needlessly painful, where we only need to know our generator takes the previous `yield` value of our saga and calls a `get` method on the object received.  

With the altered call syntax, we can easily supply a mock, and pass it in with our invocation of `next`.  Then testing proceeds and we test that the saga calls the appropriate methods on our mock in its next instruction to the middleware.

You can see this process again in the following example for `hydrateUser`.

``` javascript(/client/src/sagas/hydrate_user.spec.js)
/* global expect, jest */
import { call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';
import axios from 'axios';

import { hydrateUser } from './hydrate_user';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import retrieveUserBookmark from './utils/retrieve_bookmark';

describe("hydrateUser GREEN path", () => {
  let path = encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
+   test("then sets up a public axios client",() =>{
+     expect(saga.next().value).toEqual(call(axiosCreateClient,false));
+   });
  
+   test("saga then trades temp token for long-term",() => {
+     let pub_client = {"get": jest.fn()};
+     expect(saga.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token));
+   });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});

+ describe("hydrateUser RED path", () => {
+   let saga = hydrateUser();
+ 
+   test("begins by redirecting if path provided",() => {
+     let error = saga.next(new Error()).value;
+     expect(error["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
+   });
}); 
```

## Summary

This chapter created error handling for our client and API that should meet 90% of our needs.  The most glaring gap remaining is coverage of our ApplicationController and managing the lifecycle of our authentication tokens.

In the next chapter, we revisit our authentication and signout process.  Using some advanced concurrency patterns offered by Redux Saga we can manage our tokens throughout their lifespan, and ensure we have a graceful way of handling our state when users unexpectedly pass an expired or invalid token in the midst of a secure controller action.