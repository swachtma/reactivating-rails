# Chapter 9: Composing Complex Components

We have done some work with components and containers in previous iterations, but most have been basic UI renderings.  For our next iteration, we are going to be designing one of the more critical elements of our application's interface by improving the way we handle code examples from our book.  As we do so, we will explore mixing components that maintain an independent state from our Redux store. We will also introduce new composability patterns we have not seen before such as ES2015 classes, and component refs to create logical divisions in our code.

## Jumping in Here

If you have not been following along with code examples and wanted to jump in here, you can use our [Chapter9Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter9Starter) branch as a place to join in.

## Planning our Iteration

For a programming book, one of the most important things our application needs to do is effectively handle the display of code examples alongside our text for each chapter.  So far, we have been using out of the box parsing provided by our client and server-side packages to turn markdown into blocks of code.

Considering the minimal amount of effort we had to invest to get this running, we have achieved reasonably good results.  This feature though is core to our application.  There are some improvements we could make to specialize in reading code examples, that would separate our project from other generic e-readers.

**Here's what I would like to tackle in our next iteration:**
* Code examples should support syntax highlighting where a language is denoted in our code blocks, and attempt to detect one automatically when not provided.
* Code lines with notable changes in each example should be highlighted to help our readers focus in on what matters.
* File names/paths should be included in headers for each code example to help the reader identify which file changed.
* Code of lower importance should be markable in a way that allows code to collapse/minimize.  Truncating low priority code reduces the use of vertical screen space, and helps emphasize critical updates.
* Code examples should still support easy copy/paste of each full file to promote ease of use when following along with the book.

## Our Code Fence Markdown

Up until this point, we have been using a standard markdown syntax.  To make some of the changes this iteration, we are going to need to introduce some proprietary formatting.

A standard Markdown code fence opens with three backtick characters, followed by an optional language name.  Such as (``` javascript).  The fence closes with another line containing three backtick characters.  Lines included inside the open and close tags are part of the code example.

We are going to adapt the opening tag syntax to be (``` language(path/to/file.ext)) so that our opening tag can also denote a path to the file we are changing.  Several non-standard Markdown parsers already use this same syntax, so at least we are not going off in entirely new directions.

We are also going to adapt the Github's markdown syntax for diffs to allow us to identify lines of code as being of low, normal, or high priority.

Here is the spec for this feature in our application:
* Normal lines have no marker and are to be treated as they are currently. 
* Low priority lines, are processed to minimize or collapse the code lines into an abbreviated form.  The default behavior collapses low priority items but makes them clickable to expand their contents.  Low priority lines begin with a (- ) character pattern in our examples.
* High priority items are highlighted with a distinctive background color to draw attention to changes in the example code.  High priority lines begin with a (+ ) character pattern.

Put that all together, and we can compare a standard markdown example (left), and our altered syntax (right).  These changes should give us the extra support we need without migrating us too far away from the official markdown spec.

![Markdown Example Syntax](/images/9/MDExample.png)

## Getting Data Ready

We are going to need to break this down bit by bit.  Before we can start working on our new renderings, we need to get our data prepared in a way that's usable for our components.  Right now, we treat the entire contents of our code examples as large multi-line strings.  We are going to need to parse that string content to identify distinctions with each line.

* Isolate/remove the opening and closing code fence markers
* Identify the code language, and file path from the opening code-fence line
* Parse code lines to split each example into sections of low, normal, and high priority code.
* Remove priority markers from each line before rendering, so they are not visible in the final example

This data prep seems like the best place to start to me.  It also looks like an excellent place to use a HOC because we do not need to render anything at this point.  All we are trying to do is produce specialized data/props that meet the needs of our components.  If we split this out as a function/HOC we can cleanly separate the data preparation from the final rendering of our component.  That structure should make our code more explicit, testable, and modular.

## Parsing our Code Block Content

Let's begin by setting up a HOC to hold our parsing logic.  Since I am about to spin up several small components related to rendering nodes I am going to do something I have not previously, and group all of these related files inside a folder `src/components/nodes`.

``` javascript(/reactive-client/src/components/nodes/parse_code_node.js)
import React from 'react';

const parseCodeNode = (node) => {
  let passthroughProps = {
    
  };
  
  return class extends React.Component {
    render(){
      <CodeBlock { ...passthroughProps } />;
    }
  };
};

export default parseCodeNode;

class CodeBlock extends Component {
  render(){
+     return <div>{ JSON.stringify(this.props) }</div>;
  }
}
```

`parseCodeNode` should look pretty familiar; we are setting up this function to build a component return.  We have also created an object `passthroughProps` to hold our parsed data.  Then, using the spread operator, easily pass the prepared data through to our final rendered component.  We're using a simplified `CodeBlock` component as a placeholder for now so that when we render this content, we can easily see the props passed through with our use of JSON.stringify.  This component stub for `CodeBlock` is a temporary placeholder until we implement the real deal.

Let's take another step forward.

``` javascript(/reactive-client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

+ export const parseBlockOpen = (first_line) => {
+   if(fenceLine(first_line)){
+     return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
+   } else{
+     return [undefined,undefined];
+   }
+ };

export const fenceLine = (line) => {
+   return line.match(/^```/);
};

const parseCodeNode = (node) => {
  let all_lines = node.content.split("\n");
+   let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
  let passthroughProps = {
    node_id: node.id,
    block_type: block_type,
    block_path: block_path
  };
  
-   return class extends Component {
-     render(){
-       return <CodeBlock { ...passthroughProps } />;
-     }
-   };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>{ JSON.stringify(this.props) }</div>;
-   }
- }
```

We begin at `parseBlockOpen ` which parses the header row of our code block.  We are using a type of assignment we have not demoed before to assign `[block_type, block_path]` from the return of a single function.  This assignment operation expects an array value returned from our function and instantiates two variables for us; `block_type` from the first index of the array, and `block_path` from the second. 

We're beginning with a simplified Regex test, to ensure the first line of the block is a code fence; expecting the line to open with three backtick characters.  We have split this simple test off as a function so we can reuse it later, and to make our code easier to read.  If the first line is a fence, we execute our more complicated tests, if not we return `undefined` for our block's language type and file path.

In instances where the first line of our content **is** a fence opening, we are using a Regular expression to pull out the information we need.  The `String.replace` function allows us to pull back specific fragments of our regex evaluation.  Each set of parentheses in the regular expression forms what is called a match group.  The second parameter of the replace function allows us to access these matches using the `$#` shorthand.  In this case, we are interested in `$2`, and `$4`; the language type, and file path respectively.

I am not going to run you through the details of this regular expression, but if it is over your head and you would like to dig into it, I have set up [an example at Regex101.com](https://regex101.com/r/t9Okoc/1/) that to help you work through it.

Finally, we use the `split(",")` operator to assemble the two returns we need into an array for our function's return value.

We have added these two values to our passthrough props object as well since we want them available in our rendered component.

Our HOC is already getting complex, so let's add a wave of tests before we move forward.  

``` javascript(/reactive-client/src/components/nodes/parse_code_node.spec.js)
/* global expect*/
import * as unit from './parse_code_node';

describe("fenceLine()",()=>{
  describe("returns true only if code fence",()=>{
    expect(unit.fenceLine("```")).toBeTruthy();
    expect(unit.fenceLine("``` ")).toBeTruthy();
    expect(unit.fenceLine("* ")).toBeFalsy();
  });
});

describe("parseBlockOpen",()=>{
  let examples = [
    {test: "```", outcome: ["",""]},
    {test: "``` ", outcome: ["",""]},
    {test: "```javascript", outcome: ["javascript",""]},
    {test: "``` javascript", outcome: ["javascript",""]},
    {test: "```javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]},
    {test: "``` javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]}
  ];
  
  examples.forEach((example => {
    test("test value provide outcome",()=>{
      expect(unit.parseBlockOpen(example.test)).toEqual(example.outcome);
    });
  }));  
});
```

Here a `forEach` loop is used to test some expected and unexpected outcomes for our regular expression evaluation to ensure we are getting the behavior we need from our functions.  We have imported all exportables from our `parse_code_node.js` file under the namespace `unit` so we can run unit tests against individual areas of the imported module.

Now we need to tackle the parsing of our large code blocks into sections of priority.  I am going to assemble an object for each section, and store its content and priority level.  We also need a unique key value to use when we print these sections to the screen.  Before we start cutting up content though, we need to isolate lines of code from our larger Markdown syntax.

``` javascript(/reactive-client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

- export const parseBlockOpen = (first_line) => {
-   if(fenceLine(first_line)){
-     return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
-   } else{
-     return [undefined,undefined];
-   }
- };

+ export const fenceLine = (line) => {
+   return line.match(/^```/);
+ };

+ export const getContentLines = (lines) => {
+   return fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
+ };

const parseCodeNode = (node) => {
  let all_lines = node.content.split("\n");
+   let content_lines = getContentLines(all_lines);
  let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
-   let passthroughProps = {
-     node_id: node.id,
-     block_type: block_type,
-     block_path: block_path,
-   };
  
-   return class extends Component {
-     render(){
-       return <CodeBlock { ...passthroughProps } />;
-     }
-   };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>{ JSON.stringify(this.props) }</div>;
-   }
- }
```

Above we are using a regular expression to perform a final check that the content parsed matches the Markdown code fence syntax's triple backtick pattern.  If so, we can remove the first and last lines from the array of content lines using `Array.slice()`.  Otherwise, the function returns an unaltered array.  Now we have an isolated set of code lines we can use.

Next, we tackle sorting code lines into sections, and marking their priority to the overall example.

``` javascript(/reactive-client/src/components/nodes/parse_code_node.js)
import React, { Component } from 'react';

- export const parseBlockOpen = (first_line) => {
-   if(fenceLine(first_line)){
-     return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
-   } else{
-     return [undefined,undefined];
-   }
- };

- export const fenceLine = (line) => {
-   return line.match(/^```/);
- };

- export const getContentLines = (lines) => {
-   return fenceLine(lines[0]) ? lines.slice(1,lines.length - 2) : lines;
- };

export const divideSections = (block_contents) => {
  let remaining_lines = block_contents;
  let block_sections = [];
  let working_section;
  
+   while(remaining_lines.length !== 0){
+     let line = remaining_lines.shift();
+     let clean_line = filterFlag(line);
+     
+     if(!working_section){
+       working_section = { priority: getSectionPriority(line) };
+       working_section.content = [clean_line];
+     } else{
+       if(line[0] && line[0].match(flagMap[working_section.priority])) {
+         working_section.content.push(clean_line);
+       } else{
+         remaining_lines.unshift(line);
+         block_sections.push(working_section);
+         working_section = null;
+       }
+     }
+   }
  
  if(working_section){ block_sections.push(working_section) }
  return block_sections;
}

export const filterFlag = (line) => {
  return line.replace(/^([+-]\s)?(.*)$/,"$2");
}

export const flagMap = {
  high: /\+[ ]/,
  low: /-[ ]/,
  normal: /[^+-]/
};

export const getSectionPriority = (line) => {
  switch(line[0]){
    case("+"):
      return "high";
    case("-"):
      return "low";
    default:
      return "normal";
  }
}

const parseCodeNode = (node) => {
  let all_lines = node.content.split("\n");
  let content_lines = getContentLines(all_lines);
  let [block_type,block_path] = parseBlockOpen(all_lines[0]);
  
  let passthroughProps = {
    node_id: node.id,
    block_type: block_type,
    block_path: block_path,
+     block_sections: divideSections(content_lines)
  };
  
-   return class extends Component {
-     render(){
-       return <CodeBlock { ...passthroughProps } />;
-     }
-   };
};

export default parseCodeNode;

- class CodeBlock extends Component {
-   render(){
-     return <div>HEY LISTEN! { JSON.stringify(this.props) }</div>;
-   }
- }
```

The bulk of our logic lives in `divideSections`, where we take the total collection of lines and set up a let variable `remaining_lines` to hold content not yet processed.  

A while loop will persist as long as `remaining_lines` has more content to provide.  When we enter this while loop, we check if a `working_section` is already defined.  When `working_section` is undefined, and the loop reads in a new line, a new `working_session` instantiates.  The priority of the first line in each working_section sets the precedence for lines that follow.

As we read subsequent lines of code, we check if the priority of each line matches the current working section.  If so, the additional line is cleaned, appended to our array, and the loop continues.

If the incoming line's priority flag changes from that of the current working section, we close the current `working_section` by appending it to the array `block_sections` and then resetting `working_section` to `null`.  The current line of our loop is unshifted back into our array of remaining lines so that when the loop runs its next iteration, we re-evaluate this line as the start of a new `working_section`.

When the loop ends, we append the final `workin_section` and return our array of sections.

Just one small problem.  This code is an unholy mess.  We have wholly exceeded the scope of a single function.  However, sometimes I have to write the wrong code to get down to the right code.  Now that we have a working demonstration of what we need our parsers to do, we can refactor to something better.

## Working with Classes

In my opinion, we have exceeded the amount of heavy lifting a single function should be doing.  In fact, despite splitting many of our small utility functions off into exportables, we have still got too much happening in a single HOC.  Aside from how intimidating this all is to read, the fact that I have no idea how to approach testing our section dividing code cues me in that I need to more appropriately separate work.

We are going to look at using ES2015 classes in a way we have not before.  We have been using the class syntax extensively as we have created React components.  However, there's nothing to stop us from setting up other classes that are not components so that we can more logically divide work.

When I think about what we are doing here with our current unwieldy `parseCodeNode` function, we are working with three levels of content: the code block itself, sections of our example, and individual lines.

Let's try reworking our `parseCodeNodes` function to be better in tune with these taxonomical divisions in our work.

First, let us split out the details of our parsing work that pertain to the code fence itself.  I want to identify the language used in the block, the path to the file in our application, the fence's ID in our overall node map, and its contents.

``` javascript(/reactive-client/src/components/nodes/lib/code_fence.js)
class CodeFence {
  constructor(node){
    let all_lines = node.content.split("\n");
    
    this.node_id = node.id;
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
    this.content_lines = CodeFence.getContentLines(all_lines);
  }
  
  static fenceLine = (line) => {
    return line.match(/^```/);
  };
  
  static parseFenceOpen = (first_line) => {
    if(CodeFence.fenceLine(first_line)){
      return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
    } else{
      return [undefined,undefined];
    }
  };
  
  static getContentLines = (lines) => {
    return CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
  };
}

export default CodeFence;
```

Here we have set up a CodeFence class to manage the essential attributes of each fence for us.  Inside the class' constructor, we are assigning the specific items we need to capture as instance attributes of the class.  These instance attributes are readily accessible to us inside of our components by using dot notation off a specific instance of the class.

We have not changed the logic since we saw these same function inside the `parseCodeNode` function created in previous examples.

For now, focus on the how the class syntax differs from using a function or HOC to manage this same work.

You may notice we have also translated many of our standalone exportable functions into static methods of the class.  Using static methods this way allows us to preserve the test setup we already have, needing only some minor adjustments.

``` javascript(/reactive-client/src/components/nodes/lib/code_fence.spec.js)
/* global expect*/
import CodeFence from './code_fence';

describe("ParseCodeBlock.fenceLine()",()=>{
  describe("returns true only if code fence",()=>{
    expect(CodeFence.fenceLine("```")).toBeTruthy();
    expect(CodeFence.fenceLine("``` ")).toBeTruthy();
    expect(CodeFence.fenceLine("* ")).toBeFalsy();
  });
});

describe("ParseCodeBlock.parseFenceOpen()",()=>{
-   let examples = [
-     {test: "```", outcome: ["",""]},
-     {test: "``` ", outcome: ["",""]},
-     {test: "```javascript", outcome: ["javascript",""]},
-     {test: "``` javascript", outcome: ["javascript",""]},
-     {test: "```javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]},
-     {test: "``` javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]}
-   ];
  
  examples.forEach((example => {
    test("test value provide outcome",()=>{
      expect(CodeFence.parseFenceOpen(example.test)).toEqual(example.outcome);
    });
  }));
});

+ describe("CodeFence.getContentLines()",() =>{
+   test("removes open and close fence",()=>{
+     let test_value = ["```","test value","```"];
+     expect(CodeFence.getContentLines(test_value)).toEqual(["test value"]);
+   });
+ });
```

Instead of using the `import *` syntax to bring in all our methods under test we instead import the `CodeFence` class as a whole.  We've also defined a new test group for our `CodeFence.getContentLines` static method.

Anytime I spot an opportunities to set up units of work in static methods like this I tend to seize them.  Static methods, by their nature, lend themselves to being pure functions.  Since they are uninfluenced by values unique to the specific instance of the class, they are extremely easy to test.  If you provide a static method with the same input, you should get an easily repeatable output.

Now, let's set up a new file with a `CodeBlock` component that leverages this new class.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';

class CodeBlock extends Component {
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
  }
  
  render(){
    return(
      <div key={"code_block_" + this.code_fence.node_id} id={"code_block_" + this.code_fence.node_id}
      className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? <div>{ this.code_fence.block_path }</div> : null }
        <div>
          { JSON.stringify(this.code_fence.content_lines) }
        </div>
      </div>
    )
  }
}

export default CodeBlock;
```

Each component we render instantiates a new instance of our `CodeFence` class, passing the node from our component's properties into the CodeFence class' constructor.  We can then use this instance to return the items we need to populate the outer wrapper of our code block, filling in the ID, file path, and rough contents.

Finally, let's update our `NodesList` component to leverage this special `CodeBlock` component where relevant.

```javascipt(/reactive-client/src/components/nodes_list.js)
import React, { Component } from 'react';
import MarkdownIt from 'markdown-it';
import CodeBlock from './nodes/code_block';

const md = new MarkdownIt();

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
+       switch (node.node_type) {
+         case("code_block"):
+           return nodes_list.push(<CodeBlock key={"node_" + node.id} node={node} />);
+         default:
+           return nodes_list.push(<p key={"node_" + node.id} dangerouslySetInnerHTML={{__html: md.render(node.content)}} />);
+       }
    });
    return nodes_list;
  }
  
-   render() {
-     return (
-       <div id="nodes_list">
-         { this.renderNodes(this.props.nodes) }
-       </div>
-     );
-   }
}

export default NodesList;
```

Check your updated application rendering, and you should now have a very rough view of the overall `CodeBlock` available.

![Early Rendering of New Code Fence](/images/9/EarlyFenceRendering.png)

Now we need to tackle individual sections of code.  My initial thoughts on this are to translate the concept of a `working_section` from our first iteration into a standalone class.  The class should have an interface that allows me to take code line by line and extend the section.  As we pass in lines, the section class should watch for flag changes, and signal the section is complete when we notice a change.  

Let's see if we can set that much up without overthinking how we are going to manage the loop of lines.  It is still not clear to me whether we have enough logic to capture about each line of code to know if I need a dedicated class for lines yet.  The best way to decide is to see how the sections class looks without it.

``` javascipt(/reactive-client/src/components/nodes/lib/code_section.js)
class CodeSection {
  constructor(first_line, node_id, section_id){
    this.contents = [];
    this.section_id = "node_" + node_id + "_section_" + section_id;
    this.priority = CodeSection.checkPriority(first_line);
  }
  
  static checkPriority(line) {
    let flag = line[0];
    let flagMap = { "+": "high", "-": "low"};
    
    return flagMap[flag] ? flagMap[flag] : "normal";
  }
}

export default CodeSection;
```

We start with our constructor; setting up an array to contain the contents of the section.  We are also developing a unique ID for each section, so we have a key value available when React renders this content.  Our constructor expects a node and section ID when instantiating a new instance of this class to construct this unique key.

The final value set up by our constructor is the block's priority.  The first line of code fed to a new section determines its priority level.  We use this value to determine our behavior on future incoming lines.

``` javascipt(/reactive-client/src/components/nodes/lib/code_section.js)
class CodeSection {
-   constructor(first_line, node_id, section_id){
-     this.contents = [];
-     this.section_id = "node_" + node_id + "_section_" + section_id;
-     this.priority = CodeSection.checkPriority(first_line);
-   }
  
  get completed() {
    return {
      section_id: this.section_id,
      priority: this.priority,
      contents: this.contents
    };
  }
  
+   continues = (line) => {
+     return this.priority === CodeSection.checkPriority(line);
+   }

+   appendLine = (line) => {
+     this.contents.push(
+       CodeSection.cleanLine(line)
+     );
+   }
  
    
  static preserveLineBreaks(contents){
    return Array.from(contents, c => c === "" ? " " : c);
  }
  
  static cleanLine(raw_line) {
    return raw_line.replace(/^([+-]\s)?(.*)$/,"$2");
  }
  
-   static checkPriority(line) {
-     let flag = line[0];
-     let flagMap = { "+": "high", "-": "low"};
-     
-     return flagMap[flag] ? flagMap[flag] : "normal";
-   }
}

export default CodeSection;
```

The example above creates two more interfaces for this class; `continues` and `appendLine`.  The `continues` method accepts an incoming line and checks if its flag matches the priority set for the section.  If this next incoming line matches the priority of the section, `continues` returns true.

Our `appendLine` method gives us an interface to extend the `contents` attribute of the section.  Each time we pass in a line, it strips off the priority flag and appends the line to the section contents.

The final items of note is a getter method `complete` which we have defined for the class.  `complete` returns a simplified object representation of the section's id, content, and priority.  This function also leverages a small helper method `preserveLineBreaks` to ensure any blank lines are updated to store a string with at least one space. Changing from an empty string to a single whitespace character prevents `<pre>` tags from collapsing repeated lines of whitespace when examples render.

Before we move on, I would suggest we write some tests for this Class.

``` javascript(/reactive-client/src/components/nodes/lib/code_section.spec.js)
/* global expect */
import CodeSection from './code_section';

const test_lines = [
  { test: "+ ", priority: "high" },
  { test: "some code", priority: "normal" },
  { test: "- ", priority: "low" },
  { test: "", priority: "normal" },
];

describe("CodeSection.checkPriority()", ()=>{
  test_lines.forEach((run) =>{
    test("returns flag prioity", ()=>{
      expect(CodeSection.checkPriority(run.test)).toEqual(run.priority);
    });
  });
});

describe("CodeSection.cleanLine()", ()=>{
    test("removes priority flags from line", ()=>{
      expect(CodeSection.cleanLine("+ test")).toEqual("test");
      expect(CodeSection.cleanLine("- test")).toEqual("test");
      expect(CodeSection.cleanLine(" test")).toEqual(" test");
    });
});
```

Now let's upgrade `CodeFence` to utilize our sections class.

``` javascript(/reactive-client/src/components/nodes/lib/code_fence.js)
import CodeSection from './code_section';

class CodeFence {
  constructor(node){
    let all_lines = node.content.split("\n");
    let content_lines = CodeFence.getContentLines(all_lines);
    
    this.node_id = node.id;
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
+     this.sections = this.parseSections(content_lines);
  }
  
  parseSections = (remaining_lines) => {
    let current_section, sections = [];
    
    while(remaining_lines.length > 0){
      current_section = current_section || new CodeSection(remaining_lines[0], this.node_id, sections.length);
      if(current_section.continues(remaining_lines[0])){
        current_section.appendLine(remaining_lines.shift());
        if(remaining_lines.length === 0) { sections.push(current_section.completed) }
      } else {
        sections.push(current_section.completed);
        current_section = null;
      }
    }
    
    return sections;
  }
  
-   static fenceLine = (line) => {
-     return line.match(/^```/);
-   };
  
-   static parseFenceOpen = (first_line) => {
-     if(CodeFence.fenceLine(first_line)){
-       return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
-     } else{
-       return [undefined,undefined];
-     }
-   };
  
-   static getContentLines = (lines) => {
-     return CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
-   };
}

export default CodeFence;
```

We have added a `sections` attribute to the `CodeFence` constructor function.  A new function `parseSections` builds out an array of sections into this placeholder.  

The logic inside `parseSections` is still somewhat complex, but I find the function much more readable now that we can leverage named methods supplied by our `CodeSection` class to check the state of each section.  This step towards readability outperforms the randomly interspersed logical tests, and placeholder variables we used in the original implementation.

The basic premise of the method is unchanged.  Passed all our lines of content, we set up an empty array `sections` where we store our parsed code sections.  While we have lines remaining; we instantiate a new `CodeSection` if one does not already exist, and pass it our current first line.  As a `CodeSection` instantiates, that same line of code extends that section's content array.  Each additional passed line repeats this test; taking the next line, using `continues()` to check for flag changes, and then shifting the top line off our remaining_lines and appending it to the section's content before repeating the loop.

When a flag change is detected and `continues` returns false, we append the completed section to our `sections` array using the `completed` getter method we set up to fetch the simplified section object.

Once we reach our last line, we append the final section to our `sections` array and return that complete list of sections.

Now we can check our work by doing a quick update to our `CodeBlock` component.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
  render(){
    return(
      <div key={"code_block_" + this.code_fence.node_id} id={"code_block_" + this.code_fence.node_id}
      className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? <div>{ this.code_fence.block_path }</div> : null }
        <div>
+           { JSON.stringify(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

![Code Fence with Divided Sections](/images/9/CodeFenceWithSections.png)

We are almost ready to start fleshing out an actual UI for our new `CodeBlock` component.  Before we move on though, I think we should add an integration test to cover the entire setup of a `CodeFence` and its sections.

``` javascript(/reactive-client/src/components/nodes/lib/code_fence.spec.js)
/* global expect*/
import CodeFence from './code_fence';

const test_node = {
  id: 78,
  chapter_id: 2,
  node_type: 'code_block',
  content: '``` javascript(/reactive-client/src/App.js)\n+ console.log("high")\n- console.log("low")\nconsole.log("normal")\n```'
};

describe("CodeFence Integration Tests",()=>{
  let code_block = new CodeFence(test_node);
  test("parses code sections",()=>{
    expect(code_block.sections.length).toEqual(3);
    expect(code_block.sections[0].priority).toEqual("high");
    expect(code_block.sections[1].priority).toEqual("low");
    expect(code_block.sections[2].priority).toEqual("normal");
  });
  
  test("parses code type",()=>{
    expect(code_block.block_type).toEqual("javascript");
  });
  
  test("parses code path",()=>{
    expect(code_block.block_path).toEqual("/reactive-client/src/App.js");
  });
  
  test("assigns each section an ID",()=>{
    expect(code_block.sections[0].section_id).toEqual("node_78_section_0");
  });
});

- describe("ParseCodeBlock.fenceLine()",()=>{
-   test("returns true only if code fence",()=>{
-     expect(CodeFence.fenceLine("```")).toBeTruthy();
-     expect(CodeFence.fenceLine("``` ")).toBeTruthy();
-     expect(CodeFence.fenceLine("* ")).toBeFalsy();
-   });
- });

- describe("ParseCodeBlock.parseFenceOpen()",()=>{
-   let examples = [
-     {test: "```", outcome: ["",""]},
-     {test: "``` ", outcome: ["",""]},
-     {test: "```javascript", outcome: ["javascript",""]},
-     {test: "``` javascript", outcome: ["javascript",""]},
-     {test: "```javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]},
-     {test: "``` javascript(path/to/file.ext)", outcome: ["javascript","path/to/file.ext"]}
-   ];
-   
-   examples.forEach((example => {
-     test("test value provide outcome",()=>{
-       expect(CodeFence.parseFenceOpen(example.test)).toEqual(example.outcome);
-     });
-   }));
- });

- describe("ParseCodeBlock.getContentLines()",() =>{
-   test("removes open and close fence",()=>{
-     let test_value = ["```","test value","```"];
-     expect(CodeFence.getContentLines(test_value)).toEqual(["test value"]);
-   });
- });
```

Here I am not overly concerned with any of the internal workings of the `CodeFence` class, or the `CodeSection` class.  Instead, we instantiate a new instance of our class with an example node representing a code block.  Then we check that our test value correctly provides all the outputs we rely on; IDs, sections, file paths, and language types.  Between this and our unit tests, we have pretty good coverage over what's happening with this code.

Now, with the heavier lifting behind us, let's start addressing our UI.

## Styling our Enhanced CodeBlocks

Let's start with some updates to our top level `CodeBlock` component.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

const codeBlockStyle = {
  marginBottom: "16px"
};

const blockHeaderStyles = {
  borderBottom: "3px double #021a40",
  backgroundColor: "#021a40",
  color: "#fff",
  padding: "5px 10px 5px 20px",
  textOverflow: "ellipsis"
};

const blockBodyStyle = {
  padding: "10px 0",
  border: "1px solid #021a40",
  backgroundColor: "#f8f8f8",
  overflowX: "scroll"
};

class CodeBlock extends Component {
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
  }
  
  renderCodeSections = (sections) => {
    return Array.from(sections, s => {
      return(
        <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
        contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? 
        <div style={blockHeaderStyles}>{ this.code_fence.block_path }</div> : null 
        }
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

There is nothing in this example that we have not seen before.  We are adding some style objects to our top-level `CodeBlock` container.  We are also setting up a `renderCodeSections` method that handles printing out our sections of code using a `CodeSection` component we have not yet defined.  Inside `renderCodeSections` is our first use of `Array.from()` from the ES2015 syntax.  `Array.from` allows us to iterate through a collection and construct a new array from its contents.  It saves us needing to instantiate an empty array at the beginning of our method to populate and manually calling return.  Instead `Array.from` will itself return a fully constructed array when the method finishes.

## Components with Independent State

Now let's go ahead and define our `CodeSection` component. Before we do though, we are going to install a library to manage our syntax highlighting in code examples; HighlightJS.  The HighlightJS library can post-process our code blocks using language class names we provide to markup the rendered source code with colors and text styles.  This styling makes our examples easier to read than plain monochromatic text.

To install HighlightJS we need to update our `index.hmtl` file at the root of our application with a link to HighlightJS' Javascript.  We need to also supply a link to a CSS theme for the highlighter to use.  Both are available off the Cloudflare CDN.  If you would like to ensure you are using the latest version of HighlightJS, check the installation instructions on the [HighlightJS website](https://highlightjs.org/download/) for updated CDN links, or use the example links provided below.

Note, I am also taking this opportunity to install the [Font Awesome Icon Libray](http://fontawesome.io/icons/), which I plan to use with my new components as well.

``` html(/reactive-client/public/index.html)
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta name="theme-color" content="#000000">
-     <!--
-       manifest.json provides metadata used when your web app is added to the
-       homescreen on Android. See 
-       https://developers.google.com/web/fundamentals/engage-and-retain/web-app-manifest/
-     -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css"></link>
    <link rel="shortcut icon" href="%PUBLIC_URL%/favicon.ico">
+     <script src="https://use.fontawesome.com/4dddb60c9c.js"></script>
+     <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
+     <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
-     <!--
-       Notice the use of %PUBLIC_URL% in the tags above.
-       It will be replaced with the URL of the `public` folder during the build.
-       Only files inside the `public` folder can be referenced from the HTML.
- 
-       Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
-       work correctly both with client-side routing and a non-root public URL.
-       Learn how to configure a non-root public URL by running `npm run build`.
-     -->
    <title>React App</title>
  </head>
-   <body>
-     <noscript>
-       You need to enable JavaScript to run this app.
-     </noscript>
-     <div id="root"></div>
-     <!--
-       This HTML file is a template.
-       If you open it directly in the browser, you will see an empty page.
- 
-       You can add webfonts, meta tags, or analytics to this file.
-       The build step will place the bundled scripts into the <body> tag.
- 
-       To begin the development, run `npm start` or `yarn start`.
-       To create a production bundle, use `npm run build` or `yarn build`.
-     -->
-   </body>
</html>

```

Now that we have HighlightJS available let's set up our CodeSection Component.

``` javascript(/reactive-client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

- const codeSectionStyle = {
-   display: "table-row",
-   padding: "0 5px",
-   lineHeight: "100%"
- };

- const codeGutterStyle = {
-   display: "table-cell",
-   padding: "0 5px"
- };

- const codeBodyStyle = {
-   margin: 0,
-   display: "table-cell",
-   width: "100%",
-   paddingRight: "10px",
- };

class CodeSection extends Component {
  constructor(props){
    super(props);
+     if(props.priority === "low"){
+       this.minimizedContent = props.contents[0];
+       this.state = {collapsed: true};
+     } else { this.state = {collapsed: false} }
  }

  renderSectionContent = () => {
    let p = this.props;
    return this.state.collapsed ? <CodeCollapsed {...p} /> : <CodeFull {...p} />;
  }
  
  toggleCollapse = (e) => {
    if(this.props.priority === "low"){
      this.setState({collapsed: !this.state.collapsed});
    }
  };
  
  render() {
    let priority = this.props.priority;
    let icon = this.state.collapsed ? "plus" : "minus"; 
    
    return (
      <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={codeSectionStyle}>
        <div className="codeGutter" style={codeGutterStyle}>
          <i className={"fa fa-"+ icon +"-square-o"}></i>
        </div>
        <div className="codeBody" style={codeBodyStyle} id={this.props.section_id}>
          { this.renderSectionContent() }
        </div>
      </div>
    );
  }
}

export default CodeSection;
```


We are going to look at this entire component at once to help you get used to reading full components in a single pass if you are not already.  I have minimized some style attributes to help us focus on the behavior of the component over its look and feel.

The first thing we should look at is our component's constructor, where we see this component is maintaining its a state disconnected from our Redux store.  The props passed to this component dictate the initial state of our component.  

It is important to remember that while both `props` and `state` inside our component dictate how our components render and behave, a component should never mutate its props.  The props of a component should always be passed down from the rendering parent component.

The component's state, however, is mutatable as we need.  In this `CodeSection` component we're using a `state.collapsed` value to dictate whether our low priority components render the full text of their section or an abbreviated form.  `CodeSections` instantiated with a `normal` or `high` priority set in their props default uncollapsed, and in fact are not collapsible at all.  A low prioirty section defaults to collapsed.

We are using an `onClick` event handler in our component to toggle the collapsed state using the `setState` function.  When the component's state changes, it updates and renders either the `CollapsedSection` or `FullSection` component.  An icon for an open/close button renders in the left-hand margin of our example as well to show the current state of the component to our users.

Now let's look at those `CollapsedSection` and `FullSection` components.

``` javascript(/reactive-client/src/components/nodes/code_full.js)
/* global hljs */
import React, { Component } from 'react';

class CodeFull extends Component {
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_full"));
  }
  
  render() {
    return (
      <code id={this.props.section_id+"_full"}>
        <pre className={this.props.block_type}>{this.props.contents.join("\n")}</pre>
      </code>
    );
  }
}

export default CodeFull;
```

Our `FullCode` component is the more straightforward of the two, so let's start there.  The component renders the entire contents of the section using `<code>` and `<pre>` markup tags to ensure the whitespace in our examples preserves our indentation.  We are also supplying the language used in the block inside the `className` attribute of our `<pre>` tag so that HighlightJS knows what syntax it is marking up.

Then inside a component lifecycle method `componentDidMount()` where are invoke HighlightJS to markup our contents.  By default HighlightJS would search our markup after the onload event fires on our site using the suggested `hljs.initHighlightingOnLoad();` 

However, we need to be more controlled when using HighlightJS with React.  React can become unpredictable when you modify the document object model (DOM) outside of React's normal render cycles.  If the document tree mutates, it can break react's ability to update when the state of our application changes.  Because of this, I had to push HighlightJS down to my lowest level component and ensure the content HighlightJS operates on was static.

By static content; I mean that either our components render, or they do not.  Once `FullSection` or `CollapsedSection` components are rendered, React cannot modify them.  Our parent component, however, can still collapse and expand the content of this section by re-rendering to exchange the collapsed component for the full, or vice versa.  This isolation of our section contents gives HighlightJS a safe space to operate and make DOM modifications.

When a user click triggers the collapse or expansion of a section, React unmounts the current code rendering, and mounts the new.  Then we alert HighlightJS to markup the syntax again once the new representation of the section content has mounted.

Let's look at our `CollapsedSection` component now.

``` javascript(/reactive-client/src/components/nodes/code_collapsed.js)
/* global hljs */
import React, { Component } from 'react';

class CodeCollapsed extends Component {
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_collapsed"));
  }
  
  render() {
    let contents = this.props.contents;
    return (
      <code id={this.props.section_id+"_collapsed"}>
        <pre className={this.props.block_type}>
          <div>
            {contents[0]} 
            <i className="fa fa-arrows-h" aria-hidden="true"></i>
            {contents[contents.length-1].trim()}
            </div>
        </pre>
      </code>
    );
  }
}

export default CodeCollapsed;
```

Here we are using the same strategy for HighlightJS.  Our component body, however, does a bit of parsing to ensure we render abbreviated content for the section.  We take the first and last line of our content, and renderer an arrow icon to denote that the content can expand.

Finally, I want to make a few updates to our App.css file.

``` css(/reactive-client/src/App.css)
img {max-width: 100%;}

#reader-pane img {border: 1px solid #021a40;}

+ code {
+   background-color: rgba(27,31,35,0.05);
+   border-radius: 3px;
+   padding: 0.2em .5em;
+   margin: 0;
+   font-size: 85%;
+ }
+ 
+ .codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
+ .codeGutter .fa { font-size: 12px; opacity: 0; }
+ .lowPrioritySection .fa { opacity: 100; }
+ .lowPrioritySection { cursor: pointer; } 
+ .highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }

pre {white-space: pre-wrap; margin: 0;}

#root .hljs {padding: 0;}

- #reader-pane {
-   margin-top: 85px;
- }

- @media only screen and (max-width: 990px) {
-   #app .banner {
-     margin-left: -10px;
-   }
- }

- @media only screen and (max-width: 767px) {
-  #app #reader-pane {
-    margin-top: 125px;
-  }
- }
```

In my opinion, this is one weakness of styling components in your Javascript rather than a CSS file.  Inevitably I encounter at least one package I am using in my application that makes changes to the rendered source code in ways I cannot entirely control.  In this case, I found to get the look and feel I wanted out of HighlightJS I needed to override some of its styles.  Tools that produce HTML markup lead me to a mix where some of my styles live in the components I have written, and some live in my stylesheets.  Not a state I am fond of, but it is sometimes our best option to get the job done.

Let's take a look at our updated code examples.

![Code Section with Styling](/images/9/StyledCodeSections.png)

We have a few more convenience items to add before we are done.

## Child Components with Refs

We said at the opening of this chapter that our examples should be easily copied to the clipboard so that readers following along do not need to struggle cleaning up markup everytime they want to pull example code from our book.

However, we have complicated this a bit with our support for minimizing blocks of our example code.  To get all content on the clipboard right now, you need to expand all the sections first, so nothing is overlooked when you highlight/copy the code.  Having to go through and click all our collapsed sections open first to copy code is not ideal.  Let's add some support for a one-click copy function to each example.

While we are at it, let's also create a parent level expand/minimize button for each `CodeBlock` component, to fully expand or shrink all our example's sections in a single click.

To begin, let's prep our UI by adding three buttons to the header of each example: copy, collapse, and expand.  Some semantic UI components can help us quickly setup the interface.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
+ import { Popup, Button, Icon } from 'semantic-ui-react'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     return Array.from(sections, s => {
-       return(
-         <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
+         { this.code_fence.block_path ? 
+           <div style={blockHeaderStyles}>
+             { this.code_fence.block_path }
+             <Popup
+               trigger={<Button icon size="mini" floated="right" color="grey"><Icon name='plus' /></Button>}
+               position="bottom center" content='Expand All'
+             />
+             <Popup
+               trigger={<Button icon size="mini" floated="right" color="grey"><Icon name='minus' /></Button>}
+               position="bottom center" content='Collapse All'
+             />
+             <Popup
+               trigger={<Button icon size="mini" floated="right" color="grey"><Icon name='copy' /></Button>}
+               position="bottom center" content='Copy All'
+             />
+           </div> 
+           : null 
+         }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

Now we can start wiring in this functionality.

### Copying Examples to the Clipboard

Our copy functionality is the simplest of these tools to engineer, as we are going to lean on an NPM package [Clipboard.js](https://clipboardjs.com/) to do much of our heavy lifting. 

To install, run `npm install clipboard --save` in your client directory.

Then we can update our `CodeBlock` component to make use of this module.  We have already got an easy path to access the raw string of the code example in our components props.  We just need to make some small modifications to our `CodeFence` class to ready this data for our component.

``` javascript(/reactive-client/src/components/nodes/lib/code_fence.js)
import CodeSection from './code_section';

class CodeFence {
  constructor(node){
    let all_lines = node.content.trim().split("\n");
    
    this.node_id = node.id;
+     this.content_lines = CodeFence.getContentLines(all_lines);
    [this.block_type, this.block_path] = CodeFence.parseFenceOpen(all_lines[0]);
+     this.sections = this.parseSections([...this.content_lines]);
  }
  
+   get copy(){
+     return Array.from(this.content_lines, (line) =>{
+       return CodeSection.cleanLine(line);
+     }).join("\n");
+   }
  
-   parseSections = (remaining_lines) => {
-     let current_section, sections = [];
-     
-     while(remaining_lines.length > 0){
-       current_section = current_section || new CodeSection(remaining_lines[0], this.node_id, sections.length);
-       if(current_section.continues(remaining_lines[0])){
-         current_section.appendLine(remaining_lines.shift());
-         if(remaining_lines.length === 0) { sections.push(current_section.completed) }
-       } else {
-         sections.push(current_section.completed);
-         current_section = null;
-       }
-     }
- 
-     return sections;
-   }
  
-   static fenceLine = (line) => {
-     return line.match(/^```/);
-   };
  
-   static parseFenceOpen = (first_line) => {
-     if(CodeFence.fenceLine(first_line)){
-       return first_line.replace(/^(```\s?)([^()]*)?(\((.*)\))?\s*$/,["$2","$4"]).split(",");
-     } else{
-       return [undefined,undefined];
-     }
-   };
  
-   static getContentLines = (lines) => {
-     return CodeFence.fenceLine(lines[0]) ? lines.slice(1,lines.length - 1) : lines;
-   };
}

export default CodeFence;
```

First, we are modifying our `content_lines` variable to be set up as an instance property, so it is easily accessible from outside the class constructor.  Then our call to `parseSections` needs to be updated as well.  We're using a destructive `Array.shift()` method inside the `parseSections` class, so if we continue to pass in our `content_lines` variable reference, our parsing of the sections leaves us with an empty array in `content_lines` when its work is complete.

To avoid this, we could rewrite the `parseSections` function to use non-destructive methods to parse the array of content lines.  Alternatively, we change how we invoke this function, so it does not receive a reference to the array we want to preserve.  I have opted for the later, using the spread operator and array literal syntax to create a new instance of our content lines array when we invoke the `parseSections` function.

Finally, we set up a new getter method called `copy` to give us a clear interface to use when we want to retrieve our clipboard content for each example.   Using `Array.from` to build a new array from our `content_lines`, we pass each line through our `CodeSection.cleanLine()` method to remove the priority flags we do not want in our final text.  Then we join the members of the array with line breaks before returning to get a complete string of our example.

Now we can update our code block component to leverage this data.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react'
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     return Array.from(sections, s => {
-       return(
-         <CodeSection block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
+   componentDidMount(){
+     let button = this.triggerCopy.querySelector("button");
+     return new clipboardJS(button, {
+       text: () => this.code_fence.copy
+     });
+   }
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? 
          <div style={blockHeaderStyles}>
            { this.code_fence.block_path }
-             <Popup
-               trigger={<Button icon size="mini" floated="right" color="grey"><Icon name='plus' /></Button>}
-               position="bottom center" content='Expand All'
-             />
-             <Popup
-               trigger={<Button icon size="mini" floated="right" color="grey"><Icon name='minus' /></Button>}
-               position="bottom center" content='Collapse All'
-             />
+             <span ref={ref => this.triggerCopy = ref}>
+               <Popup
+                 trigger={
+                   <Button icon size="mini" floated="right" color="grey">
+                     <Icon name='copy' />
+                   </Button>
+                 }
+                 position="bottom center" content='Copy All'
+               />
+             </span>
          </div> 
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

The way `ClipboardJS` is set up causes us a small problem.  When we set up a button to copy items to the clipboard, we are actually registering an event handler to the DOM selector passed to `new ClipboardJS()`.  This approach means that we cannot tie a function directly to an `onClick` handler for our copy button to populate the user's clipboard.  If we did so, our user's first click would register a listener for future clicks, but not take any action on the first press of our copy button.

That means, we need to somehow register the `ClipboardJS` handler **before** the user clicks the copy button on an example for the first time.  

We could tag the button we intend to register with an ID and use DOM selectors like `getElementByID` to register our clipboard event handler.  Convention frowns upon this approach though, as our React components should limit their modifications of the DOM to the component lifecycle methods.  If React is going to make modifications to the document, updates in our component's props or state should instigate those changes.  Integrating with 3rd party tools though often comes into conflict with this pattern (as we see with ClipboardJS).

For this React provides us with refs when we need to access or manipulate the DOM.  The refs attribute, added to our components or JSX tags, adds a callback method to the elements render lifecycle.  Just before the component is mounted, the given ref callback fires.  This callback function receives, as its attribute, an instance of the element firing the callback.  The callback allows us to register a specific node of our document to an instance variable of the component.   

In this case, we are wrapping our copy button inside a `<span>` tag.  That span tag contains a ref function, which when fired, ties our span container to a newly created instance attribute of our component: `this.triggerCopy`.

React ensures all these ref functions fire before the component finishes mounting.  This pattern allows us to rely on refs being available by the time our components lifecycle method `componentDidMount` fires.  Inside `componentDidMount` we register the `ClipboardJS` click handler to our copy button and configure it to move the full code of our example onto the clipboard when pressed.

Notice that we can use refs as we would any other DOM selector.  Here, I had difficulty with Semantic UI not allowing me to tag refs directly onto semantic components.  So I had to wrap these buttons in a span tag to carry the ref.  I am still free, however, to use further selectors against that ref to narrow my target.  In this case we use `querySelector("button")` to target the HTML button element rendered inside our ref.

Revisit your application with this updated code, and try out the copy button.

### Collapse and Expand All Sections

We have seen one use case of refs, and we are about to see another.  How are we going to implement a function on our parent component (`CodeBlock`) that causes a state change in our child components?  Right now our parent component isn't aware that our child components even have a state of their own.  In theory, we could rewrite the `CodeBlock` and `CodeSection` components so that all of the state maintenance happens inside `CodeBlock`.  We would track the expanded/collapsed state of each section in our parent, and push updated props to the rendered `CodeSections` when the state changes.  

However, that would be a fair bit of hassle to build, when we consider that each code section renders an undetermined number of sections.  We would need a way to track state across all of them, not knowing how many instances we would need to monitor.  There's also the added complication that only a share of our components even **do anything** with the collapsed/expanded state.  Our high and normal priority component blissfully ignore this state.

It makes much more sense for the child component to maintain its state.  However, what happens when we want to push a mass state update from a parent component to multiple children?  Luckily, we have refs for that.

To begin, we are going to need some way of assigning a specific state to the `collapsed` attribute inside of our `CodeSection` components.  Right now, we can toggle back and forth, but we need assignment support if we are going to open/close all examples regardless of their current state.

``` javascript(/reactive-client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

- const codeSectionStyle = {
-   display: "table-row",
-   padding: "0 5px",
-   lineHeight: "100%"
- };

- const codeGutterStyle = {
-   display: "table-cell",
-   padding: "0 5px"
- };

- const codeBodyStyle = {
-   margin: 0,
-   display: "table-cell",
-   width: "100%",
-   paddingRight: "10px",
- };

class CodeSection extends Component {
-   constructor(props){
-     super(props);
-     if(props.priority === "low"){
-       this.minimizedContent = props.contents[0];
-       this.state = {collapsed: true};
-     } else { this.state = {collapsed: false} }
-   }

-   renderSectionContent = () => {
-     let p = this.props;
-     return this.state.collapsed ? <CodeCollapsed {...p} /> : <CodeFull {...p} />;
-   }
  
-   toggleCollapse = (e) => {
-     if(this.props.priority === "low"){
-       this.setState({collapsed: !this.state.collapsed});
-     }
-   };
  
+   setCollapse = (bool) => {
+     if(this.props.priority == "low"){
+       this.setState({collapsed: bool});
+     }
+   };
  
-   render() {
-     let priority = this.props.priority;
-     let icon = this.state.collapsed ? "plus" : "minus"; 
-     
-     return (
-       <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={codeSectionStyle}>
-         <div className="codeGutter" style={codeGutterStyle}>
-           <i className={"fa fa-"+ icon +"-square-o"}></i>
-         </div>
-         <div className="codeBody" style={codeBodyStyle} id={this.props.section_id}>
-           { this.renderSectionContent() }
-         </div>
-       </div>
-     );
-   }
}

export default CodeSection;
```

Now, we need to setup refs to give us a path to invoke this function.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react'
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
  renderCodeSections = (sections) => {
+     this.section_refs = [];
    return Array.from(sections, s => {
      return(
+         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
+         contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
+   collapseSections = (bool) => {
+     this.section_refs.forEach((ref) => {
+       if(ref){ ref.setCollapse(bool) }
+     });
+   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { this.code_fence.block_path ? 
          <div style={blockHeaderStyles}>
            { this.code_fence.block_path }
            <Popup
              trigger={
+                 <Button onClick={()=>this.collapseSections(false)}
+                 icon size="mini" floated="right" color="grey">
+                   <Icon name='plus' />
+                 </Button>
              }
              position="bottom center" content='Expand All'
            />
            <Popup
              trigger={
+                 <Button onClick={()=>this.collapseSections(true)}
+                 icon size="mini" floated="right" color="grey">
+                   <Icon name='minus' />
+                 </Button>
              }
              position="bottom center" content='Collapse All'
            />
            <span ref={ref => this.triggerCopy = ref}>
              <Popup
                trigger={
                  <Button icon size="mini" floated="right" color="grey" onClick={this.copyToClipboard}>
                   <Icon name='copy' />
                  </Button>
                }
                position="bottom center" content='Copy All'
              />
            </span>
          </div> 
          : null 
        }
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We are updating our `renderCodeSections` function to create an array of refs for our sections as we render them.  We can use these refs to access each instance of the `CodeSection` class that the `CodeBlock` creates.  Also, more importantly, we can use those instances as a path to invoke our new `setCollapse` methods on each section.

From there, it is not much different than any click handler we might set up.

`collapseSections` is set up to take a single boolean value in its parameters.  When invoked, it loops through each of our refs, and calls the `instance.setCollapse` function, passing along a boolean value for the state we wish to set.  Then all we need to do is tie a click handler to both our collapse and expand buttons in the header.  We use an anonymous function to wrap the call to `collapseSections` and pass along the correct boolean value.  This pattern allows us to reuse the `collapseSections` function to handle both the collapse and expand actions.

### Sharing Refs with Parent and Child

Good so far.  However, I cannot help but feel like our `CodeBlock` component has grown too large.  We are using this single component to handle several variations of code fences in our book's content.  Simple examples, that contain no header/file path get none of these additional buttons/features provided by the header.  However, that distinction in our rendering is not very clear given that the if statement controlling this rendering is mixed in with all the header's complexity.

I think we should probably split the header out from the `CodeBlock` component.  That way, the setup of our button's look and feel, as well as its click handlers are not intermixed with the rendering logic for the larger `CodeBlock` component.

First, let's move the header content out of our `CodeBlock` component.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { 
          this.code_fence.block_path ?
+           <CodeHeader block_path={this.code_fence.block_path} collapseHandler={this.collapseSections} />
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We are making some easy modifications right away.  We are now referring to the entire header section as a single component, and passing it a limited set of the props it needs to do its work; the `block_path` and the function `collapseHandler`.  This modification allows us to transition most of our functionality easily.  

Here's the matching `CodeHeader` setup for this much of our refactor.

``` javascipt(/reactive-client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react';

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

class CodeHeader extends Component {
  render() {
    return (
      <div style={blockHeaderStyles}>
        { this.props.block_path }
        <Popup
          trigger={
            <Button onClick={()=>this.props.collapseHandler(false)}
            icon size="mini" floated="right" color="grey">
              <Icon name='plus' />
            </Button>
          }
          position="bottom center" content='Expand All'
        />
        <Popup
          trigger={
            <Button onClick={()=>this.props.collapseHandler(true)}
            icon size="mini" floated="right" color="grey">
              <Icon name='minus' />
            </Button>
          }
          position="bottom center" content='Collapse All'
        />
        <span ref={ref => this.triggerCopy = ref}>
          <Popup
            trigger={
              <Button icon size="mini" floated="right" color="grey">
               <Icon name='copy' />
              </Button>
            }
            position="bottom center" content='Copy All'
          />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

Much of what we had before is unchanged.  Our click handlers for the collapse and expand buttons can be passed through from the parent as a prop.  We then use that `collapseHandler` property in the same way we used the original `collapseSections` function.  This design works because `this` inside of our `collapseHandler` function is bound to the `CodeBlock` parent component.  Even when we invoke it from within a child component, it can still access our `this.section_refs` array for the parent `CodeBlock`, and fire the open/collapse for each section correctly.  

What about our ref though on the copy button?  We know we can pass a function reference down from the parent.  Can we pass a ref back just as easily from the child?  In fact, we can, and it works in much the same way as we would pass any function to a child component.

```javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
        { 
          this.code_fence.block_path ?
+           <CodeHeader block_path={this.code_fence.block_path} 
+           collapseHandler={this.collapseSections} triggerRef={(trigger) => this.triggerCopy = trigger} />
          : null 
        }
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
      </div>
    );
  }
}

export default CodeBlock;
```

All we need to do it set up a new property for our `CodeHeader` component, and pass in the function we ultimately use to register our ref inside this child component.  We use this function to set `this.triggerCopy`, relying on the fact that `this` will remain bound to our parent component, even when we invoke it inside the child.

Then the matter of updating the `CodeHeader` component is as simple as using this passed property.

``` javascript(/reactive-client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Popup, Button, Icon } from 'semantic-ui-react';

- const blockHeaderStyles = {
-   borderBottom: "3px double #021a40",
-   backgroundColor: "#021a40",
-   color: "#fff",
-   padding: "5px 10px 5px 20px",
-   textOverflow: "ellipsis"
- };

class CodeHeader extends Component {
  render() {
    return (
      <div style={blockHeaderStyles}>
        { this.props.block_path }
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />

+          <span ref={this.props.triggerRef}>
          <Popup
            trigger={
              <Button icon size="mini" floated="right" color="grey">
               <Icon name='copy' />
              </Button>
            }
            position="bottom center" content='Copy All'
          />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

Just like that, we have restored support for our copy button inside the child component.

I am going to do a bit of final cleanup on the `CodeBlock` render before we close out.

``` javascript()
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
+   renderHeaderIf = (block_path) => {
+     if(block_path){ return( 
+       <CodeHeader 
+         block_path={this.code_fence.block_path} 
+         collapseHandler={this.collapseSections}
+         triggerRef={(trigger) => this.triggerCopy = trigger} 
+       />
+     )}
+   };
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
-   componentDidMount(){
-     if(this.triggerCopy){
-       let button = this.triggerCopy.querySelector("button");
-       return new clipboardJS(button, {
-         text: () => this.code_fence.copy
-       });
-     }
-   }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
  render() {
    return (
      <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
      id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
+         { this.renderHeaderIf(this.code_fence.block_path) } 
        <div style={blockBodyStyle}>
          { this.renderCodeSections(this.code_fence.sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

## Summary

We have now rebuilt our code examples to be significantly richer than what we were able to achieve with the default renderings provided by our client and server-side markdown processors.

In the process, we have introduced several new composability patterns for our React components.  Setting up ES2015 classes to encompass work with our application data not directly tied to React's rendering lifecycle.  Using state within our components outside of the application state managed by Redux.  Also, traversing our rendered document using refs to pass ties to specific elements between parent and child components.

There are still some significant gaps in our code examples.  Most notably, the rendering of small mobile screen formats.  In a future iteration, we might need to address this with some device specific logic for our rendering.  For now, we are putting a pin in this.

Now moving forward, we'll look at extending the testability and overall stability of our components.  In the next chapter, we add test coverage in areas of our application we have previously passed over.