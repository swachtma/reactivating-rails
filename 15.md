# Chapter 15: Implementing a Responsive Design

Designing our application, we have focused primarily on our desktop display.  While we occasionally made small brush-ups to our mobile UI, it never received anything but afterthought treatment.  

Preparing to launch, we should consider users who might have their first impression of our application on a mobile phone, and refactor our layout to optimize smaller devices.  Semantic UI provides conditional rendering components that draw different elements of our application based on the device's resolution.  In this chapter, we use these components to increase the cross-device flexibility of our application.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch15-starter
```

## Responsive Design Tools

The approach we are using to introduce a responsive design to our application is one of many possibilities.  Nothing precludes us from using device-specific CSS, or media queries to implement an entirely CSS based solution for managing device breakpoints.  

I want to explore Semantic UI's responsive design features in the hope of implementing a more React-centric solution.  Our components are styled with inline Javascript (as opposed to external CSS).  Shipping our responsive support via components as well should help us preserve them as freestanding, reusable units of our UI.

## Beginning with Semantic UI Responsive

Before redesigning our entire interface, let's introduce Semantic UI's `Responsive` component to one isolated piece of our design: our code examples.

This element has several issues with its small-screen rendering.  Take a look:

![Current mobile code block rendering, which incorrectly wraps tittle/tools line and minimizes content area to unacceptable width.](/images/15/flawedMobileCodeBlock.png)

Titles in our code examples run wider than our screen can accommodate.  This overflow causes the other tools in the header (copy, minimize, and maximize) to wrap onto a second line.  That, in turn, causes the body of our code example to render in an improper width.

Let's start our redesign by altering the displayed title for mobile devices.  On mobile phones, we can print only the file name of our code examples but show the entire file path for larger screens.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

const blockHeaderStyles = {
  borderBottom: "3px double #021a40",
  backgroundColor: "#021a40",
  color: "#fff",
  padding: "5px 10px 5px 20px",
  textOverflow: "ellipsis"
};

class CodeHeader extends Component {
  constructor(props){
    super(props);
+     let path_segments = props.block_path.split("/");
+     this.block_file = path_segments[path_segments.length - 1];
  }
  
  render() {
    return (
      <div style={blockHeaderStyles}>
+         <Responsive as="span" {...Responsive.onlyMobile}>{this.block_file}</Responsive>
+         <Responsive as="span" minWidth={Responsive.onlyMobile.maxWidth + 1}>{this.props.block_path}</Responsive>

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />

       <span ref={this.props.triggerRef}>
-           <Popup
-             trigger={
-               <Button icon size="mini" floated="right" color="grey">
-                <Icon name='copy' />
-               </Button>
-             }
-             position="bottom center" content='Copy All'
-           />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

The `Responsive` component has a simple interface controlled almost entirely by two props, `minWidth` and `maxWidth`.  Each prop is true to its given name; allowing child elements to render only if the screen width falls within the defined range.

A static value, `Responsive.onlyMobile` provides predefined breakpoints which Semantic UI considers a mobile device resolution (320px through 767px wide if you were curious).  There's no magic behind these presets; look at `Responsive`'s source code, and you find simple objects defining these preset ranges.

``` javascript
static onlyMobile = { minWidth: 320, maxWidth: 767 }
static onlyTablet = { minWidth: 768, maxWidth: 991 }
static onlyComputer = { minWidth: 992 }
static onlyLargeScreen = { minWidth: 1200, maxWidth: 1919 }
static onlyWidescreen = { minWidth: 1920 }
```

These definitions give us a more intuitive interface for `Responsive` than manually defining our breakpoints: `<Responsive as="span" {...Responsive.onlyMobile}>`

We can also define boundaries explicitly, as shown above when creating a component that renders for all devices except larger than mobile phones: `<Responsive as="span" minWidth={Responsive.onlyMobile.maxWidth + 1}>`

That brings me to two complaints I have with the Responsive component.  First, I find the provided list of static values to be rather sparse.  We have values for onlyMobile, onlyTablet, and so on.  What about our use case above; everything except mobile? 

I also disagree with having a defined minWidth on the `onlyMobile` preset.  Since it is our smallest boundary, if our screen resolution changes to 319px we render nothing at all.

Luckily, we can quickly address both of these complaints with a constants file.

``` javascript(/client/src/constants/breakpoints.js)
import { Responsive } from 'semantic-ui-react';

export const onlyMobile = { maxWidth: Responsive.onlyMobile.maxWidth};
export const onlyTablet = Responsive.onlyTablet;
export const onlyDesktop = Responsive.onlyComputer;
export const onlyLarge = Responsive.onlyLargeScreen;
export const onlyWide = Responsive.onlyWidescreen;

export const aboveMobile = {minWidth: onlyMobile.maxWidth + 1};
export const aboveTablet = {minWidth: onlyTablet.maxWidth + 1};
export const aboveDesktop = {minWidth: onlyDesktop.maxWidth + 1};

export const belowTablet = {maxWidth: onlyTablet.minWidth - 1};
export const belowDesktop = {maxWidth: onlyDesktop.minWidth - 1};
export const belowLarge = {maxWidth: onlyLarge.minWidth - 1};
```

This constants file defines custom variations for default values `Responsive` provides.  We are redefining some existing values so we can avoid calling breakpoints from two separate modules.  That redefinition also allows us to do some fine tuning, like removing `minWidth` from our `onlyMobile` preset.  

I am also renaming the default `onlyComputer` to `onlyDesktop`.  It's entirely a personal preference, but when I think of three-screen designs, I refer to them as mobile, tablet, and desktop; not mobile, tablet, and computer.  Nitpicky, but I don't want to be continuously reaching for the wrong name.

We're also defining new range types, adding in `aboveDEVICE` and `belowDEVICE` values.  These new ranges use a +/- modification on the default breakpoints provided by the `Responsive` class to define new multi-device ranges.

Let's break our file title into a freestanding component, and use our newly defined ranges.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
  filePath: {
    fontSize: ".9em",
    display: "inline-block",
  },
  limitedTitle: {
    display: "inline-block",
    width: "125px",
    textOverflow: "ellipsis",
    overflow: "hidden"
  }
};

class CodeHeader extends Component {
  render() {
    let { block_path } = this.props;
    return (
      <div style={styles.blockHeaderStyles}>
+         <FilePath block_path={block_path} />
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />
        
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />
        
        <span ref={this.props.triggerRef}>
-           <Popup
-             trigger={
-               <Button icon size="mini" floated="right" color="grey">
-                <Icon name='copy' />
-               </Button>
-             }
-             position="bottom center" content='Copy All'
-           />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;

export class FilePath extends Component {
  constructor(props){
    super(props);
    let path_segments = props.block_path.split("/");
    this.block_file = path_segments[path_segments.length - 1];
    this.block_path = this.props.block_path;
  }
  
  render() {
    let { block_file, block_path } = this;
    return(
      <div style={styles.filePath}>
        <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
        <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
      </div>
    );
  }
}
```

In the example above, I refactored our CSS styles as children of a single `styles` object.  As we refactor, I plan to use this pattern for defining styles on my components.  This change makes our components more readable by clearly indicating we are calling a style object when we access these elements.

## Semantic UI Controlled Components

We have some other problems to address in this code header area.  As we create views for mobile devices, we need to acknowledge the differences in input methods between desktop, mobile, and tablet users.  

Look at the icon buttons in the headers of our code examples.  On desktop devices, the button's hover state triggers a `Popup` display, showing a tooltip for each action.  Touch events though, don't have hover states and instead trigger each `Popup` to display on touch, and then linger onscreen.

Most of our work with Semantic UI has relied on its automatically controlled components; sensible defaults shipped to handle each element.  We can abandon these defaults though when we need to move beyond them.

Let's refactor `CodeHeader` again and migrate our icon buttons into a standalone component so we can exert more granular control.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

class CodeHeader extends Component {
  render() {
+     let { block_path, collapseHandler, triggerRef } = this.props;
    return (
      <div style={styles.blockHeaderStyles}>
        <FilePath block_path={block_path} />
+         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
+         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
+         <span ref={triggerRef}>
+           <HeaderControlButton icon="copy" label="Copy All" />
+         </span>
      </div> 
    );
  }
}

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
  render() {
    let { handler, icon, label } = this.props;
    return(
      <Popup
        trigger={
          <Button className={icon} onClick={handler}
          icon size="mini" floated="right" color="grey">
            <Icon name={icon} />
          </Button>
        }
        position="bottom center" content={label}
      />
    );
  }
}
```

The example above is an exact migration of our existing functionality.

Have a look at the span wrapping our "Copy All" button: `<span ref={triggerRef}>`

In an earlier chapter, we wrapped this button in another element to create a reference on the specific DOM node users were clicking.  However, as we transition these controls to a component, it's increasingly less clear why this one button needs wrapping, and others do not.

There's no need for our ref to wrap the trigger button of our event directly.  We can use a CSS query selector to target the specific element from a more extensive selection.  I am going to move our ref up to the containing `div`, and modify the function tied to it, so it selects the specific button we need based on the className we added in the last refactor.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

class CodeHeader extends Component {
  render() {
    let { block_path, collapseHandler, triggerRef } = this.props;
    return (
+       <div style={styles.blockHeaderStyles} ref={triggerRef}>
        <FilePath block_path={block_path} />
        <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
        <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
+         <HeaderControlButton icon="copy" label="Copy All" />
      </div> 
    );
  }
}

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

- export class HeaderControlButton extends Component {
-   render() {
-     let { handler, icon, label } = this.props;
-     return(
-       <Popup
-         trigger={
-           <Button className={icon} onClick={handler}
-           icon size="mini" floated="right" color="grey">
-             <Icon name={icon} />
-           </Button>
-         }
-         position="bottom center" content={label}
-       />
-     );
-   }
- }
```

We also need to update the function managing this ref in our `CodeBlock` component.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderHeaderIf = (block_path) => {
-     if(block_path){ return( 
-       <CodeHeader 
-         block_path={this.code_fence.block_path} 
-         collapseHandler={this.collapseSections}
-         triggerRef={(trigger) => this.triggerCopy = trigger} 
-       />
-     )}
-   };
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
  componentDidMount(){
    if(this.triggerCopy){
+       let button = this.triggerCopy.querySelector("button.copy");
      return new clipboardJS(button, {
        text: () => this.code_fence.copy
      });
    }
  }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
-   render() {
-     return (
-       <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
-       id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
-         { this.renderHeaderIf(this.code_fence.block_path) } 
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
-       </div>
-     );
-   }
}

export default CodeBlock;
```

Now we can rework these button to expand our mobile device functionality.

### Handling Defaults on Controlled Components

We can begin transitioning to a controlled `Popup` component by rebuilding behaviors mirroring existing defaults.  We need to track an open/closed state and define an open and close handler to manage state transitions.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

- class CodeHeader extends Component {
-   render() {
-     let { block_path, collapseHandler, triggerRef } = this.props;
-     return (
-       <div style={styles.blockHeaderStyles} ref={triggerRef}>
-         <FilePath block_path={block_path} />
-         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
-         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
-         <HeaderControlButton icon="copy" label="Copy All" />
-       </div> 
-     );
-   }
- }

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
+   state = { isOpen: false };
+   
+   handleOpen = (e,data) => {
+     this.setState({ isOpen: true });
+   }
+   
+   handleClose = () => {
+     this.setState({ isOpen: false });
+   }
  
  render() {
    let { handler, icon, label } = this.props;
    return(
      <Popup
+         on={["click","hover"]}
+         open={this.state.isOpen}
+         onClose={this.handleClose}
+         onOpen={this.handleOpen}
        trigger={
          <Button className={icon} onClick={handler}
          icon size="mini" floated="right" color="grey">
            <Icon name={icon} />
          </Button>
        }
        position="bottom center" content={label}
      />
    );
  }
}
```

We are adding four new props to Semantic UI's `Popup`; `on`, `open`, `onOpen`, and `onClose`.  The `on` prop instructs our component to fire an open or close event for specific user actions (click and hover in this case).  Those events trigger the defined `onOpen` or `onClose` event handlers, depending on the component's current state.  The handler functions then invoke `this.setState` to change the `isOpen` value to show or hide our message.

Reload your application, and we have rebuilt our existing functionality.  Still, what is the point in all this extra code?

Now that we have verbosely defined the component's state changes, we can extend beyond their defaults.  We can prevent lingering mobile labels by writing a dedicated event handler for touch events. To start, we must wrap our Semantic UI `Popup` in another element; that way can manage an `onTouchStart` event it doesn't natively support.  This event can start a timer, and automatically clear our popups after the countdown elapses.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

- class CodeHeader extends Component {
-   render() {
-     let { block_path, collapseHandler, triggerRef } = this.props;
-     return (
-       <div style={styles.blockHeaderStyles} ref={triggerRef}>
-         <FilePath block_path={block_path} />
-         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
-         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
-         <HeaderControlButton icon="copy" label="Copy All" />
-       </div> 
-     );
-   }
- }

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
  state = { isOpen: false };
  
  handleOpen = (e,data) => {
    this.setState({ isOpen: true });
+     if(e.type === "click") this.handleTimeout();
  }
  
+   handleTimeout = (e) => {
+     this.timeout = setTimeout(() => {
+     this.setState({ isOpen: false });
+     }, 400);
+   }
  
  handleClose = () => {
    this.setState({ isOpen: false });
+     clearTimeout(this.timeout);
  }
  
  render() {
    let { handler, icon, label } = this.props;
    return(
+       <span onTouchStart={this.handleTimeout}>
        <Popup
          on={["click","hover"]}
          open={this.state.isOpen}
          onClose={this.handleClose}
          onOpen={this.handleOpen}
          trigger={
            <Button className={icon} onClick={handler}
            icon size="mini" floated="right" color="grey">
              <Icon name={icon} />
            </Button>
          }
          position="bottom center" content={label}
        />
+       </span>
    );
  }
}
```

When a user taps a control on a touch device, a 400ms `timeout` value begins.  We either let this timer run its course or clear it explicitly if a different event closes our `Popup`.

Reload your application on mobile, and you should see popup labels disappear soon after controls are touched.  This tooltip gives users a brief flash of text to reinforce the functionality of each button, without allowing lingering content to crowd valuable screen real-estate.  Let's move on to our larger UI.

## Responsive Global Navigation

Our top-level navigation bar is our next area of focus.

![Mobile navigation menus exceed the device width, causing them to stack and steal valuable screen space from our reading area. ](/images/15/mobileNavigationMenusPre.png)

I used Semantic UI's `stackable` setting as a lazy "solution" for responsive menus on smaller screen widths. With this setting enabled, individual navigation components can vertically stack if they can't render side by side.  This stacking behavior causes our navigation bar to grow taller as the device gets narrower, shrinking our valuable reading area.

Let's rework this area to keep our top-navigation bar on a single line.  I am going to remove our chapter selection dropdown from mobile phones, and instead use a popout menu that we can support across all devices for chapter navigation.  I am also reworking our chapter titles as part of this iteration.

To begin, let's trim our application stylesheet.  We have several rules targetting this global navigation menu, including some media-specific rules.  As with earlier refactors, we are going to push as much CSS as possible into our components.

``` css(/client/src/App.css)
img {max-width: 100%;}
#main-section {margin-top: 65px;}
#reader-pane img {border: 1px solid #021a40;}

code {
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
  padding: 0.2em .5em;
  margin: 0;
  font-size: 85%;
}

.hljs {padding: 0 0.5em;}
.codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
.codeGutter .fa { font-size: 12px; opacity: 0; }
.lowPrioritySection .fa { opacity: 100; }
.lowPrioritySection { cursor: pointer; } 
.highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }
pre {white-space: pre-wrap; margin: 0;}
```

Next, look at our `MenuBar` component.  Adding a responsive tag around our drop-down menu prevents it from rendering on our mobile devices (using our `aboveMobile` breakpoint).

I am also reworking many of the components we leverage from Semantic UI; in general, I am attempting to strip out custom CSS to better leverage Semantic's default settings.  I won't be detailing each of these changes, so you may want to copy/paste this example code into your codebase.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import rrLogo from '../assets/images/reactivating-rails.png';

import * as BREAKPOINTS from '../constants/breakpoints';
import { ConnectedChapterMenuItems } from '../containers/chapter_provider';
import { ConnectedUserBadge } from '../containers/user_provider';

const styles = {
  fixedMenuStyle: {
    backgroundColor: '#fff',
    border: '1px solid #ddd',
    boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
    paddingLeft: "1em",
    paddingRight: "1em"
  },
  menuIcon: {margin: "0"},
  logo: {
    margin: "auto 1.5em", 
    maxWidth: "230px",
    verticalAlign: "middle"
  }
};

class MenuBar extends Component {
  render() {
    let { active_chapter } = this.props;
    return (
        <Menu id="menu_bar" size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item fitted name='Main Menu'>
              <Icon style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={rrLogo} />
            <Menu.Menu position='right'value={active_chapter}>
              <Responsive {...BREAKPOINTS.aboveMobile } >
                <ConnectedChapterMenuItems />
              </Responsive>
              <ConnectedUserBadge />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

I've also made small refactors in other sub-components of our global navigation bar.  Copy these changes into your application as well so that you are ready to move forward with building our new navigation menu.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import ConnectedGitHubIcon from './github_icon';

const styles ={
  profile: {
    maxHeight: "32x",
    maxWidth: "32px",
    marginLeft: "1.757px"
  }
};

class UserBadge extends Component {
  render() {
    return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
  }
}

class ProfileIcon extends Component {
  render() {
    let { username, avatar, dispatchSignalSignout } = this.props;
    let badge = <Image src={avatar} avatar style={styles.profile}/>;
    return (
      <Menu.Item name={username} fitted>
        <Dropdown icon={badge} compact pointing="top right">
          <Dropdown.Menu>
            <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
          </Dropdown.Menu>
        </Dropdown>
      </Menu.Item>
    );
  }
}

export default UserBadge;
```

``` javascript(/client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';
import routeProvider from '../containers/route_provider';

const styles = {
  githubIcon: {marginRight: 0}
};

class GithubIcon extends Component {
  buildRedirect = (loc = this.props.location) => {
    let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
    return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
  }
  
  render() {
    let rd = this.buildRedirect();
    return (
      <Menu.Item 
        href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd}
        name='Sign in with GitHub'
        fitted
      >
        <Icon name='github' style={styles.githubIcon} size="big" />
      </Menu.Item>
    );
  }
}

const ConnectedGitHubIcon = routeProvider(GithubIcon);
export default ConnectedGitHubIcon;
```

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';

const styles = {
  dropdown: {margin: "0 1em"}
};

export default class ChapterMenuItems extends Component {
  renderChapterOptions = () => {
    let { active_chapter, chapters } = this.props;
    let chapters_list = [];
    chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
          active: chapter.id === active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
    let { active_chapter, dispatchRouteChapter } = this.props;
    return( 
        <Dropdown 
          pointing="top right"
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          style={styles.dropdown}
          selectOnNavigation={false}
          value={active_chapter.id}
          text={active_chapter.title}
          onChange={dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Reload your application and your mobile rendering should look like the following screenshot
![Updated single-line mobile navigation menu.](/images/15/mobileNavigationMenusPost.png)

## Roughing in SideBar Navigation

Adding a secondary navigation bar is a significant revision to our application.  So before worrying about the details of populating real content, I want to get our presentation prototyped.  Let's take a first pass at this new element using sample content from Semantic UI React's documentation.

To begin, add a new component to our top level `App` container.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
+ import SideBarPopout from './components/side_bar_popout';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <SideBarPopout />
        <MenuBar />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

Now we can define our new child component with draft content.

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

const styles = {
  popoutLayer: {
    position: "fixed",
    top: "0px",
    left: "0px",
    maxHeight: "150vh",
    minWidth: "100vw",
    zIndex: 100
  },
  pusher: { minHeight: "100vh", minWidth: "100vw" },
  sideBar: { maxWidth: "320px", maxHeight: "100vh", paddingTop: "45px" }
};

class SideBarPopout extends Component {
  render() {
    return (
      <div style={styles.popoutLayer}>
        <Sidebar.Pushable style={styles.pusher}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={true} icon='labeled' 
          style={styles.sideBar} inverted vertical>
-             <Menu.Item name='home'>
-               <Icon name='home' />
-               Home
-             </Menu.Item>
-             <Menu.Item name='gamepad'>
-               <Icon name='gamepad' />
-               Games
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
            <Menu.Item name='cancel'>
             <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher style={styles.pusher} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout;
```

Most of our menu's content is trivial at this point; our buttons are simple mockups.  What is essential is having content overflowing the screen of the smallest device I plan to support, the iPhone 5/SE device, which has a screen resolution of 320x568.  

Our menu is a new layer produced in a `div` tag and using a z-index value of 100 to position the element at the top of our vertical stack, overlapping our center content, but still underneath our navigation bar.  We're using CSS viewport height and width units, to ensure this element occupies the entire screen space with its navigation menu and dimmer layer.

Finally, we set specific `overflowY` instructions on the element rendering our navigation buttons.  This way, we can offer a scrollbar for this menu when its content overflows the devices screen space.

### Self Contained State

With the basics of our UI outlined, let's connect to our store.

Modify your `chapter_provider` container to export a connected sidebar component.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterMenuItems from '../components/chapter_menu_items';
import ChapterFooter from '../components/chapter_footer';
import SideBarPopout from '../components/side_bar_popout';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

const chapterProvider = (WrappedComponent) => {
  return class extends React.Component {
    render(){
      if(this.props.chapters !== []){
        return <WrappedComponent {...this.props} active_chapter={this.props.active_chapter || -1} />;
      } else {
        return null;
      }
    }
  };
};

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterMenuItems = connectToChapters(ChapterMenuItems);
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
+ export const ConnectedChapterSideBar = connectToChapters(SideBarPopout);
```

Be sure to update your `App` component to use this new connected component as well.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
import { ConnectedChapterSideBar } from './containers/chapter_provider';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <ConnectedChapterSideBar />
        <MenuBar />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

Now we can add some local state for this component.  Rather than hardwiring the component to be visible at all times, create a state value to track the opening and closing of the menu.  Toggle the menu's state to closed anytime a user clicks a link, our "close" button, or anywhere within the dimmer.  

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

const styles = {
-   popoutLayer: {
-     position: "fixed",
-     top: "0px",
-     left: "0px",
-   },
  pusher: { minHeight: "100vh", minWidth: "100vw" },
-   sideBar: { 
-     minWidth: "320px",
-     maxWidth: "320px",
-     minHeight: "100vh",
-     maxHeight: "100vh",
-     paddingTop: "45px", 
-     zIndex: 100
-   }
};

class SideBarPopout extends Component {
  state = { visible: true };
  
  toggleVisibility = (bool) => {
    let vis = bool === undefined ? !this.state.visible : bool;
    this.setState({ visible: vis});
  };
  
  handleLink = (e,t) => {
    this.props.dispatchRouteChapter(e,t);
    this.toggleVisibility();
  };
  
  handleCloseClick = () => this.toggleVisibility();
  
  renderChapterLinks = () => {
    let { chapters } = this.props;
    return chapters.map((chapter)=>{
      let key = "chapter"+chapter.id;
      return(
        <Menu.Item link={true} onClick={this.handleLink}
        name={key} key={key} value={chapter.id}>
          {chapter.title}
        </Menu.Item>
      );
    });
  };
  
  render() {
    let { visible } = this.state;
    return (
      <div style={styles.popoutLayer} onBlur={this.handleBlur}>
        <Sidebar.Pushable style={visible ? styles.pusher : null}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={visible} icon='labeled' 
          style={styles.sideBar} inverted vertical>
            { this.renderChapterLinks() }
            <Menu.Item link={true} onClick={this.handleCloseClick} name='cancel'>
              <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher onClick={this.handleCloseClick} style={visible ? styles.pusher : null} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout
```

We're adding a function to print chapter links for each item in our `chapters` prop, and leveraging `dispatchRouteChapter` to trigger page changes.  We also added a `toggleVisibility` method to handle visibility state change. This function is used across several UI elements to trigger the menu to close.  

Notice in several places we conditionally assign styles from `styles.pusher`, applying them only if the component is in its visible state.  We need this conditional styling because the way I am using Semantic UI's `Sidebar` component departs from it's intended use.  Rather than leveraging this component inside an existing content layer, we are drawing the Sidebar as a fixed position element, and using CSS to ensure it occupies the entire screen.

Without the conditional CSS, our menu would continue to overlap the entire screen, even in its `visible == false` state.  That overlap interferes with our ability to scroll other elements onscreen, particularly on mobile devices where we often need horizontal scrolling inside code examples.  To alleviate this problem, we're assigning a minimum height and width to this menu only when it is in its visible state, and we want it to block underlying elements. We allow the element to collapse entirely when invisible, restoring our ability to interact with other elements.

Take a look at your desktop rendering, and you should see the following:
![Desktop sidebar rendering with early chapter links, and close events managed for all of the component's internal elements.](/images/15/desktopEarlySidebarRender.png)

Now that we have the internals figured out, we need to address the controls that live outside the component, like the menu button in our top navigation.

## Managing References

We are going to refactor our two navigation components that need to reference one another so that a single parent component includes each child.  Using this new parent layer, we can manage the references needed to invoke state changes across the two components. 

First, let's create the new component.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
  render() {
    return [
        <SideBarPopout {...this.props} key="sidebar" />,
        <MenuBar {...this.props} key="menubar" />
    ];
  }
}

export default NavigationMenus;
```

We are leveraging a new render strategy in this component; returning an Array of elements. React 16+ can automatically render a collection of children so long as we provide a unique `key` attribute for each child.  This strategy saves us adding an otherwise useless `div` to our DOM.

Next, update `chapter_provider` to connect this parent element to our state.  Notice in the example above, as `NavigationMenus` renders each child menu, we pass through all the parent's props with the spread operator.  That means we no longer need to connect each child menu to our store individually.  We can strip out this connection as we make other updates.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

- const chapterProvider = (WrappedComponent) => {
-   return class extends React.Component {
-     render(){
-       if(this.props.chapters !== []){
-         return <WrappedComponent {...this.props} active_chapter={this.props.active_chapter || -1} />;
-       } else {
-         return null;
-       }
-     }
-   };
- };

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
+ export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

We should also update our `App` component to leverage this new combined component.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
+ import { ConnectedNavigationMenus } from './containers/chapter_provider';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <ConnectedNavigationMenus />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

We also need to refactor `GithubIcon` to rework its connection to the store.  Adapt this component and `routerProvider` to move the creation of the `ConnectedGitHubIcon` component into the container.

``` javascript(/client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';

- const styles = {
-   githubIcon: {marginRight: 0}
- };

- class GithubIcon extends Component {
-   buildRedirect = (loc = this.props.location) => {
-     let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
-     return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
-   }
-   
-   render() {
-     let rd = this.buildRedirect();
-     return (
-       <Menu.Item 
-         href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd}
-         name='Sign in with GitHub'
-         fitted
-       >
-         <Icon name='github' style={styles.githubIcon} size="big" />
-       </Menu.Item>
-     );
-   }
- }

+ export default GithubIcon;
```

``` javasccript(/client/src/containers/route_provider.js)
import { connect } from 'react-redux';
import RouterSwitch from '../components/router_switch';

import GithubIcon from '../components/github_icon';

- const routerProvider = (WrappedComponent = RouterSwitch) => {
-   let mapStateToProps = (state) => ({
-     location: state.location
-   });
-   
-   return connect(mapStateToProps,null)(WrappedComponent);
- };

export default routerProvider;

+ // EXPORTABLE CONNECTED COMPONENTS
+ export const ConnectedGitHubIcon = routerProvider(GithubIcon);
```

We need matching updates to `UserBadge`.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

+ import { ConnectedGitHubIcon } from '../containers/route_provider';

- const styles ={
-   profile: {
-     maxHeight: "32x",
-     maxWidth: "32px",
-     marginLeft: "1.757px"
-   }
- };

class UserBadge extends Component {
  render() {
+     return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
  }
}

- class ProfileIcon extends Component {
-   render() {
-     let { username, avatar, dispatchSignalSignout } = this.props;
-     let badge = <Image src={avatar} avatar style={styles.profile}/>;
-     return (
-       <Menu.Item name={username} fitted>
-         <Dropdown icon={badge} compact pointing="top right">
-           <Dropdown.Menu>
-             <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
-           </Dropdown.Menu>
-         </Dropdown>
-       </Menu.Item>
-     );
-   }
- }

export default UserBadge;
```

Finally, update `MenuBar` to reflect the changes we have made elsewhere in our application.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import rrLogo from '../assets/images/reactivating-rails.png';

import * as BREAKPOINTS from '../constants/breakpoints';
+ import ChapterMenuItems from './chapter_menu_items';
import { ConnectedUserBadge } from '../containers/user_provider';

- const styles = {
-   fixedMenuStyle: {
-     backgroundColor: '#fff',
-     border: '1px solid #ddd',
-     boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-     paddingLeft: "1em",
-     paddingRight: "1em",
-   },
-   menuIcon: {margin: "0"},
-   logo: {
-     margin: "auto 1.5em", 
-     maxWidth: "230px",
-     verticalAlign: "middle"
-   }
- };

class MenuBar extends Component {
  render() {
    let { active_chapter } = this.props;
    return (
        <Menu id="menu_bar" size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item fitted name='Main Menu'>
              <Icon style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={rrLogo} />
            <Menu.Menu position='right'value={active_chapter}>
              <Responsive {...BREAKPOINTS.aboveMobile } >
+                 <ChapterMenuItems {...this.props} />
              </Responsive>
              <ConnectedUserBadge />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Since MenuBar is now receiving our `store.chapters` state as props from a connected parent component, it's useless to have `ChapterMenuItems` connecting directly.  We can rework this component to expect the data it needs as props from its parent `MenuBar`.

## Working with Refs

We are ready to add refs for cross-component triggering of our menu.  I am centralizing as much work as I can in the new `NavigationMenus` component.

To begin, let's create our refs.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
  constructor(props){
    super(props);
+     this.sideBarRef = React.createRef();
  }
  
+   handleSidebarVisibility = (e,t) => {
+     this.sideBarRef.current.toggleVisibility();
+   };
  
  render() {
    return [
+         <SideBarPopout ref={this.sideBarRef} {...this.props} key="sidebar" />,
+         <MenuBar handleSidebarVisibility={this.handleSidebarVisibility} {...this.props} key="menubar" />
    ];
  }
}

export default NavigationMenus;
```

We've created a ref `sideBarRef`, and assigned it to the `SideBar` component.  When assigning a ref to a custom component built as a React Class, the ref returns that instance of the class under `sideBarRef.current` anywhere else it is accessed.  This grants access to methods of the class from other areas of our application.  (Note: this pattern is unsupported by Functional components).

We created a new method `handleSidebarVisibility` that uses our ref to manage the sidebar's open and close.  Passing this method to the child component `MenuBar` allows us to trigger the `SideBar.toggleVisibility` functionality from its sister component.

Update `MenuBar` to use this new function.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import rrLogo from '../assets/images/reactivating-rails.png';

import * as BREAKPOINTS from '../constants/breakpoints';
import ChapterMenuItems from './chapter_menu_items';
import { ConnectedUserBadge } from '../containers/user_provider';

const styles = {
  fixedMenuStyle: {
    backgroundColor: '#fff',
    border: '1px solid #ddd',
    boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
    paddingLeft: "1em",
    paddingRight: "1em",
+     maxWidth: "100vw"
  },
  menuIcon: {margin: "0"},
-   logo: {
-     margin: "auto 1.5em", 
-     maxWidth: "230px",
-     verticalAlign: "middle"
-   }
};

class MenuBar extends Component {
  render() {
    let { active_chapter, handleSidebarVisibility } = this.props;
    return (
+         <Menu id="menu_bar" onClick={handleSidebarVisibility} size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item id="sideMenuButton" link={true} fitted name='Main Menu'>
              <Icon id="sideMenuIcon" style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={rrLogo} />
            <Menu.Menu position='right'value={active_chapter}>
              <Responsive {...BREAKPOINTS.aboveMobile } >
+                 <ChapterMenuItems {...this.props} />
              </Responsive>
+               <ConnectedUserBadge handleSidebarVisibility={handleSidebarVisibility} />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

I want the sidebar to close anytime the user interacts with the top navigation menu, whether that is clicking the menu button, opening our chapter drop-down, or interacting with our login/profile button.  We use `handleSidebarVisibility` combined with `onClick` and `onFocus` events to create this behavior by passing our event handler further down our rendering chain.

Then we need to add the event handlers to the child components.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';

const styles = {
  dropdown: {margin: "0 1em"}
};

export default class ChapterMenuItems extends Component {
-   renderChapterOptions = () => {
-     let { active_chapter, chapters } = this.props;
-     let chapters_list = [];
-     chapters.forEach((chapter) => {
-       chapters_list.push(
-         { 
-           key: "chapter_" + chapter.id,
-           id:  "chapter_menu_item_" + chapter.id,
-           value: chapter.id,
-           text: chapter.title,
-           active: chapter.id === active_chapter.id
-         }
-       );
-     });
-     return chapters_list;
-   }
  
  render() {
    let { active_chapter, dispatchRouteChapter, handleSidebarVisibility } = this.props;
    return( 
+         <Dropdown onFocus={handleSidebarVisibility}
          pointing="top right"
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          style={styles.dropdown}
          selectOnNavigation={false}
+           selectOnBlur={false}
          value={active_chapter.id}
          text={active_chapter.title}
          onChange={dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

For `ChapterMenuItems`, I am using an `onFocus` handler rather than `onClick`. That way, users leveraging keyboard controls to change focus also trigger our sidebar's close behavior.  

I have also added a new property `selectOnBlur={false}` to the dropdown itself.  Before scrutinizing this control, I failed to notice a problem. Blurring this menu sometimes triggered unintended navigation if the user had a chapter selection highlighted when the drop-down unfocused.

We need similar updates inside `UserBadge`.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import { ConnectedGitHubIcon } from '../containers/route_provider';

- const styles ={
-   profile: {
-     maxHeight: "32x",
-     maxWidth: "32px",
-     marginLeft: "1.757px"
-   }
- };

- class UserBadge extends Component {
-   render() {
-     return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
-   }
- }

class ProfileIcon extends Component {
  render() {
    let { username, avatar, dispatchSignalSignout, handleSidebarVisibility } = this.props;
    let badge = <Image src={avatar} avatar style={styles.profile}/>;
    return (
      <Menu.Item name={username} fitted>
+         <Dropdown closeOnBlur={true} onFocus={handleSidebarVisibility} icon={badge} compact pointing="top right">
          <Dropdown.Menu>
            <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
          </Dropdown.Menu>
        </Dropdown>
      </Menu.Item>
    );
  }
}

export default UserBadge;
```

We aren't tagging `GithubIcon` with the event handler since clicking this element triggers offsite navigation.  For authenticated users though, the sign-out menu should trigger the sidebar to close.  I also added a `closeOnBlur` prop to this menu, preventing the signout menu from lingering on mobile screens when the focus shifts off this element.

### Leveraging the DOM with Refs.

There's another behavior we should address, clicking our top-left menu button should toggle the visibility of our sidebar. Other clicks within the menu should only close the menu if it is open, not the inverse.  In the example above I added several IDs to the sidebar menu button; `sideMenuButton` and `sideMenuIcon`.  We can use these IDs to refine our event handler's behavior, making it ignores opening clicks occurring elsewhere in our navigation menu.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
-   constructor(props){
-     super(props);
-     this.sideBarRef = React.createRef();
-   }
  
+   handleSidebarVisibility = (e,t) => {
+     let tgl = this.sideBarRef.current.toggleVisibility;
+     ["sideMenuIcon","sideMenuButton"].includes(e.target.id) ? tgl() : tgl(false);
+   };
  
-   render() {
-     return [
-         <SideBarPopout ref={this.sideBarRef} {...this.props} key="sidebar" />,
-         <MenuBar handleSidebarVisibility={this.handleSidebarVisibility} {...this.props} key="menubar" />
-     ];
-   }
}

export default NavigationMenus;
```

## Cleaning Up Menu Contents

Since our side navigation fills mobile screens, we should add a signout link for authenticated users that is visible while the menu is open.  We can also use this revision to style and deactivate the user's current location in our list of links.

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

import { ConnectedSidebarSignOut } from '../containers/user_provider';

- const styles = {
-   popoutLayer: {
-     position: "fixed",
-     top: "0px",
-     left: "0px",
-   },
-   pusher: { minHeight: "100vh", minWidth: "100vw" },
-   sideBar: { 
-     minWidth: "320px",
-     maxWidth: "320px",
-     minHeight: "100vh",
-     maxHeight: "100vh",
-     padding: "45px 0 0 5px", 
-     zIndex: 100
-   }
- };

class SideBarPopout extends Component {
  state = { visible: false };
  
-   toggleVisibility = (bool) => {
-     let vis = bool === undefined ? !this.state.visible : bool;
-     this.setState({ visible: vis});
-   };
  
-   handleLink = (e,t) => {
-     this.props.dispatchRouteChapter(e,t);
-     this.toggleVisibility();
-   };
  
  handleCloseClick = () => this.toggleVisibility();
  
  renderChapterLinks = () => {
    let { chapters, active_chapter } = this.props;
    return chapters.map((chapter)=>{
      let key = "chapter"+chapter.id;
+       let status = chapter.id === active_chapter.id;
      return(
+         <Menu.Item link={!status} onClick={this.handleLink} disabled={status}
+         name={key} key={key} value={chapter.id}>
          {chapter.title}
        </Menu.Item>
      );
    });
  };
  
  render() {
    let { visible } = this.state;
    return (
      <div style={styles.popoutLayer} onBlur={this.handleBlur} id="sideBarPopout">
        <Sidebar.Pushable style={visible ? styles.pusher : null}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={visible} 
          style={styles.sideBar} inverted vertical>
            { this.renderChapterLinks() }
+             <ConnectedSidebarSignOut handleCloseClick={this.handleCloseClick} />
            <Menu.Item link={true} onClick={this.handleCloseClick} name='Close Menu'>
              <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher onClick={this.handleCloseClick} style={visible ? styles.pusher : null} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout;
```

I am creating the new sign out link as a component so that we can connect just this one element to our store.

``` javascript(/client/src/components/side_bar_signout.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';

const styles = {signout: {color: "#cc0000"}}

class SideBarSignout extends Component {
  handleSignout = () => {
    this.props.handleCloseClick();
    this.props.dispatchSignalSignout();
  };
  
  render() {
    let { username } = this.props;
    if(username){
      return (
        <Menu.Item link={true} onClick={this.handleSignout} name='Sign Out'>
          <div style={styles.signout}><Icon name='cancel' />Sign Out</div>
        </Menu.Item>
      );
    } else {
      return null;
    }
  }
}

export default SideBarSignout;
```

Finally, we'll add this component as an exportable module from `user_provider`.

``` javascript(/client/src/containers/user_provider.js)
import { connect } from 'react-redux';

import UserBadge from '../components/user_badge';
import SideBarSignout from '../components/side_bar_signout';
import { signalSignout } from '../actions/user';

-  const connectToUser = (WrappedComponent) => {
-    return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
- };

- const mapStateToProps = (state) => ({
-   username: state.user.username,
-   avatar: state.user.avatar
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchSignalSignout: (e) => dispatch(signalSignout())
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedUserBadge = connectToUser(UserBadge);
+ export const ConnectedSidebarSignOut = connectToUser(SideBarSignout);
```

To finish, make a few small adjustments to our CSS to support the responsive layout changes we've made.  

At small resolutions, some code examples run offscreen.  Since these examples are sometimes long strings, unbroken by spaces, the text is unable to wrap.  Luckily, CSS allows us to easily assert that line breaks can occur as needed for such situations.

``` javascript(/client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import FilteredNodesList from '../containers/filtered_nodes_list';
import { ConnectedChapterFooterLink } from '../containers/chapter_provider';
import { ConnectedBookmarkModal } from '../containers/bookmarks_provider';

const reader_pane_styles= {
  paddingBottom: "15px",
+   overflowWrap: "break-word"
};

- class ReaderPane extends Component {
-   render() {
-     return (
-       <div id="reader-pane" style={ reader_pane_styles }>
-         <ConnectedBookmarkModal />
-         <Container text>
-           <FilteredNodesList />
-         <ConnectedChapterFooterLink />
-         </Container>
-       </div>
-     );
-   }
- }

export default ReaderPane;
```

## Wrapping Up

This chapter brought many changes that should make our content more accessible across devices.  It also concludes the last new features planned for our application.

In the final two chapters, we clean up our code with an application-wide refactor.  We look for opportunities to clarify our code's intent, expand test coverage, and to optimize render times. Finally, in our last chapter, we move our application through its first production release.
