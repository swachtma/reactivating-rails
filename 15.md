# Chapter 15: Implementing a Responsive Design

As we have moved through our application design, we have been primarily focussing on the desktop display of our application.  While I have occasionally made some small brush-ups to our mobile UI, it has never received anything but afterthought treatment.  

As we prepare to launch, we should consider the users who might have their first impression of our application on a mobile phone.  While we may never expect a user to read an entire book on a phone screen, I do want to be sure anyone landing on our content seeking a quick answer from a Google search has a reasonable ability to digest our materials.

We are going to refactor our application layout a bit.  Using some components provided by Semantic UI, we can conditionally render elements of our application based on the resolution of the device window digesting our content.

## Jumping in Here

If you have not been following along with code examples and wanted to jump in here, you can use our [Chapter15Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter15Starter) branch as a place to join in.

## Responsive Design Tools

Before we dive in, I should note that the approach I am taking to introduce a responsive design to our application is one of many possibilities.  There is nothing, for example, that precludes you from using device-specific CSS, or media queries to implement an entirely CSS based solution to manage your device breakpoints.  

However, I want to explore the use of Semantic UI's responsive design features in the hope we can implement a more React-centric solution.  Our components, for the most part, are carrying internal styling instructions (as opposed to leveraging external CSS).  Shipping our responsive support via components as well should help us keep our components as freestanding, reusable units of our UI.

## Beginning with Semantic UI Responsive

Before we start a wholesale redesign of our application interface, let's first dig into Semantic UI's `Responsive` component.  We can start by reworking one very isolated piece of our design: our code examples.

This component is facing several issues with its small-screen rendering.  Take a look:

![Current mobile code block rendering, which incorrectly wraps tittle/tools line and minimizes content area to unacceptable width.](/images/15/flawedMobileCodeBlock.png)

Our title bar for the code example is running wider than our screen resolution can accommodate.  This overflow causes the other tools we have in this area (copy, minimize, and maximize) to wrap onto a second line.  That, in turn, causes the body of our example to render in an improper width.

Let's start our redesign by altering the displayed title for mobile devices.  If the screen-type of our user is a phone, we can print only the file name, and otherwise show the entire file path.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

const blockHeaderStyles = {
  borderBottom: "3px double #021a40",
  backgroundColor: "#021a40",
  color: "#fff",
  padding: "5px 10px 5px 20px",
  textOverflow: "ellipsis"
};

class CodeHeader extends Component {
  constructor(props){
    super(props);
+     let path_segments = props.block_path.split("/");
+     this.block_file = path_segments[path_segments.length - 1];
  }
  
  render() {
    return (
      <div style={blockHeaderStyles}>
+         <Responsive as="span" {...Responsive.onlyMobile}>{this.block_file}</Responsive>
+         <Responsive as="span" minWidth={Responsive.onlyMobile.maxWidth + 1}>{this.props.block_path}</Responsive>

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />

-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />

       <span ref={this.props.triggerRef}>
-           <Popup
-             trigger={
-               <Button icon size="mini" floated="right" color="grey">
-                <Icon name='copy' />
-               </Button>
-             }
-             position="bottom center" content='Copy All'
-           />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;
```

The `Responsive` component has a simple interface that runs almost entirely off of two props, `minWidth` and `maxWidth`.  Each of these props is true to their given name; allowing the child elements to render only if the screen width falls within the defined range.  The Responsive component provides listeners which monitor the browser window's resize events.  A fresh render cycle triggers whenever the window dimensions move in or out of the defined boundaries.

A static value, `Responsive.onlyMobile` provides predefined breakpoints for what Semantic UI considers a mobile device resolution (320px through 767px wide if you were curious).  There's no magic behind these presets.  If you look at the `Responsive` component's source code in the Semantic UI package, you find a set of simple objects.

``` javascript
static onlyMobile = { minWidth: 320, maxWidth: 767 }
static onlyTablet = { minWidth: 768, maxWidth: 991 }
static onlyComputer = { minWidth: 992 }
static onlyLargeScreen = { minWidth: 1200, maxWidth: 1919 }
static onlyWidescreen = { minWidth: 1920 }
```

These object definitions, combined with the spread operator, serve to give us a more intuitive interface for our component than manually defining our breakpoints: `<Responsive as="span" {...Responsive.onlyMobile}>`

We can also define our boundaries explicitly, such as the example above, where we create a component that renders for all devices except those in our mobile range: `<Responsive as="span" minWidth={Responsive.onlyMobile.maxWidth + 1}>`

That quickly brings me to two complaints I have with Semantic's approach to the Responsive component.  First, I find the provided list of static values to be on the sparse side.  We have values for onlyMobile, onlyTablet, and so on.  What about our use case above; everything except mobile? 

 I also disagree with having a defined minWidth on the `onlyMobile` preset.  Since it is the lowest boundary-set we have, if our screen resolution changes to 319px we suddenly render nothing at all.  I do not want to spend too much time worrying about users who choose to browse my site in a 200px width column.  However, I would prefer my UI not fall apart entirely due to components failing to render.

We can address both of these complaints with a constants file.

``` javascript(/client/src/constants/breakpoints.js)
import { Responsive } from 'semantic-ui-react';

export const onlyMobile = { maxWidth: Responsive.onlyMobile.maxWidth};
export const onlyTablet = Responsive.onlyTablet;
export const onlyDesktop = Responsive.onlyComputer;
export const onlyLarge = Responsive.onlyLargeScreen;
export const onlyWide = Responsive.onlyWidescreen;

export const aboveMobile = {minWidth: onlyMobile.maxWidth + 1};
export const aboveTablet = {minWidth: onlyTablet.maxWidth + 1};
export const aboveDesktop = {minWidth: onlyDesktop.maxWidth + 1};

export const belowTablet = {maxWidth: onlyTablet.minWidth - 1};
export const belowDesktop = {maxWidth: onlyDesktop.minWidth - 1};
export const belowLarge = {maxWidth: onlyLarge.minWidth - 1};
```

We are defining variations of the default values `Responsive` provides, that way we do not need to call our breakpoints from two separate locations.  This change also gives us the opportunity to do some fine tuning, such as removing the `minWidth` restriction from our `onlyMobile` value.  

I am also renaming the default `onlyComputer` to `onlyDesktop`.  This change is my preferences showing through; when I think of three-screen designs, I refer to them as mobile, tablet, and desktop; not mobile, tablet, and computer.  Nitpicky, but I do not want to be reaching for the wrong keyword.

We can also use this file to define new default sets, and I am adding in `aboveDEVICE` and `belowDEVICE` values.  That way, we can quickly declare content by groups containing several device formats.  These new ranges use a +/- modification on the default screen breakpoints provided by the `Responsive` class to define a new range.

Now that we have these new values let's refactor our component to make use of them.  I am also going to use this opportunity to break our file title into a freestanding component.  I want my top level component to be readable at a glance.  Rather than allowing it to handle the minutia of `Responsive` changes directly, we can set up a new `FilePath` component, and let that new child manage the details of what we render for each device.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
  filePath: {
    fontSize: ".9em",
    display: "inline-block",
  },
  limitedTitle: {
    display: "inline-block",
    width: "125px",
    textOverflow: "ellipsis",
    overflow: "hidden"
  }
};

class CodeHeader extends Component {
  render() {
    let { block_path } = this.props;
    return (
      <div style={styles.blockHeaderStyles}>
+         <FilePath block_path={block_path} />
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(false)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='plus' />
-             </Button>
-           }
-           position="bottom center" content='Expand All'
-         />
        
-         <Popup
-           trigger={
-             <Button onClick={()=>this.props.collapseHandler(true)}
-             icon size="mini" floated="right" color="grey">
-               <Icon name='minus' />
-             </Button>
-           }
-           position="bottom center" content='Collapse All'
-         />
        
        <span ref={this.props.triggerRef}>
-           <Popup
-             trigger={
-               <Button icon size="mini" floated="right" color="grey">
-                <Icon name='copy' />
-               </Button>
-             }
-             position="bottom center" content='Copy All'
-           />
        </span>
      </div> 
    );
  }
}

export default CodeHeader;

export class FilePath extends Component {
  constructor(props){
    super(props);
    let path_segments = props.block_path.split("/");
    this.block_file = path_segments[path_segments.length - 1];
    this.block_path = this.props.block_path;
  }
  
  render() {
    let { block_file, block_path } = this;
    return(
      <div style={styles.filePath}>
        <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
        <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
      </div>
    );
  }
}
```

Notice in the example above I have refactored our CSS styles to all be children of a single `styles` object.  Moving forward, as we refactor our application for its first launch, I plan to use this pattern to define all the styles of my components.  This change allows me to consolidate all our styles into a single declaration, and also makes our components more readable by clearly indicating we are calling a style object when we access these elements.

## Semantic UI Controlled Components

We are on the right track, but we have some other problems we need to address, even in this code header area.  As we set up views for our mobile devices, we need to also acknowledge the differences in input methods between our desktop, mobile, and tablet users.  

Look at our icon buttons in the headers of our code examples.  On a desktop device, the hover state of our buttons triggers a `Popup` to display, providing a tooltip for each action in our controls.  A touch event does not have a hover state.  Instead, this `Popup` element triggers on our mobile touch event and then linger onscreen.

![Example of tap events that leave a lingering label element onscreen until a subsequent tap moves focus off the element](/images/15/lingeringTapEventLabels.png)

Most of our work with Semantic UI thus far has relied on automatically controlled components; sensible defaults shipped to handle events related to each element.  However, when we have specialized use cases like this, we might need to intercede and take more direct control.  Luckily, Semantic UI makes this easy for us.
 Automatically controlling any elements we do not provide explicit instructions for, and getting out of our way when we intercede.

To begin, let's do another refactor of our `CodeHeader` component to migrate our control buttons into a standalone component.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

class CodeHeader extends Component {
  render() {
+     let { block_path, collapseHandler, triggerRef } = this.props;
    return (
      <div style={styles.blockHeaderStyles}>
        <FilePath block_path={block_path} />
+         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
+         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
+         <span ref={triggerRef}>
+           <HeaderControlButton icon="copy" label="Copy All" />
+         </span>
      </div> 
    );
  }
}

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
  render() {
    let { handler, icon, label } = this.props;
    return(
      <Popup
        trigger={
          <Button className={icon} onClick={handler}
          icon size="mini" floated="right" color="grey">
            <Icon name={icon} />
          </Button>
        }
        position="bottom center" content={label}
      />
    );
  }
}
```

Given the code overlap in our control buttons, we likely should have already undertaken this refactor.  However, the case is even stronger now, since externalizing these controls as a component saves us having to write repetitive open and close events for each button.  

One more item before we move on though, have a look at the span wrapping our "Copy All" button: `<span ref={triggerRef}>`

If you remember our earlier chapter, we needed to wrap this button in another element to locate a reference to the specific DOM node our user was interacting with during their click.  That way, we could determine which specific code example should copy to the user's clipboard.  However, as we transition these controls to a component, it's increasingly less clear why this one button needs wrapping, and others do not.

There's no need for our ref to be immediately around the triggering button of our event.  We can use a CSS query selector to target the specific element we need.  With that in mind, I am going to move our ref up to the containing `div`, and modify the function to select the specific button we need based on the className we added in the last refactor.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

class CodeHeader extends Component {
  render() {
    let { block_path, collapseHandler, triggerRef } = this.props;
    return (
+       <div style={styles.blockHeaderStyles} ref={triggerRef}>
        <FilePath block_path={block_path} />
        <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
        <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
+         <HeaderControlButton icon="copy" label="Copy All" />
      </div> 
    );
  }
}

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

- export class HeaderControlButton extends Component {
-   render() {
-     let { handler, icon, label } = this.props;
-     return(
-       <Popup
-         trigger={
-           <Button className={icon} onClick={handler}
-           icon size="mini" floated="right" color="grey">
-             <Icon name={icon} />
-           </Button>
-         }
-         position="bottom center" content={label}
-       />
-     );
-   }
- }
```

We also need to update the function that manages this ref in our `CodeBlock` component.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import clipboardJS from 'clipboard'
import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

- const codeBlockStyle = {
-   marginBottom: "16px"
- };

- const blockBodyStyle = {
-   padding: "10px 0",
-   border: "1px solid #021a40",
-   backgroundColor: "#f8f8f8",
-   overflowX: "scroll"
- };

class CodeBlock extends Component {
-   constructor(props){
-     super(props);
-     this.code_fence = new CodeFence(props.node);
-   }
  
-   renderHeaderIf = (block_path) => {
-     if(block_path){ return( 
-       <CodeHeader 
-         block_path={this.code_fence.block_path} 
-         collapseHandler={this.collapseSections}
-         triggerRef={(trigger) => this.triggerCopy = trigger} 
-       />
-     )}
-   };
  
-   renderCodeSections = (sections) => {
-     this.section_refs = [];
-     return Array.from(sections, s => {
-       return(
-         <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type} priority={s.priority}
-         contents={s.contents} key={s.section_id} section_id={s.section_id} />
-       );
-     });
-   };
  
  componentDidMount(){
    if(this.triggerCopy){
+       let button = this.triggerCopy.querySelector("button.copy");
      return new clipboardJS(button, {
        text: () => this.code_fence.copy
      });
    }
  }
  
-   collapseSections = (bool) => {
-     this.section_refs.forEach((ref) => {
-       if(ref){ ref.setCollapse(bool) }
-     });
-   };
  
-   render() {
-     return (
-       <div style={codeBlockStyle} key={"code_fence_" + this.props.node.id}
-       id={"code_block_" + this.code_fence.node_id} className={"language-"+this.code_fence.block_type}>
-         { this.renderHeaderIf(this.code_fence.block_path) } 
-         <div style={blockBodyStyle}>
-           { this.renderCodeSections(this.code_fence.sections) }
-         </div>
-       </div>
-     );
-   }
}

export default CodeBlock;
```

Now we are ready to expand our mobile device functionality on these controls.

### Handling Defaults on Controlled Components

We can begin our transition to a controlled `Popup` component by rebuilding behaviors that mirror our existing defaults.  To do this, we need to track an open/closed state on the component and define an open and close handler to manage the transitions between states.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

- class CodeHeader extends Component {
-   render() {
-     let { block_path, collapseHandler, triggerRef } = this.props;
-     return (
-       <div style={styles.blockHeaderStyles} ref={triggerRef}>
-         <FilePath block_path={block_path} />
-         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
-         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
-         <HeaderControlButton icon="copy" label="Copy All" />
-       </div> 
-     );
-   }
- }

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
+   state = { isOpen: false };
+   
+   handleOpen = (e,data) => {
+     this.setState({ isOpen: true });
+   }
+   
+   handleClose = () => {
+     this.setState({ isOpen: false });
+   }
  
  render() {
    let { handler, icon, label } = this.props;
    return(
      <Popup
+         on={["click","hover"]}
+         open={this.state.isOpen}
+         onClose={this.handleClose}
+         onOpen={this.handleOpen}
        trigger={
          <Button className={icon} onClick={handler}
          icon size="mini" floated="right" color="grey">
            <Icon name={icon} />
          </Button>
        }
        position="bottom center" content={label}
      />
    );
  }
}
```

We are adding four new props to our Semantic UI `Popup` component; `on`, `open`, `onOpen`, and `onClose`.  The `on` prop instructs our component to fire an open or close event for specific user actions (click and hover in this case).  

Those events will in turn fire the defined `onOpen` or `onClose` event handlers, depending on the component's current state.  The handler functions themselves invoke `this.setState` to change the `isOpen` value to show or hide our message.

Reload your application, and you should see we have rebuilt our existing functionality.  Still, what is the point in all this extra code? 
Especially if it is only boilerplate that restores Semantic UI's defaults.

Now that we have verbosely defined how the component state changes, we can extend beyond defaults.  Our problem with lingering popup messages still plagues our UI.  However, we can now manage that specific scenario by writing a dedicated handler for touch events. To do this, we need to wrap our Semantic UI `Popup` in another element; that way can manage an event it does not have explicit support for `onTouchStart`.  We can use this event to set a timer, and automatically clear our popups after the countdown elapses.

``` javascript(/client/src/components/nodes/code_header.js)
import React, { Component } from 'react';
import { Responsive, Popup, Button, Icon } from 'semantic-ui-react';

import * as BREAKPOINTS from '../../constants/breakpoints';

- const styles = {
-   blockHeaderStyles: {
-     borderBottom: "3px double #021a40",
-     backgroundColor: "#021a40",
-     color: "#fff",
-     padding: "5px 10px 5px 20px",
-   },
-   filePath: {
-     fontSize: ".9em",
-     display: "inline-block",
-   },
-   limitedTitle: {
-     display: "inline-block",
-     width: "125px",
-     textOverflow: "ellipsis",
-     overflow: "hidden"
-   }
- };

- class CodeHeader extends Component {
-   render() {
-     let { block_path, collapseHandler, triggerRef } = this.props;
-     return (
-       <div style={styles.blockHeaderStyles} ref={triggerRef}>
-         <FilePath block_path={block_path} />
-         <HeaderControlButton handler={()=>collapseHandler(false)} icon="plus" label="Expand All" />
-         <HeaderControlButton handler={()=>collapseHandler(true)} icon="minus" label="Collapse All" />
-         <HeaderControlButton icon="copy" label="Copy All" />
-       </div> 
-     );
-   }
- }

export default CodeHeader;

- export class FilePath extends Component {
-   constructor(props){
-     super(props);
-     let path_segments = props.block_path.split("/");
-     this.block_file = path_segments[path_segments.length - 1];
-     this.block_path = this.props.block_path;
-   }
-   
-   render() {
-     let { block_file, block_path } = this;
-     return(
-       <div style={styles.filePath}>
-         <Responsive as="span" {...BREAKPOINTS.onlyMobile}><span style={styles.limitedTitle}>{block_file}</span></Responsive>
-         <Responsive as="span" {...BREAKPOINTS.aboveMobile}>{block_path}</Responsive>
-       </div>
-     );
-   }
- }

export class HeaderControlButton extends Component {
  state = { isOpen: false };
  
  handleOpen = (e,data) => {
    this.setState({ isOpen: true });
+     if(e.type === "click") this.handleTimeout();
  }
  
+   handleTimeout = (e) => {
+     this.timeout = setTimeout(() => {
+     this.setState({ isOpen: false });
+     }, 400);
+   }
  
  handleClose = () => {
    this.setState({ isOpen: false });
+     clearTimeout(this.timeout);
  }
  
  render() {
    let { handler, icon, label } = this.props;
    return(
+       <span onTouchStart={this.handleTimeout}>
        <Popup
          on={["click","hover"]}
          open={this.state.isOpen}
          onClose={this.handleClose}
          onOpen={this.handleOpen}
          trigger={
            <Button className={icon} onClick={handler}
            icon size="mini" floated="right" color="grey">
              <Icon name={icon} />
            </Button>
          }
          position="bottom center" content={label}
        />
+       </span>
    );
  }
}
```

Now when a user taps a control on a touch device, we have a `timeout` value set on our component which resolves after 400ms.  We either let this timer run its course naturally or clear it explicitly if a different event closes the `Popup`.

Reload your application on a mobile device, and you should see that our popup labels disappear soon after our controls are touched.  This update gives the user a brief flash of text to reinforce and validate the functionality of each button in our UI.  It does not allow content to linger on our valuable mobile screen real-estate.

That's all for now.  Mobile phone are still probably far from ideal for consuming our content, but we've done what we can to ensure that our content presents as gracefully as we can manage.  Now, let us move on to the larger UI itself.

## Responsive Global Navigation

We focused in on our code examples for a manageable place to start.  But that ignored that our entire mobile layout could use some serious poslish, particularly where our top-level navigation bar is concerned.

![Mobile navigation menus exceed device width, causing them to stack and steal valuable screen space from our reading area. ](/images/15/mobileNavigationMenusPre.png)

In an earlier chapter, I used a setting provided by Semantic UI `stackable` as a lazy "solution" for making our navigation menus responsive to smaller screen widths. With this setting toggled on, the individual components of our nav can stack once they no longer have room to render side by side.  I also didn't waste much time cleaning up our visual presentation.  This approach though causes our navigation bar to grow taller as the device gets narrower, stealing valuable screen realestate from our reading area.

Let's rework this area so that we can keep out top-navigation bar on a single line.  To do this, I am going to remove our chapter selection dropdown menu on mobile phones, and instead offer a popout menu that will be available accross all devices for chapter navigation.  We are also going to rework our titles, and logos as part of this revision.

In my early chapters, when I was unsure I would see this project through to the end, I used the React and Rails logos as a placeholder.  Now that I am nearing a launch for the final product though, I am ready to commit a few dollars and a little time to having a logo made for our design.  You can download this updated asset here: [reactivating-rails-logo-small.png](http://www.sometotallylegiturl.com)

To begin, let's do some cutting in our application stylesheet.  Right now we have several rules targetting this global navigation menu, including some media specific CSS rules.  I don't want these rules influencing my design as I try to rework it, so let's clean them out.  As with our earlier refactors, we are going to try to push as much CSS as possible into our componenets.

``` css(/client/src/App.css)
img {max-width: 100%;}
#main-section {margin-top: 65px;}
#reader-pane img {border: 1px solid #021a40;}

code {
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
  padding: 0.2em .5em;
  margin: 0;
  font-size: 85%;
}
.codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
.codeGutter .fa { font-size: 12px; opacity: 0; }
.lowPrioritySection .fa { opacity: 100; }
.lowPrioritySection { cursor: pointer; } 
.highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }
pre {white-space: pre-wrap; margin: 0;}
```

Now let's take a look and the `MenuBar` component.  We can bring our redesign by stripping out the old logos, and replacing them with the new.  We will also refactor our CSS style objects as we did in earlier chapters.  Adding a responsive tag around our dropdown menu will prevent it from rendering on our mobile devices (using the `aboveMobile` breakpoint we set up earlier in this chapter).

I am also reworking many of the components we leverages from Semantic UI; in genral I am trying to strip out custom CSS where I can, to better leverage SUI native settings.  I won't be detailing each of these changes, as we've covered SUI in depth at this point.  You may therefore want to copy/paste this example code into your own codebase.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import reactivatingRailsLogo from '../assets/images/reactivating-rails-logo-small.png';

import * as BREAKPOINTS from '../constants/breakpoints';
import { ConnectedChapterMenuItems } from '../containers/chapter_provider';
import { ConnectedUserBadge } from '../containers/user_provider';

const styles = {
  fixedMenuStyle: {
    backgroundColor: '#fff',
    border: '1px solid #ddd',
    boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
    paddingLeft: "1em",
    paddingRight: "1em"
  },
  menuIcon: {margin: "0"},
  logo: {
    margin: "auto 1.5em", 
    maxWidth: "230px",
    verticalAlign: "middle"
  }
};

class MenuBar extends Component {
  render() {
    let { active_chapter } = this.props;
    return (
        <Menu id="menu_bar" size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item fitted name='Main Menu'>
              <Icon style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={reactivatingRailsLogo} />
            <Menu.Menu position='right'value={active_chapter}>
+               <Responsive {...BREAKPOINTS.aboveMobile } >
+                 <ConnectedChapterMenuItems />
+               </Responsive>
              <ConnectedUserBadge />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

I've also done some small refactor to other sub-componenets inside our global naigation bar.  Copy these changes into your application as well so that you are ready to move forward with building our new navigation menu.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import ConnectedGitHubIcon from './github_icon';

const styles ={
  profile: {
    maxHeight: "32x",
    maxWidth: "32px",
    marginLeft: "1.757px"
  }
};

class UserBadge extends Component {
  render() {
    return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
  }
}

class ProfileIcon extends Component {
  render() {
    let { username, avatar, dispatchSignalSignout } = this.props;
    let badge = <Image src={avatar} avatar style={styles.profile}/>;
    return (
      <Menu.Item name={username} fitted>
        <Dropdown icon={badge} compact pointing="top right">
          <Dropdown.Menu>
            <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
          </Dropdown.Menu>
        </Dropdown>
      </Menu.Item>
    );
  }
}

export default UserBadge;
```

``` javascript(/client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';
import routeProvider from '../containers/route_provider';

const styles = {
  githubIcon: {marginRight: 0}
};

class GithubIcon extends Component {
  buildRedirect = (loc = this.props.location) => {
    let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
    return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
  }
  
  render() {
    let rd = this.buildRedirect();
    return (
      <Menu.Item 
        href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd}
        name='Sign in with GitHub'
        fitted
      >
        <Icon name='github' style={styles.githubIcon} size="big" />
      </Menu.Item>
    );
  }
}

const ConnectedGitHubIcon = routeProvider(GithubIcon);
export default ConnectedGitHubIcon;
```

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';

const styles = {
  dropdown: {margin: "0 1em"}
};

export default class ChapterMenuItems extends Component {
  renderChapterOptions = () => {
    let { active_chapter, chapters } = this.props;
    let chapters_list = [];
    chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
          active: chapter.id === active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
    let { active_chapter, dispatchRouteChapter } = this.props;
    return( 
        <Dropdown 
          pointing="top right"
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          style={styles.dropdown}
          selectOnNavigation={false}
          value={active_chapter.id}
          text={active_chapter.title}
          onChange={dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Reload your application and your mobile rendering should look like the following screenshot
![Updated single-line mobile navigation menu.](/images/15/mobileNavigationMenusPost.png)

### Roughing in SideBar Navigation

Adding a secondary side navigation bar will be a major revision to our appplication.  So before we start worrying about the details of populating the menu with real content, or controlling the componenet's state I would like to get our UI presentation planned out.  Let's take a first pass at adding in this new element with sample content pulled from the Semantic UI React documentation.

To start this process, let's add a new component to our top level `App` container.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
+ import SideBarPopout from './components/side_bar_popout';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <SideBarPopout />
        <MenuBar />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

Now we can actually define out that new child component with some draft content.

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

const styles = {
  popoutLayer: {
    position: "fixed",
    top: "0px",
    left: "0px",
    maxHeight: "150vh",
    minWidth: "100vw",
    zIndex: 100
  },
  pusher: { minHeight: "100vh", minWidth: "100vw" },
  sideBar: { maxWidth: "320px", maxHeight: "100vh", paddingTop: "45px" }
};

class SideBarPopout extends Component {
  render() {
    return (
      <div style={styles.popoutLayer}>
        <Sidebar.Pushable style={styles.pusher}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={true} icon='labeled' 
          style={styles.sideBar} inverted vertical>
-             <Menu.Item name='home'>
-               <Icon name='home' />
-               Home
-             </Menu.Item>
-             <Menu.Item name='gamepad'>
-               <Icon name='gamepad' />
-               Games
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
-             <Menu.Item name='camera'>
-               <Icon name='camera' />
-               Channels
-             </Menu.Item>
            <Menu.Item name='cancel'>
             <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher style={styles.pusher} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout;
```

Most of our menu's actual content is trival at this point, our buttons are all simple mockups, and even with those, I plan to rework our layout.  What is most import to me at this point is having enough content to overflow the screen on the smallest device I plan to support, the iPhone 5/SE device, which has a screen resolution of 320x568.  

Sincce we already have fixed position elements in our layout, it seems appropriate to take a similar approach with our sidebar.  We are setting up a new layer in `div` tag, and using a z-index value of 100 to position the element in our vertical stack so that it lay overtop of the najority of our content, while still being underneath our top-level navigation.  We are also making heavy use of CSS viewport height and width units, to ensure this element when it is visible occupies the entire screen space with either it navigation menu, or the dimmer layer.

Finally we set specific `overflowY` instructions on the element that actually renders our navigation buttons.  this way, we can offer a scrollbar for this menu when it's contents overflow the devices screen space.

### Self Contained State

Now that we have the basics of our UI outlined, let's make a connection to our state so that we can begin working out the details of our component that are self-contained.

Modify your `chapter_provider` container to export a connected sidebar component.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterMenuItems from '../components/chapter_menu_items';
import ChapterFooter from '../components/chapter_footer';
import SideBarPopout from '../components/side_bar_popout';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

const chapterProvider = (WrappedComponent) => {
  return class extends React.Component {
    render(){
      if(this.props.chapters !== []){
        return <WrappedComponent {...this.props} active_chapter={this.props.active_chapter || -1} />;
      } else {
        return null;
      }
    }
  };
};

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterMenuItems = connectToChapters(ChapterMenuItems);
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
+ export const ConnectedChapterSideBar = connectToChapters(SideBarPopout);
```

And be sure to also update your `App` component to use this new connected component as well.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
import { ConnectedChapterSideBar } from './containers/chapter_provider';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <ConnectedChapterSideBar />
        <MenuBar />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

Now we can start adding in some local state for this component.  Rather than hard wiring the component to be visible at all times, we can set up a value in our state to track the open/close of the menu.  We shoud toggle the menu's state to closed anytime a user clicks a link, explicitly clicks our "close" button, or clicks somewhere withing our dimmer.  

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

const styles = {
-   popoutLayer: {
-     position: "fixed",
-     top: "0px",
-     left: "0px",
-   },
  pusher: { minHeight: "100vh", minWidth: "100vw" },
-   sideBar: { 
-     minWidth: "320px",
-     maxWidth: "320px",
-     minHeight: "100vh",
-     maxHeight: "100vh",
-     paddingTop: "45px", 
-     zIndex: 100
-   }
};

class SideBarPopout extends Component {
  state = { visible: true };
  
  toggleVisibility = (bool) => {
    let vis = bool === undefined ? !this.state.visible : bool;
    this.setState({ visible: vis});
  };
  
  handleLink = (e,t) => {
    this.props.dispatchRouteChapter(e,t);
    this.toggleVisibility();
  };
  
  handleCloseClick = () => this.toggleVisibility();
  
  renderChapterLinks = () => {
    let { chapters } = this.props;
    return chapters.map((chapter)=>{
      let key = "chapter"+chapter.id;
      return(
        <Menu.Item link={true} onClick={this.handleLink}
        name={key} key={key} value={chapter.id}>
          {chapter.title}
        </Menu.Item>
      );
    });
  };
  
  render() {
    let { visible } = this.state;
    return (
      <div style={styles.popoutLayer} onBlur={this.handleBlur}>
        <Sidebar.Pushable style={visible ? styles.pusher : null}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={visible} icon='labeled' 
          style={styles.sideBar} inverted vertical>
            { this.renderChapterLinks() }
            <Menu.Item link={true} onClick={this.handleCloseClick} name='cancel'>
              <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher onClick={this.handleCloseClick} style={visible ? styles.pusher : null} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout
```

You should be comfortable with this code from previous examples.  We're adding in a new function to print out chapter links for each item in our `chapters` state, and leverage the `dispatchRouteChapter` function offered by our `connectToChapters` function to handle the page changes for these link items.  We also add in a `toggleVisibility` method to handle changes in the state, and use this accross several elements of the UI we mentioned above to trigger the menu to close.  

Notice that in several places we also use conditionally assign styles from `styles.pusher` to be applied only if the component is in its visible state.  This is done because the way I am using Semantic UI's `Sidebar` component is perhaps a slight departure from it's intended use.  Rather than leveraging this component inside an existing content layer of our application, we are drawing the Sidebar as a fixed position element, and using CSS to ensure that layer occupies the entire screen, and sits on a higher z-index than other other content.

Without the conditional CSS, our menu would continue to overlap the entire screen, even in its `visible == false` state.  That overlap, interferes with our ability to scroll on the underlying elements, particularly on mobile devices where we more often need horizontal scrolling inside our code examples.  To aleviate this problem, we're assigning a minimum height and width to this menu only when it is in it's visible state (when we want it to block underlying elements), and then allowing the element to collapse to a width of 0px when it is invisible, restoring our ability to interact with other elements.

Take a look at your desktop rendering, and you should see the following:
![Desktop sidebar rendering with early chapter links, and close events managed for all of the component's internal elements.](/images/15/desktopEarlySidebarRender.png)

Now that we have the internals figured out, we need to address the controls that live outside of our component.  Most notably, the menu button in our top navigation bar.

### Updating to React 16x

Before I move forward, I want to upgrade my local React package to the latest release (16.3.1 at the time of writting).  You may not need to do this step depending on what you installed in your initial setup of your application.  However, in the time I have been working on this book, React 16 was released, making available a new method `React.createRef` I would like to leverage to manage our state accross our two navigation menus.

Luckily, there are no breaking changes between 15.6.x release of React (my current version), and 16x version of React.  To update, I can quickly run the following commands in npm from my client directory.

``` bash
docker-compose exec client yarn add react@latest
docker-compose exec client yarn add react-dom@latest
```

Be sure to update `react-dom` as well, as your version should always match what you use for the primary `react` package.

### Managing Reference Layers

We are going to refactor our two navigation components that need to share references to one another so that each is included by a single parent component.  We will use this new layer to manage the references needed to invoke state changes accross the two components. 

First, let's create the new component.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
  render() {
    return [
        <SideBarPopout {...this.props} key="sidebar" />,
        <MenuBar {...this.props} key="menubar" />
    ];
  }
}

export default NavigationMenus;
```

We are leveraging another new feature of React 16 in this component, and returning an Array of elements in our render method. Historically we would have needed to wrap these components in a single containing element like a `div` to draw them both from a single parent component.  Now, React 16 will let us render a collection so long as we provide a unique `key` attribute for each member.  We saw this pattern in earlier iterations when we populated our dropdown menus, but until React 16 we could not use this same approach in the `render` method of a component.  Now we can, and it saves us adding an otherwise useless `div` to our DOM.

Now let's update out `chapter_provider` to connect this parent element to our state.  Notice in the example above, when we had our new `NavigationMenus` parent render each child menu, we passed through all of the aprent's props with the spread opperator.  This means we no longer need to individually connect each child menu to our store.  We will strip out this connection as we make our other updates.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

- const chapterProvider = (WrappedComponent) => {
-   return class extends React.Component {
-     render(){
-       if(this.props.chapters !== []){
-         return <WrappedComponent {...this.props} active_chapter={this.props.active_chapter || -1} />;
-       } else {
-         return null;
-       }
-     }
-   };
- };

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
+ export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

We can also update our App component to leverage this new layer of abstraction.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
+ import { ConnectedNavigationMenus } from './containers/chapter_provider';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
+         <ConnectedNavigationMenus />
        <Container text id="main-section">
          <ApplicationAlerts />
          <ConnectedRouterSwitch />
        </Container>
      </div>
    );
  }
}

export default App;
```

We also need to refactor our `GithubIcon` component to rework the way we connect to the store.  We'll adapt this component and its partner `routerProvider` to move our creation of the `ConnectedGitHubIcon` component into the container so it matches the way we are exporting similar elements.

``` javascript(/client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';

- const styles = {
-   githubIcon: {marginRight: 0}
- };

- class GithubIcon extends Component {
-   buildRedirect = (loc = this.props.location) => {
-     let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
-     return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
-   }
-   
-   render() {
-     let rd = this.buildRedirect();
-     return (
-       <Menu.Item 
-         href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd}
-         name='Sign in with GitHub'
-         fitted
-       >
-         <Icon name='github' style={styles.githubIcon} size="big" />
-       </Menu.Item>
-     );
-   }
- }

+ export default GithubIcon;
```

``` javasccript(/client/src/containers/route_provider.js)
import { connect } from 'react-redux';
import RouterSwitch from '../components/router_switch';

import GithubIcon from '../components/github_icon';

- const routerProvider = (WrappedComponent = RouterSwitch) => {
-   let mapStateToProps = (state) => ({
-     location: state.location
-   });
-   
-   return connect(mapStateToProps,null)(WrappedComponent);
- };

export default routerProvider;

+ // EXPORTABLE CONNECTED COMPONENTS
+ export const ConnectedGitHubIcon = routerProvider(GithubIcon);
```

And we'll need to update `UserBadge` to leverage this new pattern.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

+ import { ConnectedGitHubIcon } from '../containers/route_provider';

- const styles ={
-   profile: {
-     maxHeight: "32x",
-     maxWidth: "32px",
-     marginLeft: "1.757px"
-   }
- };

class UserBadge extends Component {
  render() {
+     return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
  }
}

- class ProfileIcon extends Component {
-   render() {
-     let { username, avatar, dispatchSignalSignout } = this.props;
-     let badge = <Image src={avatar} avatar style={styles.profile}/>;
-     return (
-       <Menu.Item name={username} fitted>
-         <Dropdown icon={badge} compact pointing="top right">
-           <Dropdown.Menu>
-             <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
-           </Dropdown.Menu>
-         </Dropdown>
-       </Menu.Item>
-     );
-   }
- }

export default UserBadge;
```

Finally, we should update our `MenuBar` component to reflect the changes we have made elsewhere in our application.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import reactivatingRailsLogo from '../assets/images/reactivating-rails-logo-small.png';

import * as BREAKPOINTS from '../constants/breakpoints';
+ import ChapterMenuItems from './chapter_menu_items';
import { ConnectedUserBadge } from '../containers/user_provider';

- const styles = {
-   fixedMenuStyle: {
-     backgroundColor: '#fff',
-     border: '1px solid #ddd',
-     boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
-     paddingLeft: "1em",
-     paddingRight: "1em",
-   },
-   menuIcon: {margin: "0"},
-   logo: {
-     margin: "auto 1.5em", 
-     maxWidth: "230px",
-     verticalAlign: "middle"
-   }
- };

class MenuBar extends Component {
  render() {
    let { active_chapter } = this.props;
    return (
        <Menu id="menu_bar" size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item fitted name='Main Menu'>
              <Icon style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={reactivatingRailsLogo} />
            <Menu.Menu position='right'value={active_chapter}>
              <Responsive {...BREAKPOINTS.aboveMobile } >
+                 <ChapterMenuItems {...this.props} />
              </Responsive>
              <ConnectedUserBadge />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Since our MenuBar is itself now recieving our `store.chapters` state as props passed through a connected parent component, it seems very silly to have our `ChapterMenuItems` component connecting to the same state directly.  Instead we can rework this component to also accept the data it needs as props from its parent `MenuBar`.

## Working with Refs

We are now ready to add in our refs, and handle the cross-component triggering of our menu.  I am going to centralize as much of this work as I can in our new `NavigationMenus` component.  That way, if in the fututre we want this component to manage additional children, we can push similar behaviors to other ares of our application.

To begin, let's create our refs.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
  constructor(props){
    super(props);
+     this.sideBarRef = React.createRef();
  }
  
+   handleSidebarVisibility = (e,t) => {
+     this.sideBarRef.current.toggleVisibility();
+   };
  
  render() {
    return [
+         <SideBarPopout ref={this.sideBarRef} {...this.props} key="sidebar" />,
+         <MenuBar handleSidebarVisibility={this.handleSidebarVisibility} {...this.props} key="menubar" />
    ];
  }
}

export default NavigationMenus;
```

Above, we create a new ref under the name `sideBarRef`, and assign it to our `SideBar` component.  When we assign a ref to a custom component built as a React Class, the ref will return a specific instance of the class under `sideBarRef.current` anywhere else it is accessed.  This allows us to access method of the class directly from other areas of our application.  (Note: this pattern cannot be used with Functional components).

We set up a new method to handle triggering of our sidebar to open and close, inside the method `handleSidebarVisibility`.  Passing this method to our child compoent `MenuBar` will allow us to trigger the `SideBar.toggleVisibility` visibility functionality.

Let's look at that assignment.

``` javascript(/client/src/components/menu_bar.js)
import React, { Component } from 'react';
import { Container, Image, Menu, Icon, Responsive } from 'semantic-ui-react';
import reactivatingRailsLogo from '../assets/images/reactivating-rails-logo-small.png';

import * as BREAKPOINTS from '../constants/breakpoints';
import ChapterMenuItems from './chapter_menu_items';
import { ConnectedUserBadge } from '../containers/user_provider';

const styles = {
  fixedMenuStyle: {
    backgroundColor: '#fff',
    border: '1px solid #ddd',
    boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
    paddingLeft: "1em",
    paddingRight: "1em",
+     maxWidth: "100vw"
  },
-   menuIcon: {margin: "0"},
-   logo: {
-     margin: "auto 1.5em", 
-     maxWidth: "230px",
-     verticalAlign: "middle"
-   }
};

class MenuBar extends Component {
  render() {
    let { active_chapter, handleSidebarVisibility } = this.props;
    return (
+         <Menu id="menu_bar" onClick={handleSidebarVisibility} size="huge" borderless fixed="top" style={ styles.fixedMenuStyle }>
          <Container>
            <Menu.Item id="sideMenuButton" link={true} fitted name='Main Menu'>
              <Icon id="sideMenuIcon" style={styles.menuIcon} color="black" name='content' size="large" />
            </Menu.Item>
              <Image fluid wrapped style={styles.logo} alt="Reactivating Rails" src={reactivatingRailsLogo} />
            <Menu.Menu position='right'value={active_chapter}>
              <Responsive {...BREAKPOINTS.aboveMobile } >
+                 <ChapterMenuItems {...this.props} />
              </Responsive>
+               <ConnectedUserBadge handleSidebarVisibility={handleSidebarVisibility} />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

I want my sidebar to close anytime the user interacts with the top nevigation menu, whether that is clicking the menu button, opening our chapter dropdown, or interacting with our login/profile button.  We'll use our passed method `handleSidebarVisibility` combined with `onClick` and `onFocus` events to create this behavior.

To do this we'll need to pass that `handleSidebarVisibility` prop down into our child components as well so we can properly register it to event handlers for our other menus as well.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';

const styles = {
  dropdown: {margin: "0 1em"}
};

export default class ChapterMenuItems extends Component {
-   renderChapterOptions = () => {
-     let { active_chapter, chapters } = this.props;
-     let chapters_list = [];
-     chapters.forEach((chapter) => {
-       chapters_list.push(
-         { 
-           key: "chapter_" + chapter.id,
-           id:  "chapter_menu_item_" + chapter.id,
-           value: chapter.id,
-           text: chapter.title,
-           active: chapter.id === active_chapter.id
-         }
-       );
-     });
-     return chapters_list;
-   }
  
  render() {
    let { active_chapter, dispatchRouteChapter, handleSidebarVisibility } = this.props;
    return( 
+         <Dropdown onFocus={handleSidebarVisibility}
          pointing="top right"
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          style={styles.dropdown}
          selectOnNavigation={false}
+           selectOnBlur={false}
          value={active_chapter.id}
          text={active_chapter.title}
          onChange={dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

For our `ChapterMenuItems` component, I am using an `onFocus` handler, rather that `onClick` so that users leveraging keyboard controls to change focus also trigger our sidebar's close behavior.  I have also added a new property to the dropdown itself `selectOnBlur={false}`.  Until I began to scrutinize this area I failed to notice that bluring this menu could sometimes trigger an unintended navigation to a new chapter if the user had a selection highlighted when the dropdown unfocused.

We'll need similar tratment in our `UserBadge` component.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import { ConnectedGitHubIcon } from '../containers/route_provider';

- const styles ={
-   profile: {
-     maxHeight: "32x",
-     maxWidth: "32px",
-     marginLeft: "1.757px"
-   }
- };

- class UserBadge extends Component {
-   render() {
-     return !this.props.username ? <ConnectedGitHubIcon /> : <ProfileIcon {...this.props} />;
-   }
- }

class ProfileIcon extends Component {
  render() {
    let { username, avatar, dispatchSignalSignout, handleSidebarVisibility } = this.props;
    let badge = <Image src={avatar} avatar style={styles.profile}/>;
    return (
      <Menu.Item name={username} fitted>
+         <Dropdown closeOnBlur={true} onFocus={handleSidebarVisibility} icon={badge} compact pointing="top right">
          <Dropdown.Menu>
            <Dropdown.Item onClick={dispatchSignalSignout}>Sign Out</Dropdown.Item>
          </Dropdown.Menu>
        </Dropdown>
      </Menu.Item>
    );
  }
}

export default UserBadge;
```

We won't worry about tagging our `GithubIcon`, since clicking this element trigger offsite navigation that will completely scrap our application rendering.  But the signout menu for authenticated users should also trigger a sidebar close.  I have also added a `closeOnBlur` prop to this menu so that our signout enu doesn't linger onscreen for mobile device if the focus shifts off this element.

### Leveraging the DOM with Refs.

Have a look at your application, and you will see our behavior is almost correct.  For our menu button in the top left corner, we want the button to toggle visibility of our sidebar on/off with each click. However, other triggering events should only close the menu if it is open, not the inverse.  We can brush up our event handler code to address this issue.  Notice in the example above that I added several IDs to the sidebar menu button; `sideMenuButton` and `sideMenuIcon`.  We can use this IDs to refine our event handler's behavior.

``` javascript(/client/src/components/navigation_menus.js)
import React, { Component } from 'react';

import MenuBar from './menu_bar';
import SideBarPopout from './side_bar_popout';

class NavigationMenus extends Component {
-   constructor(props){
-     super(props);
-     this.sideBarRef = React.createRef();
-   }
  
+   handleSidebarVisibility = (e,t) => {
+     let tgl = this.sideBarRef.current.toggleVisibility;
+     ["sideMenuIcon","sideMenuButton"].includes(e.target.id) ? tgl() : tgl(false);
+   };
  
-   render() {
-     return [
-         <SideBarPopout ref={this.sideBarRef} {...this.props} key="sidebar" />,
-         <MenuBar handleSidebarVisibility={this.handleSidebarVisibility} {...this.props} key="menubar" />
-     ];
-   }
}

export default NavigationMenus;
```

## Cleaning Up Menu Contents

I'm satisfied at this point with our cross-device rendering.  To close out the chapter, I am going to make a few revision to the renderings of our menus, and add in some additional links to our sidebar when we have more room for controls.  There won't be anything beyond this point we ahven't seen before.  So follow along with the revisions if you like, or jump forward to the next chapter, and use the chapter's starter commit to fold in these revision.

Before we close out, I think we should make  sure our side navigation menu offers a full range of controls to our users.  This means adding in a signout link for authenticated users.  We can also use this revision to mark and deactivate the chapter the user is currently reading among our list of links.  

``` javascript(/client/src/components/side_bar_popout.js)
import React, { Component } from 'react';
import { Menu, Sidebar, Icon } from 'semantic-ui-react';

import { ConnectedSidebarSignOut } from '../containers/user_provider';

- const styles = {
-   popoutLayer: {
-     position: "fixed",
-     top: "0px",
-     left: "0px",
-   },
-   pusher: { minHeight: "100vh", minWidth: "100vw" },
-   sideBar: { 
-     minWidth: "320px",
-     maxWidth: "320px",
-     minHeight: "100vh",
-     maxHeight: "100vh",
-     padding: "45px 0 0 5px", 
-     zIndex: 100
-   }
- };

class SideBarPopout extends Component {
  state = { visible: false };
  
-   toggleVisibility = (bool) => {
-     let vis = bool === undefined ? !this.state.visible : bool;
-     this.setState({ visible: vis});
-   };
  
-   handleLink = (e,t) => {
-     this.props.dispatchRouteChapter(e,t);
-     this.toggleVisibility();
-   };
  
  handleCloseClick = () => this.toggleVisibility();
  
  renderChapterLinks = () => {
    let { chapters, active_chapter } = this.props;
    return chapters.map((chapter)=>{
      let key = "chapter"+chapter.id;
+       let status = chapter.id === active_chapter.id;
      return(
+         <Menu.Item link={!status} onClick={this.handleLink} disabled={status}
+         name={key} key={key} value={chapter.id}>
          {chapter.title}
        </Menu.Item>
      );
    });
  };
  
  render() {
    let { visible } = this.state;
    return (
      <div style={styles.popoutLayer} onBlur={this.handleBlur} id="sideBarPopout">
        <Sidebar.Pushable style={visible ? styles.pusher : null}>
          <Sidebar as={Menu} animation='overlay' width='wide' visible={visible} 
          style={styles.sideBar} inverted vertical>
            { this.renderChapterLinks() }
+             <ConnectedSidebarSignOut handleCloseClick={this.handleCloseClick} />
            <Menu.Item link={true} onClick={this.handleCloseClick} name='Close Menu'>
              <div><Icon name='cancel' />Close Menu</div>
            </Menu.Item>
          </Sidebar>
          <Sidebar.Pusher onClick={this.handleCloseClick} style={visible ? styles.pusher : null} dimmed />
        </Sidebar.Pushable>
      </div>
    );
  }
}

export default SideBarPopout;
```

We should set this specialized link up as a new component, so that we can connect just this one component's rendering to our user state in Redux.

``` javascript(/client/src/components/side_bar_signout.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';

const styles = {signout: {color: "#cc0000"}}

class SideBarSignout extends Component {
  handleSignout = () => {
    this.props.handleCloseClick();
    this.props.dispatchSignalSignout();
  };
  
  render() {
    let { username } = this.props;
    if(username){
      return (
        <Menu.Item link={true} onClick={this.handleSignout} name='Sign Out'>
          <div style={styles.signout}><Icon name='cancel' />Sign Out</div>
        </Menu.Item>
      );
    } else {
      return null;
    }
  }
}

export default SideBarSignout;
```

And finally, we'll add this component as an exportable module from our `user_provider` file.

``` javascript(/client/src/containers/user_provider.js)
import { connect } from 'react-redux';

import UserBadge from '../components/user_badge';
import SideBarSignout from '../components/side_bar_signout';
import { signalSignout } from '../actions/user';

-  const connectToUser = (WrappedComponent) => {
-    return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
- };

- const mapStateToProps = (state) => ({
-   username: state.user.username,
-   avatar: state.user.avatar
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchSignalSignout: (e) => dispatch(signalSignout())
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedUserBadge = connectToUser(UserBadge);
+ export const ConnectedSidebarSignOut = connectToUser(SideBarSignout);
```

Now before we close out this chapter I want to make a few small adjustments to our CSS to finalize our refactor for the responsive layout changes we have made this chapter.  At small resolutions some of our inline code is running offscreen.  Since these element sometimes are long strings of text, unbroken by spaces, the text is unable to wrap.  Luckily, CSS allows us to easily assert that line breaks can be added as needed in such situations.

``` javascript(/client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import FilteredNodesList from '../containers/filtered_nodes_list';
import { ConnectedChapterFooterLink } from '../containers/chapter_provider';
import { ConnectedBookmarkModal } from '../containers/bookmarks_provider';

const reader_pane_styles= {
  paddingBottom: "15px",
+   overflowWrap: "break-word" // new code
};

- class ReaderPane extends Component {
-   render() {
-     return (
-       <div id="reader-pane" style={ reader_pane_styles }>
-         <ConnectedBookmarkModal />
-         <Container text>
-           <FilteredNodesList />
-         <ConnectedChapterFooterLink />
-         </Container>
-       </div>
-     );
-   }
- }

export default ReaderPane;
```

## Wrapping Up

This chapter has brought a lot of changes to our application that should make our content more accessible accross devices.  It also bring us to the end of the last revisions we'll be making to featureset of our application before it's launch, and the close of our book.

In the final two chapters, we'll be looking at cleaning up code with an application-wide refactor.  We'll look for opportunities to clarify our code's intent while we also expand test coverage in areas we have thus far ignored. Finally, in our last chapter we will move our application through its first production release.
