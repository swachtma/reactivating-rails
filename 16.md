# Chapter 16: Refactor and Test

This chapter is a refactor of our entire application.  As we prepare to launch, I want to ensure our code is well tested, optimized, and written to maximize self-documentation.  There are no new features introduced this chapter.  Instead, we're going to revisit old ground to ensure our application launches on the best footing possible.  Let's go!

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch15-starter
```

## Setting Up ESLint

I am going to introduce ESLint to our project to help us refactor.  It may be some time before I pull this project off the shelf to code new functionality.  I want to ensure the code I leave behind for myself, or another developer to inherit is as consistent and developer friendly as possible.  

I want to trigger lint from my command line, which is currently unsupported in `react-scripts`.  However, we can make some quick edits in `package.json` to enable this functionality.

``` json(/client/package.json)
{
  "name": "client",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://138.197.14.5:3000",
  "dependencies": {
    "axios": "^0.16.2",
    "clipboard": "^1.7.1",
    "history": "^4.7.2",
    "markdown-it": "^8.4.0",
    "react": "^16.3.1",
    "react-dom": "^16.3.1",
    "react-redux": "^5.0.6",
    "react-scripts": "1.1.4",
    "redux": "^3.7.2",
    "redux-first-router": "0.0.16-next",
    "redux-first-router-link": "^1.4.1",
    "redux-first-router-restore-scroll": "^1.2.1",
    "redux-persist": "^5.5.0",
    "redux-saga": "^0.16.0",
    "semantic-ui-react": "^0.75.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject",
+     "lint": "node_modules/eslint/bin/eslint.js src"
  },
  "devDependencies": {
    "chai": "^4.1.2",
    "redux-devtools-extension": "^2.13.2"
  }
}
```

Typically, on installing you would run ESlint's `--init` command to generate a configuration file.  However, we are going to generate a config file manually, extending an existing configuration for React apps.

Create the following file.

``` javascript(/client/.eslintrc.js)
module.exports = {
  "extends": "./node_modules/eslint-config-react-app/index.js",
  "rules"  : {
    "key-spacing": [
      "error"
    ]
  }
}
```

Now you can run ESLint with the command `docker-compose exec client npm run lint`.  Be aware, if you have lint errors in files checked with this command, NPM barks errors at you.  Don't worry, that's normal.  

When lint finds an error, it returns an error code to NPM, which then warns you.  This error is useful when linting is part of a larger build task; assuming you don't want that task to proceed when linting fails.  The errors produced when manually linting though, can be misleading.

## Declaring Proptypes

As we refactor, I plan to add PropType declarations to our components.

PropTypes allow us to declare expected props for each component and what primitive each prop should be.  The advantage offered is twofold.  We're alerted when components unexpectedly receive data in unsupported formats.  Plus, the PropType declarations inform us of what props components require.

PropTypes once shipped as part `React`, but it's now a separate dependency you must explicitly include into files: `import PropTypes from 'prop-types'`.

## Conventions for this Chapter

I am handling this chapter differently than earlier entries.  Previously, I documented and explained almost every change made to our application. However, while seeking to make an application wide refactor, that approach becomes impractical.

This chapter I focus in detail on files that best demonstrate each concept I am introducing, but I am skipping repetitious examples.  Take this as an opportunity to practice applying new concepts to other components yourself.  Check out the starter tag for next chapter if you want to compare your solutions to my own for any of the components I don't cover in detail.

Incorporating only the examples shown is enough to prepare you for launch in chapter 17.

## Refactoring for Clarity

I'm going to start this process by revisiting our CodeBlock component and attempting to clarify its design.

`CodeBlock` is our most complex presentational component:
* Several external classes (`CodeFence` and `CodeSection`) parse and prepare its props.
* Visual presentation is divided across child components, such as `CodeSection` and `CodeHeader`.
* It leverages the `Responsive` component to vary behavior and presentation cross-device.
* Lifecycle methods in several child components run HighlightJS' syntax highlighting.

While I think we did reasonably well at dividing lines of work into logical units, we could make improvements.  Let's start at the top and work our way down the rendering tree.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

const styles = {
 codeBlockStyle: {
   marginBottom: "16px"
 },
 blockBodyStyle: {
   padding: "10px 0",
   border: "1px solid #021a40",
   backgroundColor: "#f8f8f8",
   overflowX: "scroll"
 }
};

class CodeBlock extends Component {
+   static propTypes = {
+     node: shape({ id: number, content: string }).isRequired
+   };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
+     this.section_refs = [];
  }
  
  componentDidMount(){
  if(this.triggerCopy){
    let button = this.triggerCopy.querySelector("button.copy");
    return new clipboardJS(button, {
      text: () => this.code_fence.copy
    });
  }
  }
  
  renderCodeSections = (sections) => {
    return Array.from(sections, s => {
      return(
        <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type}
        priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  };
  
+   render() {
+     let {node_id, block_type, block_path, sections} = this.code_fence;
+     return (
+       <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
+       id={"code_block_" + node_id} className={"language-" + block_type}>
+         { block_path && 
+           <CodeHeader block_path={block_path} collapseHandler={this.collapseSections}
+           triggerRef={(trigger) => this.triggerCopy = trigger} /> 
+         } 
+         <div style={styles.blockBodyStyle}>
+           { this.renderCodeSections(sections) }
+         </div>
+       </div>
+     );
  }
}

export default CodeBlock;
```

I've reorganized imports at the top of this file to ensure I import dependencies first, and my internal files second.  I also restructured my CSS into a single `styles` object as seen in chapter 15.

This class has our first use of `prop-types`.  Importing from the `prop-types` dependency, I list the individual types used by the component, not the entire library.  That saves me needing to chain all of my declarations through `propTypes`.  I am using `shape` to declare my component must receive an object with a numeric ID, and a string of content.  I placed this block above my constructor so that it is immediately clear what props my component requires.

`this.section_refs = []` was previously defined inside `renderCodeSections`, but declaring all our instance values in our constructor makes the class easier to understand.  

Inside the `render` function, we are destructing `this.code_fence` to make values returned by our parsing classes more accessible.  This change allows us to remove chaining (`this.code_fence.somethingelse`) noise from our rendered content.

Finally, I have abandoned the `renderHeaderIf` method entirely.  This function's only job was to test that a `block_path` was available for the node and if so, print a `CodeHeader`.  Adding an instance method for this trivial job seemed silly in hindsight; we can easily perform the test inside `render`.  Short-circuit `&&` evaluation now performs this logic test.  In this context, the `&&` operator only evaluates its right-hand side when the left evaluates truthy.  I'm using this as a streamlined `if` test with no `else` condition (where we might instead use the ternary operator).

## How Stuff Works Vs. How Stuff Looks

`CodeBlock` contains a large amount of behavioral code.  It supplies collapse and expand methods, binds event handlers in its lifecycle methods, and prepares data using the `CodeFence` and `CodeSection` classes.  There's nothing technically wrong with this, but it creates noise, making it difficult to comprehend the component.  Presentational changes made in the future would have to happen amidst that confusion.

Previously, we've used container components to create a layer between Redux and our application.  However, a more flexible definition would give containers purview over how components behave; leaving our components free to dictate how things look.

`CodeBlock` is doing a lot of both.  Let's refactor again to create a container `CodeExample` to manage behavioral tasks.  We'll also relocate the data cleanup classes currently living in `components/lib` to the container directory to clarify their purpose.  Here's how that looks.

``` javascript(/client/src/containers/code_example.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeBlock from '../components/nodes/code_block';

class CodeExample extends Component {
  static propTypes = {
    node: shape({ id: number, content: string }).isRequired
  };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
    this.section_refs = [];
  }
  
  componentDidMount(){
    if(this.triggerCopy){
      let button = this.triggerCopy.querySelector("button.copy");
      return new clipboardJS(button, {
        text: () => this.code_fence.copy
      });
    }
  }

  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  }
  
+   addSectionRef = s => this.section_refs.push(s);
  
+   attachCopyTrigger = (trigger) => this.triggerCopy = trigger;
  
  render() {
    return (
+       <CodeBlock 
+         node={this.code_fence} section_refs={this.section_refs}
+         collapseSections={this.collapseSections} addSectionRef={this.addSectionRef}
+         attachCopyTrigger={this.attachCopyTrigger}
+       />
    );
  }
}

export default CodeExample;
```

Most of this code is migrated directly from `CodeBlock`.

There's one small change, we've added two new functions `addSectionRef` and `attachCopyTrigger` to this container so that we can pass the functions as props.  Previously, `CodeBlock` defined anonymous functions inside prop declarations such as `triggerRef={(trigger) => this.triggerCopy = trigger}`.  Passing anonymous functions creates a weakness in our render cycle.  Since the reference to the passed function changes each time the parent renders, the children inheriting these anonymous functions are guaranteed to render again as well, even if the resulting props are functionally unchanged from the last cycle.

By passing props that are an instance method on the parent, we can preserve the function references between renders, mitigating this problem. We also remove noise from our child components.

Here's what `CodeBlock` looks like after these changes.

``` javascript(/client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string, array, func } from 'prop-types';

import CodeHeader from './code_header';
import CodeSection from './code_section';

const styles = {
  codeBlockStyle: {
    marginBottom: "16px"
  },
  blockBodyStyle: {
    padding: "10px 0",
    border: "1px solid #021a40",
    backgroundColor: "#f8f8f8",
    overflowX: "scroll"
  }
};

class CodeBlock extends Component {
  static propTypes = {
    collapseSections: func,
    attachCopyTrigger: func,
    node: shape(
      { node_id: number, block_type: string, block_path: string, sections: array }
    ).isRequired
  };

  renderCodeSections = () => {
    let { addSectionRef, node } = this.props;
    return Array.from(node.sections, s => 
      <CodeSection ref={addSectionRef} block_type={node.block_type} 
      priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
    );
  };
  
  render() {
    let { collapseSections, attachCopyTrigger, node } = this.props;
    let { node_id, block_type, block_path } = node;

    return (
      <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
      id={"code_block_" + node_id} className={"language-" + block_type}>
        { block_path && 
          <CodeHeader block_path={block_path} collapseHandler={collapseSections}
          triggerRef={attachCopyTrigger} /> 
        } 
        <div style={styles.blockBodyStyle}>
          { this.renderCodeSections() }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

We're ready to move into the other child components for this element.  I am satisfied with the refactor we performed for the `CodeHeader` component in chapter 15, so let's focus next on `CodeSection`.

``` javascript(/client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import {string, array, oneOf } from 'prop-types';

import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

const styles = {
  codeSectionStyle: {
    display: "table-row",
    padding: "0 5px",
    lineHeight: "100%"
  },
  codeGutterStyle: {
    display: "table-cell",
    padding: "0 5px"
  },
  codeBodyStyle: {
    margin: 0,
    display: "table-cell",
    width: "100%",
    paddingRight: "10px",
  }
};

class CodeSection extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string,
    priority: oneOf(["low","normal","high"])
  };
  
  constructor(props){
    super(props);
    this.state = {
      collapsed: props.priority === "low" ? true : false
    };
  }
  
+   toggleCollapse = (e) => 
+     this.props.priority === "low" && this.setState({collapsed: !this.state.collapsed});
+ 
+   setCollapse = (bool) =>
+     this.props.priority === "low" && this.setState({collapsed: bool});
+     //called by reference when +/- buttons are clicked in CodeHeader

  render() {
    let { section_id, priority } = this.props;
    let { collapsed } = this.state;
    let icon = collapsed ? "plus" : "minus"; 
    
    return (
      <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={styles.codeSectionStyle}>
        <div className="codeGutter" style={styles.codeGutterStyle}>
          <i className={"fa fa-"+ icon +"-square-o"}></i>
        </div>
        <div className="codeBody" style={styles.codeBodyStyle} id={section_id}>
          { collapsed ? <CodeCollapsed {...this.props} /> : <CodeFull {...this.props} /> }
        </div>
      </div>
    );
  }
}

export default CodeSection;
```

I'm refactoring some of the component's methods to use an abbreviated arrow function syntax `() => return-value;` which implicitly returns the value of a function with a single line expression.  This syntax, combined with the short-circuit `&&` removes a large amount of bracket spaghetti from the `toggleCollapse` and `setCollapse` methods.

Our last two components from code examples, `CodeCollapsed` and `CodeFull` don't need much beyond a propTypes declaration and cleanup with object destructuring.

``` javascript(/client/src/components/nodes/code_collapsed.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeCollapsed extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_collapsed"));
  }
  
  render() {
    let { contents, section_id, block_type } = this.props;
    return (
      <code id={section_id+"_collapsed"}>
        <pre className={block_type}>
          <div>
            {contents[0]} 
            <i className="fa fa-arrows-h" aria-hidden="true"></i>
            {contents[contents.length-1].trim()}
          </div>
        </pre>
      </code>
    );
  }
}

export default CodeCollapsed;
```

``` javascript(/client/src/components/nodes/code_full.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeFull extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_full"));
  }
  
  render() {
    let {section_id, contents, block_type } = this.props;
    return (
      <code id={section_id+"_full"}>
        <pre className={block_type}>{contents.join("\n")}</pre>
      </code>
    );
  }
}

export default CodeFull;
```

## Function Components

There's one more transformation I'm going to make where possible; moving away from class components in favor of functions.

We cannot write components that maintain state or use lifecycle methods as functions.  These features are unsupported (at least so far).  However, functions work well where we have a purely visual component.  They offer a much simpler syntax, and are notably easier to test.

Let's look at an example; our `AlertList` component before and after the change.

``` javascript(/client/src/components/alert_list.js)
import React, { Component } from 'react';

alertStyle: {
  padding: "15px",
  marginBottom: "20px",
  border: "1px solid transparent",
  borderRadius: "4px"
},

alertLevels ={
  info: {
    backgroundColor: "#d9edf7",
    borderColor: "#bce8f1",
    color: "#31708f"
  },
  warning: {
    backgroundColor: "#fcf8e3",
    borderColor: "#faebcc",
    color: "#8a6d3b"
  },
  success: {
    backgroundColor: "#dff0d8",
    borderColor: "#d6e9c6",
    color: "#3c763d"
  },
  danger: {
    backgroundColor: "#f2dede",
    borderColor: "#ebccd1",
    color: "#a94442"
  }
};

class AlertList extends Component {
  renderAlertMessages = (alerts) => {
    return alerts.map((a) => 
      <div 
        key={a.timestamp}
        className={"alert alert-" + a.level }
        style={Object.assign(alertStyle,alertLevels[a.level])}
        children={a.message}
      />
    );
  }
  
  render() {
    return (
      <div className={"alert_list_" + this.props.scope}>
        { this.renderAlertMessages(this.props.alerts) }
      </div>
    );
  }
}

export default AlertList;
```

Our component is already reasonably concise.  However, compare that to the refactored example below.

``` javascript(/client/src/components/alert_list.js)
import React, { Component } from 'react';
import {string, array} from 'prop-types';

const styles = {
  alertStyle: {
    padding: "15px",
    marginBottom: "20px",
    border: "1px solid transparent",
    borderRadius: "4px"
  },

  alertLevels: {
    info: {
      backgroundColor: "#d9edf7",
      borderColor: "#bce8f1",
      color: "#31708f"
    },
    warning: {
      backgroundColor: "#fcf8e3",
      borderColor: "#faebcc",
      color: "#8a6d3b"
    },
    success: {
      backgroundColor: "#dff0d8",
      borderColor: "#d6e9c6",
      color: "#3c763d"
    },
    danger: {
      backgroundColor: "#f2dede",
      borderColor: "#ebccd1",
      color: "#a94442"
    }
  }
};

AlertList.propTypes = {
  scope: string,
  alerts: array
};

function AlertList(props){
  let { scope, alerts } = props; 
  
  alerts = alerts.map((a) => {
    let ac = "alert alert-" + a.level;
    let as = Object.assign(styles.alertStyle,styles.alertLevels[a.level]);
    return <div key={a.timestamp} children={a.message} className={ac} style={as} />;
  });
  
  return <div className={"alert_list_" + scope}>{ alerts }</div>;
}

export default AlertList;
```

We can remove `render` entirely; a function component renders its return value.  I've stripped out `renderAlertMessages` to instead map `alerts` directly from props, transforming each alert into a `div` element.  These changes allow us to use one destructing call to make our props available across the entire function, mitigating the need to pass data in method parameters such as `this.renderAlertMessages(this.props.alerts)`.

## Setting Up for Component Tests

Our components are flying completely untested.  With our visual design settled, its time to stop stalling and place critical aspects of our UI under test.  I am going to add a library, `enzyme` to render components while testing so we can check some assumptions about each.

We need to install Enzyme, and an adaptor for our specific version of React: `docker-compose exec client yarn add enzyme enzyme-adapter-react-16 --dev`

We're going to need these dependencies inside each component test.  Export Enzyme's set up as a module and place this helper in your client root to make it easily accessible.

``` javascript(/client/src/test_helper.js)
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

export default configure({ adapter: new Adapter() });
```

Enzyme provides several rendering options for testing components.  Whenever possible, I use the `shallow` method, which renders the component passed, without fullying rendering its children.

Limiting child rendering minimizes the amount of mocking needed to test components.  Instead of testing our entire component tree in mass, we render components in isolation; focusing tests on each component's responsibilities.

Enzyme's querying method `find`  ensures our components render the correct children when we need specific validation. For higher level monitoring, we can use Jest's `toMatchSnapShot()`.

``` javascript(/client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  it("renders div#app", ()=>expect(wrapper.find("div#app").exists()).toBe(true));
  it("renders AlertList", ()=>expect(wrapper.find("Connect(AlertList)").exists()).toBe(true));
  it("renders RouterSwitch", ()=>expect(wrapper.find("Connect(RouterSwitch)").exists()).toBe(true));
  it("renders NavigationMenus", ()=>expect(wrapper.find("Connect(NavigationMenus)").exists()).toBe(true));
});
```

Here we test that `App` renders each of its expected children.  However, it pays to remember we can use javascript control statements to clean up repetitive tests.

``` javascript(/client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  
+   let children = ["div#app","Connect(NavigationMenus)","Connect(RouterSwitch)","Connect(AlertList)"];
+   children.forEach((c) => it("renders " + c, ()=>expect(wrapper.find(c).exists()).toBe(true)));
});
```

These tests are almost right, but a weakness in `chapterProvider` is creating our component as an anonymous class, `connect(Component)`.  That is leading to a test failure when we try to query for a specific component name.  To avoid ambiguity, and fix this spec, refactor the container to name the dynamically generated components.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

+ const chapterProvider = (WrappedComponent) => {
+   const C = (props) => {
+     return props.chapters !== [] ?
+       <WrappedComponent {...props} active_chapter={props.active_chapter || {id: -1, title: ""}} /> :
+       null;
+   };
+   Object.defineProperty (C, 'name', {value: WrappedComponent.name});
+   return C;
+ };

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters.map((ch) => {
-     ch.title = ch.title.replace(/^chapter\s?/i,"");
-     return ch;
-   })
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

Let's apply what we've learned so far to another component, `GitHubIcon`.  

I am setting up a spec directory in my `components` folder for all of my component tests to live.  Placing spec files in the same directory as the files under test becomes unwieldy with so many component files.

See if you are comfortable with the following spec.

``` javascript(/client/src/components/spec/user_badge.spec.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

describe("<UserBadge />", () =>{
  it("renders GithubIcon on !props.username", ()=>{
    let wrapper = shallow(<UserBadge />);
    expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
  });
  
  it("renders ProfileIcon on props.username", ()=>{
    let wrapper = shallow(<UserBadge username="TestDude" />);
    expect(wrapper.find("ProfileIcon").exists()).toBe(true);
  });
})

describe("<ProfileIcon />",()=>{
  let wrapper = shallow(<ProfileIcon username="TestDude" avatar="someurl.png"/>)
  console.log(wrapper.debug())
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  })
});
```

In the spec above we are passing props to our components and examining the resulting render.  We do this with the JSX syntax we always used.  

Our default component `UserBadge` uses the presence of a username to conditionally render either a sign-in badge or the user's GitHub Avatar.

Since `shallow` won't follow rendering into child components, we can import the `ProfileIcon` component directly, and shallow render it with sample props to produce a more detailed snapshot.  Since this component renders no children, I forgo querying for specific rendered nodes.  

However, since `UserBadge` receives event handlers from its parents, we should ensure we call the passed functions when appropriate events trigger.  To do this, we can use Enzyme's simulated events, with a little help from Jest's mocks.

``` javascript(/client/src/components/spec/user_badge.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

- describe("<UserBadge />", () =>{
-   it("renders GithubIcon on !props.username", ()=>{
-     let wrapper = shallow(<UserBadge />);
-     expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
-   });
-   
-   it("renders ProfileIcon on props.username", ()=>{
-     let wrapper = shallow(<UserBadge username="TestDude" />);
-     expect(wrapper.find("ProfileIcon").exists()).toBe(true);
-   });
- });

describe("<ProfileIcon />",()=>{
+   let mockDispatch = jest.fn();
+   let mockHandler = jest.fn();
+   let wrapper = shallow(
+     <ProfileIcon username="TestDude" avatar="someurl.png"
+       dispatchSignalSignout={mockDispatch} handleSidebarVisibility={mockHandler} />
+   );
+   
+   it("calls function passed in dispatchSignalSignout on Signout click",()=>{
+     let link = wrapper.find("DropdownItem");
+     link.simulate("click");
+     expect(mockDispatch).toBeCalled();
+   });
+   
+   it("calls function passed in handleSidebarVisibility on focus",()=>{
+     let menubar = wrapper.find("Dropdown");
+     menubar.simulate("focus");
+     expect(mockHandler).toBeCalled();
+   });
  
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  });
});
```

Using `find`, we locate elements with attached event handlers.  Enzyme supplies a very intuitive `simulate` method for triggering events such as clicks, focus, and others.  As we trigger each event, we expect a call on the mock passed through our props.

## Testing Stateful Components

Let's look at a more complex component, carrying internal state; `SideBarPopout`.  Several UI interactions need testing, all related to this component's visibility.  I want to ensure the menu opens and closes according to the proper user actions.  

Before testing state mutations, let's create tests to check the basic rendering.

``` javascript(/client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

const test_props = {
  chapters: [
    {id: 1, title: "Test Chapter 1"},
    {id: 2, title: "Test Chapter 2"}
  ],
  active_chapter: {id: 2, title: "Test Chapter 1"},
  dispatchRouteChapter: jest.fn()
};

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

describe("<SideBarPopout /> rendering",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("renders a link for each chapter", () =>{
    test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
  });
  
  it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
  it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
  it("renders according to snapshot",() => expect(w).toMatchSnapshot());
});
```

A simple check ensures we render all expected nodes: a link for each chapter, our signout component, and close link. Finally, a snapshot provides high level alerting for rendering changes.

I'm introducing a helper function `expectXInY`, because I am frequently repeating `expect(wrapper.find("selector").exists()).toBe(true)` evaluations.  A helper function keeps my examples concise.  I migrate the helper to our `test_helper` file after this example for reusability.

Now take a pass at testing state changes.  Before testing UI interactions, I want to test one of this component's instance methods directly.

``` javascript(/client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

describe("SideBarPopout.toggleVisibility", ()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("reverses visibilty if specific value not given", () => {
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(false);
  });
  
  it("assigns visibility specified", () =>{
    w.instance().toggleVisibility(true);
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility(false);
    expect(w.state("visible")).toBe(false);
  });
});
```

Enzyme provides a method `instance` on its wrappers.  With its return, we can call instance methods of the component using method chaining, in this case, `w.instance().toggleVisibility`.

Testing `toggleVisibility` ensures this core function impacts the state as expected.  It should either flip the visibility value to its inverse, or assign the specific visibility state passed to the method.  We use another Enzyme method `getState` to (as you might expect), get our state.

Now we can turn to some UI interactions.

``` javascrip(/client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

- describe("SideBarPopout.toggleVisibility", ()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("reverses visibilty if specific value not given", () => {
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(false);
-   });
-   
-   it("assigns visibility specified", () =>{
-     w.instance().toggleVisibility(true);
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility(false);
-     expect(w.state("visible")).toBe(false);
-   });
- });
  
describe("<SideBarPopout /> visible state",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("defaults to hidden", () => expectXInY("Sidebar[visible=false]",w));
  
  describe("will",()=>{
    beforeEach(() => {
      w.setState({visible: true});
      w.update();
    });
    
    it("change to visibility = false, and dispatch chapter route on chapter link",()=>{
      w.find("MenuItem[name='chapter1']").simulate("click");
      expectXInY("Sidebar[visible=false]",w);
      expect(test_props.dispatchRouteChapter).toBeCalled();
    });
    
    ["MenuItem[name='Close Menu']","SidebarPusher"].forEach(t =>{
      it("change to visibility = false on click of " + t,()=>{
        t = w.find(t);
        t.simulate("click");
        expectXInY("Sidebar[visible=false]",w);
      });
    });
    
    it("not change on click of MenuItem[link=false]", () => {
      w.find("MenuItem[link=false]").simulate("click");
      expectXInY("Sidebar[visible=true]",w);
    });
  });
});
```

The UI behaviors I want to test are active during the component's open state, but the component defaults to its hidden state.  We need to perform some setup before each test.  We begin with a test validating our default behavior.  Then, using `beforeEach`, we write a block that's executed before each spec, preparing the component for other test cases by opening our menu.

`setState`, toggles visibility to `true`, and calling an `update` method on our wrapper rerenders with this new state.  We must explicitly call `update`; shallow rendered components don't re-render automatically on state changes.  We haven't seen this previously, because Enzyme automatically calls `update` on wrappers after simulated events.  When using instance methods though, or setting state directly, we must intercede to tell enzyme it should update.

With our component visible, we can test our events.  Our link to chapter one, when clicked, should cause the menu to close, and invoke our `dispatchRouteChapter` mock.  The Signout link, close link, and clicks of the layer's dimmer area should also set our visibility to `false`.  Our link denoting the current active chapter is disabled and should **not** close the sidebar when clicked.

## Critical Container Refactors

Before we wrap, we need to look into a few of our containers and correct a serious error I made in my initial design.  Have a look at the example below and see if you can spot the problem.

``` javascript(/client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

const filtered_nodes = (nodes, chapter) => {
  return nodes.filter((node) => { return node.chapter_id === chapter });
};

const mapStateToProps = (state) => ({
  nodes: filtered_nodes(state.nodes,state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

The way I designed this container causes our application to run extra render cycles on everything connected to it.  The most damaging impact is that **every** state change, even to completely unrelated sections of our state tree, retriggers the rendering of our nodes list.

My connect function's use of `Array.filter` is the source of the problem.  The `filter` method produces a new array instance containing only elements of the original array that pass our filter expression.  React doesn't perform a deep comparison of our array to determine if it needs to render a component anew.  Instead, it relies on us to keep an immutable state on its behalf so its tests for rendering can be simple referential checks.  If a component receives a new array instance, it renders anew, even if the new array is a perfect twin of the last render cycle.

`Array.filter` produces a new array each time its run.  What is especially problematic is that `connect` subscribes to **all updates** on our state tree; not just the branches of state we need for this container.  Have a look at our reducer for a quick refresher.

``` javascript(/client/src/reducers/nodes.js)
import * as constants from '../constants/nodes';

let default_state = [];

- export const sortNodes = (nodes) => {
-   return nodes.sort((a,b) =>{
-     if(a.chapter_id === b.chapter_id){
-       return a.id - b.id;
-     } else
-     {
-       return a.chapter_id - b.chapter_id;
-     }
-   });
- };

+ const nodesReducer = function(state = default_state,action){
+   switch (action.type) {
+     case(constants.LOAD_NODES):
+       return [...sortNodes(action.payload)];
+     default:
+       return state;
+   }
+ };

export default nodesReducer;
```

We've done this correctly; our `nodesReducer` is only managing one action that loads our list of nodes on the `LOAD_NODES` action. When loading, we use a spread operator to assign all members of the array to a new array literal, allowing React to spot the change quickly.  Remember though that **all** actions get passed through **all** of our reducers.  

That means that any actions dispatched evaluate inside `nodesReducer`.  Since other action types won't match the switch conditions, other actions fall through to our default case, which returns our unaltered state.  React sees that our reference to our nodes array is unchanged, and skips any render cycles dependent on that part of our state.  At least, that's how it should work.

It all goes wrong when `connect` receives that unaltered reference to our existing state.  It picks up the unchanged state, and happily churns through its filter operation, producing a **new** list of nodes, and supplying that to React.

Rendering this list of nodes is perhaps the most expensive operation our client performs.  Printing an extensive list of React elements, and running additional work afterward to add syntax highlighting using `highlightJS`.  It's not a task to repeat needlessly.  Let's look at how we can fix this.

``` javascript(/client/src/containers/filtered_nodes_list.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ export class FilteredNodeList extends Component {
+   render(){
+     const { nodes, active_chapter_id } = this.props;
+     const node_list = nodes.filter(n => n.chapter_id === active_chapter_id);
+     return node_list && node_list.length ? <NodesList nodes={node_list} /> : null;
+   }
+ }

const mapStateToProps = (state) => ({
  nodes: state.nodes,
  active_chapter_id: state.settings.active_chapter_id
});

export default connect(
  mapStateToProps,
  null
)(FilteredNodeList);
```

We've dumbed down `mapStateToProps` to keep a simple subscription to our state.  To offset this, we've reworked `FilteredNodeList` to do our heavy lifting. The container now produces our filtered list of nodes and renders our child components only once we have a list of elements ready to print. 

This approach removes our extra render cycles because `render` only runs inside our HOC after receiving updated props.  That means receiving a truly **new** array of nodes, or an updated `active_chapter_id` from our store.  If the HOC's props don't change, we short-circuit its render, preventing `Array.filter` from running and updating children downstream.

One more thing before we move on.  Let's make this component a little easier to get inside for testing.

``` javascript(/client/src/containers/filtered_nodes_list.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ export const nodesProvider = (WrappedComponent = NodesList) => 
+   class extends Component {
+     static displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
+     
+     render(){
+       const { nodes, active_chapter_id } = this.props;
+       const node_list = nodes.filter(n => n.chapter_id === active_chapter_id);
+       return node_list && node_list.length ? <WrappedComponent nodes={node_list} /> : null;
+     }
+   };

- const mapStateToProps = (state) => ({
-   nodes: state.nodes,
-   active_chapter_id: state.settings.active_chapter_id
- });

export const connectToNodes = (WrappedComponent) =>
  connect(mapStateToProps, null)(nodesProvider(WrappedComponent));
  
export default connectToNodes();
```

Instead of configuring our HOC as a static class, we have refactored it as a function `nodesProvider` which returns a dynamically created class.  That class renders a wrapped component with our prepared props.  We can now reuse this functionality to connect any component we need with our filtered list of nodes.  Plus, reusability aside, we can now test this container without mocking our redux store.

``` javascript(/client/src/containers/filtered_nodes_list.spec.js)
/* global expect */
import React, { Component } from 'react';
import { shallow } from 'enzyme';

import config from '../test_helper';
import { nodesProvider } from './filtered_nodes_list';

let defaultProps = {
  active_chapter_id: 1,
  nodes: [
    {id: 1, chapter_id: 1, node_type: "header", content: "Node 1"},
    {id: 2, chapter_id: 1, node_type: "paragraph", content: "Node 2"},  
    {id: 3, chapter_id: 2, node_type: "header", content: "Node 3"},  
  ]
};

+ class MockComponent extends Component {}
+ const MockContainer = nodesProvider(MockComponent);

describe("nodesProvider", ()=>{
+   it("renders wrapper only with nodes matching active_chapter_id", ()=>{
+     let w = shallow(<MockContainer {...defaultProps}/>);
+     expect(w.find("MockComponent").props().nodes.length).toBe(2);
+   });
  
  it("render nothing if no nodes match filter", () => {
    let w = shallow(<MockContainer nodes={[]} active_chapter_id={1} />);
    expect(w).toMatchSnapshot();
  });
});
```

By moving logic operations out of `mapStateToProps` and into a High Order Component, we can test our filtering results without mocking an entire Redux store.  We simply render the HOC and manually pass the props we want to utilize in testing.

Before moving on, we need similar refactoring inside `chapterProvider`.

``` javascript(/client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React, { Component } from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => 
  connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));


export const chapterProvider = (WrappedComponent) => class ChapterFilter extends Component {
  static displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
  
  render(){
    const { active_chapter_id, chapters, ...otherProps } = this.props;
    const active_chapter = chapters.find(c => c.id === active_chapter_id);
    const next_chapter = chapters.find(c => c.id === active_chapter_id + 1);
    
    const cleaned_chapters = chapters.map( c =>{
      c.title = c.title.replace(/^chapter\s?/i,"");
      return c;
    });
    
    return  chapters && chapters.length ? 
      <WrappedComponent active_chapter={active_chapter || {id: -1, title: ""}}
        next_chapter={next_chapter} chapters={cleaned_chapters} {...otherProps} /> : null;
  }
};

const mapStateToProps = (state) => ({
  chapters: state.chapters,
  active_chapter_id: state.settings.active_chapter_id
});

const mapDispatchToProps = (dispatch) => ({
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

We should also add test coverage for this container.

``` javascript(/client/src/containers/chapter_provider.spec.js)
/* global expect */
import React, { Component } from 'react';
import { shallow } from 'enzyme';

import config from '../test_helper';
import { chapterProvider } from './chapter_provider';

let defaultProps = {
  active_chapter_id: 1,
  chapters: [
    {id: 1, title: "Chapter 1: Stuff"},
    {id: 2, title: "Chapter 2: Things"},  
    {id: 3, title: "Chapter 3: Stuff & Things"}
  ]
};

class MockComponent extends Component {}
const MockContainer = chapterProvider(MockComponent);

describe("chapterProvider", ()=>{
  it("selects active and next chapter", ()=>{
    let w = shallow(<MockContainer {...defaultProps}/>);
    expect(w.find("MockComponent").props().active_chapter.id).toBe(1);
    expect(w.find("MockComponent").props().next_chapter.id).toBe(2);
  });
  
  it("passes cleaned titles to WrappedComponent", ()=>{
    let w = shallow(<MockContainer {...defaultProps}/>);
    expect(w.find("MockComponent").props().chapters[0].title).toBe("1: Stuff");
  });
  
  it("render nothing if no nodes match filter", () => {
    let w = shallow(<MockContainer chapters={[]} active_chapter_id={1} />);
    expect(w).toMatchSnapshot();
  });
});
```

## Wrapping Up

We have looked at all the tools and strategies needed to test components and containers throughout our application.  If you would like additional practice, add coverage for components we didn't explicitly cover until you are comfortable with different scenarios.

If you get stuck on something, consult the starter commit at the beginning of our next chapter and compare your work to my own.  Otherwise, move on to chapter 17, where we cover deploying our application to production for the first time.