# Chapter 16: Refactor and Test

## Jumping in Here

If you have not been following along with code examples and wanted to jump in here, you can use our [Chapter16Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter16Starter) branch as a place to join in.

## Author's Note

As I move into this chapter, I am taking a moment to update to the latest available `react-scripts`.  This step is optional if you are following along in your application.  As I prepare for launch, I wanted to ensure I was working with the latest stable release of this package, since it is central to my application.

## Setting Up ESLint

I'm going to be running ESLint frequently as I move through this refactor to clean up some of my code.  I want to trigger lint to run from my command line, which is not currently supported by `react-scripts` natively.  However, we can make some quick edits to our `package.json` file to enable this functionality.

``` json(/reactive-client/package.json)
{
  "name": "reactive-client",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://138.197.14.5:3000",
  "dependencies": {
    "axios": "^0.16.2",
    "clipboard": "^1.7.1",
    "history": "^4.7.2",
    "markdown-it": "^8.4.0",
    "react": "^16.3.1",
    "react-dom": "^16.3.1",
    "react-redux": "^5.0.6",
    "react-scripts": "1.1.4",
    "redux": "^3.7.2",
    "redux-first-router": "0.0.16-next",
    "redux-first-router-link": "^1.4.1",
    "redux-first-router-restore-scroll": "^1.2.1",
    "redux-persist": "^5.5.0",
    "redux-saga": "^0.16.0",
    "semantic-ui-react": "^0.75.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject",
+     "lint": "node_modules/eslint/bin/eslint.js src"
  },
  "devDependencies": {
    "chai": "^4.1.2",
    "redux-devtools-extension": "^2.13.2"
  }
}
```

Typically, you would want to run ESlint's `--init` command to generate a configuration file.  However, we are going to generate a config file manually, and use it to extend the configuration used by `create-react-app.`

``` javascript(/reactive-client/.eslintrc.js)
module.exports = {
  "extends": "./node_modules/eslint-config-react-app/index.js",
  "rules"  : {
    "key-spacing": [
      "error"
    ]
  }
}
```

Now you can run your lint with the command `npm run lint`.  Be aware, if you have lint errors among files you check with this command, NPM is going to bark an error at you.  Don't worry, that's normal.  When your lint rules find an error, they return an error code to NPM, which in turn warns you of the failure.  This error is useful if you are planning to add this linting step to a more substantial build task, and you don't want the task to proceed if your lint fails.  However, the errors it produces when manually executing your lint can be misleading.

## Declaring Proptypes

As we refactor our components, we are also going to add PropType declarations.  PropTypes allow us to declare the needed props of each component and define what primitive type we expect in each.  The advantage of doing this is twofold; for one, it helps to alert us if our components suddenly begin to receive data in an unsupported format.  Also, having a PropType declaration helps us understand what each component needs to receive to render correctly.

PropTypes once shipped as part of `React` itself, however, it now lives in an independent dependency, and we need to include it explicitly where we wish to make use of it 

``` javascript
import PropTypes from 'prop-types';
```

## Conventions for this Chapter

I'm going to approach this chapter a bit differently than our previous examples.  Up until now, I have documented and explained almost every change I have made to our application.  As we look to make an application wide refactor though, that becomes less practical.  This chapter I am going to focus only on the files that best demonstrate the concepts I am introducing. Use this as an opportunity to take a look at a few other components yourself, and try a refactor on your own.  If you want to then compare your work to my own, check out the GitHub tag for the next chapter's starter to see where I landed.

## Refactoring for Clarity

I'm going to start this process by revisiting our CodeBlock component and attempting to clarify its design.  The CodeBlock component is arguably our most complex presentational component; it relies on an external class (classes actually) CodeFence, and CodeSection to do some heavy lifting to parse and prepare its props.  Then the CodeBlock component itself leverages several other child components, such as CodeSection and CodeHeader to divide the visual layout into manageable pieces. It also contains instructions from the Responsive component we worked with during our last chapter.  To make things a little more complicated, we also use lifecycle methods inside several of our child components to run HighlightJS' syntax highlighting.

While I think we've done a reasonably good job of dividing our lines of work into logical units, I think we could still make some improvements.

Let's start at the top and make our way down the rendering tree.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

+ const styles = {
+   codeBlockStyle: {
+     marginBottom: "16px"
+   },
+   blockBodyStyle: {
+     padding: "10px 0",
+     border: "1px solid #021a40",
+     backgroundColor: "#f8f8f8",
+     overflowX: "scroll"
+   }
+ };

class CodeBlock extends Component {
+   static propTypes = {
+     node: shape({ id: number, content: string }).isRequired
+   };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
+     this.section_refs = [];
  }
  
  componentDidMount(){
  if(this.triggerCopy){
    let button = this.triggerCopy.querySelector("button.copy");
    return new clipboardJS(button, {
      text: () => this.code_fence.copy
    });
  }
  }
  
  renderCodeSections = (sections) => {
    return Array.from(sections, s => {
      return(
        <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type}
        priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  };
  
  render() {
+     let {node_id, block_type, block_path, sections} = this.code_fence;
    return (
      <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
      id={"code_block_" + node_id} className={"language-" + block_type}>
+         { block_path && 
+           <CodeHeader block_path={block_path} collapseHandler={this.collapseSections}
+           triggerRef={(trigger) => this.triggerCopy = trigger} /> 
+         } 
        <div style={styles.blockBodyStyle}>
          { this.renderCodeSections(sections) }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

Let's break down our changes one by one.  I've reorganized my imports at the top of this file to ensure I import my dependencies first, followed by a line break, and then my internal files.  I have also restructured my CSS objects to all belong to a single `styles` object as we saw in previous chapters.

In our component class, we now have our first use of `prop-types`.  Notice that my import from the `prop-types` dependency lists the individual types I am using in this component, rather than the entire library.  That saves me from the need to chain all of my declarations through that parent class.  In this case, I am using shape to declare that my component must receive an object with a specific shape; a numeric ID, and a string of contents.  I've placed this block above my constructor so that it is immediately clear what props my component requires.

Inside my constructor, I have moved our declaration of `this.section_refs = []`. This instance value was defined previously inside our `renderCodeSections` method, but for clarity, I want to have all my instance values for the class declared in my constructor.

Our render method is now using object destructing, similar to how we have destructured our props in the previous chapter.  The only difference is, we are destructing `this.code_fence`, to make the parsed values returned by our class more accessible.  This change allows us to remove a lot of `this.code_fence.somethingelse` noise from our rendered content.

Finally, our render method has abandoned our `renderHeaderIf` method entirely.  This function's only job was to perform a test that a `block_path` was available for the node, and if so print a `CodeHeader`.  Having an extra instance method on our class for such a small job seemed silly in hindsight when we can easily perform the test in our component's render method.  I've changed us to using a short-circuit `&&` evaluation to perform this logic test.  Used in this context, the `&&` operator only evaluates its right side if the left side evaluates truthy.  In this case, we leverage this to conditionally print a streamlined `if` test that has no `else` condition (where we might instead use the ternary operator).

## How Stuff Works Vs. How Stuff Looks

There's another change for this component that's gnawing at me.  `CodeBlock` contains a large amount of behavioral code.  We're supplying our collapse and expand method, binding our copy/paste action using the component's lifecycle method, and preparing data using our `CodeFence` and `CodeSection` classes.  There's nothing technically wrong about this, but it's creating noise that makes it difficult to parse out what's happening in the component.  If we want to make presentational changes in the future, we'll need to do so amidst all of that confusion.

Previously we've used container components primarily to create a layer between Redux and our application.  However, a more flexible definition of containers would give them purview over how our components behave; leaving our components free to dictate how things look.

`CodeBlock` is doing a lot of both.  I am going to refactor again to split out a container `CodeExample` to handle these behavioral tasks.  We'll also relocate the data cleanup classes currently living in `components/lib` to the container directory to clarify their purpose.  Here's how that looks.

``` javascript(/reactive-client/src/containers/code_example.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeBlock from '../components/nodes/code_block';


class CodeExample extends Component {
  static propTypes = {
    node: shape({ id: number, content: string }).isRequired
  };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
    this.section_refs = [];
  }
  
  componentDidMount(){
    if(this.triggerCopy){
      let button = this.triggerCopy.querySelector("button.copy");
      return new clipboardJS(button, {
        text: () => this.code_fence.copy
      });
    }
  }

  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  }
  
+   addSectionRef = s => this.section_refs.push(s);
  
+   attachCopyTrigger = (trigger) => this.triggerCopy = trigger;
  
  render() {
    return (
+       <CodeBlock 
+         node={this.code_fence} section_refs={this.section_refs}
+         collapseSections={this.collapseSections} addSectionRef={this.addSectionRef}
+         attachCopyTrigger={this.attachCopyTrigger}
+       />
    );
  }
}

export default CodeExample;
```

Most of this code is a direct migration from our `CodeBlock` component.  Our render method is simply calling our original `CodeBlock` and passing through the items it needs as props.

There's one small change, we've added two new functions `addSectionRef` and `attachCopyTrigger` to this container so that we can pass them as props.  Previously, `CodeBlock` defined these functions inline as props such as `triggerRef={(trigger) => this.triggerCopy = trigger}`.  This pattern creates a weakness in our render cycle that recreates new instances of these functions each time the component rerenders.  By passing them as props from a parent, we can mitigate that problem, and allow all our child components to use the same function provided by the parent. We also remove noise from our child components.

Here's what `CodeBlock` looks like after these changes.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string, array, func } from 'prop-types';

import CodeHeader from './code_header';
import CodeSection from './code_section';

const styles = {
  codeBlockStyle: {
    marginBottom: "16px"
  },
  blockBodyStyle: {
    padding: "10px 0",
    border: "1px solid #021a40",
    backgroundColor: "#f8f8f8",
    overflowX: "scroll"
  }
};

class CodeBlock extends Component {
  static propTypes = {
    collapseSections: func,
    attachCopyTrigger: func,
    node: shape(
      { node_id: number, block_type: string, block_path: string, sections: array }
    ).isRequired
  };

  renderCodeSections = () => {
    let { addSectionRef, node } = this.props;
    return Array.from(node.sections, s => 
      <CodeSection ref={addSectionRef} block_type={node.block_type} 
      priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
    );
  };
  
  render() {
    let { collapseSections, attachCopyTrigger, node } = this.props;
    let { node_id, block_type, block_path } = node;

    return (
      <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
      id={"code_block_" + node_id} className={"language-" + block_type}>
        { block_path && 
          <CodeHeader block_path={block_path} collapseHandler={collapseSections}
          triggerRef={attachCopyTrigger} /> 
        } 
        <div style={styles.blockBodyStyle}>
          { this.renderCodeSections() }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

With that done, I think we're ready to move deeper into our some of our other child components for this element.  I am satisfied for the moment with the refactoring we did for our `CodeHeader` component in chapter 15, so let's turn our attention next to `CodeSection`

``` javascript(/reactive-client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import {string, array, oneOf } from 'prop-types';

import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

const styles = {
  codeSectionStyle: {
    display: "table-row",
    padding: "0 5px",
    lineHeight: "100%"
  },
  codeGutterStyle: {
    display: "table-cell",
    padding: "0 5px"
  },
  codeBodyStyle: {
    margin: 0,
    display: "table-cell",
    width: "100%",
    paddingRight: "10px",
  }
};

class CodeSection extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string,
    priority: oneOf(["low","normal","high"])
  };
  
  constructor(props){
    super(props);
    this.state = {
      collapsed: props.priority === "low" ? true : false
    };
  }
  
+   toggleCollapse = (e) => 
+     this.props.priority === "low" && this.setState({collapsed: !this.state.collapsed});
+ 
+   setCollapse = (bool) =>
+     this.props.priority === "low" && this.setState({collapsed: bool});
+     //called by reference when +/- buttons are clicked in CodeHeader

  render() {
    let { section_id, priority } = this.props;
    let { collapsed } = this.state;
    let icon = collapsed ? "plus" : "minus"; 
    
    return (
      <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={styles.codeSectionStyle}>
        <div className="codeGutter" style={styles.codeGutterStyle}>
          <i className={"fa fa-"+ icon +"-square-o"}></i>
        </div>
        <div className="codeBody" style={styles.codeBodyStyle} id={section_id}>
          { collapsed ? <CodeCollapsed {...this.props} /> : <CodeFull {...this.props} /> }
        </div>
      </div>
    );
  }
}

export default CodeSection;
```

You should be comfortable with these changes at this point.  One thing to note though is that I'm refactoring a few of this component's methods to use an abbreviated arrow function syntax `() => return-value;` which implicitly returns the value of a function with a single line expression.  I'm using this syntax, combined with the short-circuit `&&` operator we introduced earlier to remove a large amount of bracket spaghetti caused by our function bodies, and the if-statements we had in our `toggleCollapse` and `setCollapse` methods.

Our last two components from this group `CodeCollapsed` and `CodeFull` don't need much work beyond adding a propTypes declaration, and a little cleanup with object destructuring.

``` javascript(/reactive-client/src/components/nodes/code_collapsed.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeCollapsed extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_collapsed"));
  }
  
  render() {
    let { contents, section_id, block_type } = this.props;
    return (
      <code id={section_id+"_collapsed"}>
        <pre className={block_type}>
          <div>
            {contents[0]} 
            <i className="fa fa-arrows-h" aria-hidden="true"></i>
            {contents[contents.length-1].trim()}
          </div>
        </pre>
      </code>
    );
  }
}

export default CodeCollapsed;
```

``` javascript(/reactive-client/src/components/nodes/code_full.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeFull extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_full"));
  }
  
  render() {
    let {section_id, contents, block_type } = this.props;
    return (
      <code id={section_id+"_full"}>
        <pre className={block_type}>{contents.join("\n")}</pre>
      </code>
    );
  }
}

export default CodeFull;
```

## Function Components

There's one other transformation I'm going to make to our components where we are able, and that is moving away from class components in favor of functions where possible.

I plan to use this format in my components where they don't need to maintain their own state, or have lifecycle methods we need to observe during their rendering, and these feature are not supported in function components (at least so far).  However they work quite well in cases where we have a purely visual component.

Let's look at an example; our `AlertList` component before and after the change.

``` javascript(/reactive-client/src/components/alert_list.js)
import React, { Component } from 'react';

alertStyle: {
  padding: "15px",
  marginBottom: "20px",
  border: "1px solid transparent",
  borderRadius: "4px"
},

alertLevels ={
  info: {
    backgroundColor: "#d9edf7",
    borderColor: "#bce8f1",
    color: "#31708f"
  },
  warning: {
    backgroundColor: "#fcf8e3",
    borderColor: "#faebcc",
    color: "#8a6d3b"
  },
  success: {
    backgroundColor: "#dff0d8",
    borderColor: "#d6e9c6",
    color: "#3c763d"
  },
  danger: {
    backgroundColor: "#f2dede",
    borderColor: "#ebccd1",
    color: "#a94442"
  }
};

class AlertList extends Component {
  renderAlertMessages = (alerts) => {
    return alerts.map((a) => 
      <div 
        key={a.timestamp}
        className={"alert alert-" + a.level }
        style={Object.assign(alertStyle,alertLevels[a.level])}
        children={a.message}
      />
    );
  }
  
  render() {
    return (
      <div className={"alert_list_" + this.props.scope}>
        { this.renderAlertMessages(this.props.alerts) }
      </div>
    );
  }
}

export default AlertList;
```

Overall our component is already fairly concise.  However, compare that to the refactored example below.

``` javascript(/reactive-client/src/components/alert_list.js)
import React, { Component } from 'react';
import {string, array} from 'prop-types';

const styles = {
  alertStyle: {
    padding: "15px",
    marginBottom: "20px",
    border: "1px solid transparent",
    borderRadius: "4px"
  },

  alertLevels: {
    info: {
      backgroundColor: "#d9edf7",
      borderColor: "#bce8f1",
      color: "#31708f"
    },
    warning: {
      backgroundColor: "#fcf8e3",
      borderColor: "#faebcc",
      color: "#8a6d3b"
    },
    success: {
      backgroundColor: "#dff0d8",
      borderColor: "#d6e9c6",
      color: "#3c763d"
    },
    danger: {
      backgroundColor: "#f2dede",
      borderColor: "#ebccd1",
      color: "#a94442"
    }
  }
};

AlertList.propTypes = {
  scope: string,
  alerts: array
};

function AlertList(props){
  let { scope, alerts } = props; 
  
  alerts = alerts.map((a) => {
    let ac = "alert alert-" + a.level;
    let as = Object.assign(styles.alertStyle,styles.alertLevels[a.level]);
    return <div key={a.timestamp} children={a.message} className={ac} style={as} />;
  });
  
  return <div className={"alert_list_" + scope}>{ alerts }</div>;
}

export default AlertList;
```

We're able to remove our render function entirely, since a function component will render its return value implicitly.  I've also stripped out the `renderAlertMessages` function declaration in favor of opperating directly on the list of alerts in our props to map the raw data into our `div` elements.  These two changes allow us to us one destructing call to make our prop values available accross the entire function body, and in turn mitigate the need to pass around data in method parameters such as `this.renderAlertMessages(this.props.alerts)`.

We're also able to declare our propTypes for the component above the function itself.  This is possible because Javascript's function hoisting ensure our function is defined and available before the rest of our script executes.  This allows us to keep a similar convention to our class components, where props are defined near the top of the component.

We also ave an advatage that a function compnent is by nature almost certain to be a "pure" component.  Pure components are typically defined as components that produce the same rendering each time they are passed the same property values (they are not influenced by states that exist outside the component).  This makes them a sinch too test, and also gives us a good indictation we've created a solid seperation of concerns between our visual and behavioral elemets

# Setting Up for Component Tests

Luckily, create-react app has done most of the heavy lift. 

We need to install a dependency for Enzyme:
```
npm i --save-dev enzyme enzyme-adapter-react-16
```

Start by setting up App.js with Enzyme configuration.

``` javascript(/reactive-client/src/App.test.js)
import React from 'react';
import {Provider} from 'react-redux';
import ReactDOM from 'react-dom';
+ import { configure } from 'enzyme';
+ import Adapter from 'enzyme-adapter-react-16';

import buildStore from './reducers/store';
import App from './App';

+ configure({ adapter: new Adapter() });

let { store } = buildStore();

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<Provider store={store}><App /></Provider>, div);
});
```

export the enzyme configuration to a module to avoid duplication.  Place in client root to make easily accessible.

``` javascript(/reactive-client/src/test_helper.js)
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

export default configure({ adapter: new Adapter() });
```

Test with snapshot to alert of changes, and use individual compnent checks to prodce more detailed test output on failures.

``` javascript(/reactive-client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  it("renders div#app", ()=>expect(wrapper.find("div#app").exists()).toBe(true));
  it("renders AlertList", ()=>expect(wrapper.find("Connect(AlertList)").exists()).toBe(true));
  it("renders RouterSwitch", ()=>expect(wrapper.find("Connect(RouterSwitch)").exists()).toBe(true));
  it("renders NavigationMenus", ()=>expect(wrapper.find("Connect(NavigationMenus)").exists()).toBe(true));
});
```

Remember that we can use javascript control statements to clean up these repetitive tests.

``` javascript(/reactive-client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  
+   let children = ["div#app","Connect(NavigationMenus)","Connect(RouterSwitch)","Connect(AlertList)"];
+   children.forEach((c) => it("renders " + c, ()=>expect(wrapper.find(c).exists()).toBe(true)));
});
```

chapterProvider creating an anyomous class `connect(Component)` is leading to a test failure.  To avoid ambiguity, let's refactor that container to set a name for the dynamically generated component.

``` javascript(/reactive-client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

+ const chapterProvider = (WrappedComponent) => {
+   const C = (props) => {
+     return props.chapters !== [] ?
+       <WrappedComponent {...props} active_chapter={props.active_chapter || {id: -1, title: ""}} /> :
+       null;
+   };
+   Object.defineProperty (C, 'name', {value: WrappedComponent.name});
+   return C;
+ };

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters.map((ch) => {
-     ch.title = ch.title.replace(/^chapter\s?/i,"");
-     return ch;
-   })
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

Let's apply what we've learned so far to another component `GitHubIcon`.  I am setting up a spec directory in my `components` folder for all of my component tests to live.  While previous I have place spec files in the same directory as the item under test, this becomes unwieldly with the number of component files we have.

See if you are comfortable with the following spec.

``` javascript(/reactive-client/src/components/spec/user_badge.spec.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

describe("<UserBadge />", () =>{
  it("renders GithubIcon on !props.username", ()=>{
    let wrapper = shallow(<UserBadge />);
    expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
  });
  
  it("renders ProfileIcon on props.username", ()=>{
    let wrapper = shallow(<UserBadge username="TestDude" />);
    expect(wrapper.find("ProfileIcon").exists()).toBe(true);
  });
})

describe("<ProfileIcon />",()=>{
  let wrapper = shallow(<ProfileIcon username="TestDude" avatar="someurl.png"/>)
  console.log(wrapper.debug())
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  })
});
```

The only difference in the spec above is that we are passing props to our components to examine the resulting rendering.  We can do this easily, using the same syntaax we always have in our JSX.  Only default component for this module uses the presence of a username to conditionally render either a sign in badge, or the user's GitHub Avatar after authentication.

Since `shallow` won't follow rendering into child components, we can import the `ProfileIcon` component directly, and shallow render it with some sample data to produce a more detailed shnapshot.  Sine this component isn't responsible for calling other child components, I'm content to forgoe querying for specific nodes inside the rendered component hierarchy.  

However, since this component is recieving event handlers from its parents, we should probably make sure that the passed functions are getting called as their cooresponding events trigger.  To do this, we can use Enzyme's simulated events, with a little help from Jest's mocks.

``` javascript(/reactive-client/src/components/spec/user_badge.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

- describe("<UserBadge />", () =>{
-   it("renders GithubIcon on !props.username", ()=>{
-     let wrapper = shallow(<UserBadge />);
-     expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
-   });
-   
-   it("renders ProfileIcon on props.username", ()=>{
-     let wrapper = shallow(<UserBadge username="TestDude" />);
-     expect(wrapper.find("ProfileIcon").exists()).toBe(true);
-   });
- });

describe("<ProfileIcon />",()=>{
+   let mockDispatch = jest.fn();
+   let mockHandler = jest.fn();
+   let wrapper = shallow(
+     <ProfileIcon username="TestDude" avatar="someurl.png"
+       dispatchSignalSignout={mockDispatch} handleSidebarVisibility={mockHandler} />
+   );
+   
+   it("calls function passed in dispatchSignalSignout on Signout click",()=>{
+     let link = wrapper.find("DropdownItem");
+     link.simulate("click");
+     expect(mockDispatch).toBeCalled();
+   });
+   
+   it("calls function passed in handleSidebarVisibility on focus",()=>{
+     let menubar = wrapper.find("Dropdown");
+     menubar.simulate("focus");
+     expect(mockHandler).toBeCalled();
+   });
  
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  });
});
```

Using the `find` method, we first locate the element with our event handlers attached.  Enzyme then supplies a very intuitive `simulate` method for triggers events such as clicks, focus, and others.  Once we trigger each event, we can expect the mock passed in our props to be called.

## Testing Stateful Components

Let's look at one of our more complex component's that carries its own internal state; `SideBarPopout`.  There are several UI interactions I want to have under test that all relate to the visibility of this component.  I want to ensure that the menu opens and closes according to the proper user actions.  

Before we get into tests for our state manipulation, let's set up tests to check our basic rendering.

``` javascript(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

const test_props = {
  chapters: [
    {id: 1, title: "Test Chapter 1"},
    {id: 2, title: "Test Chapter 2"}
  ],
  active_chapter: {id: 2, title: "Test Chapter 1"},
  dispatchRouteChapter: jest.fn()
};

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

describe("<SideBarPopout /> rendering",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("renders a link for each chapter", () =>{
    test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
  });
  
  it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
  it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
  it("renders according to snapshot",() => expect(w).toMatchSnapshot());
});
```

This should all be understandable to you.  We're doing some simple check to ensure we are rendering all the expected nodes: a link for each chapter, our signout component, a close link, and finally a snapshot to give us some high level alerting if this components rendering changes unexpectedly.

I'm introducing a small helper function `expectXInY`, because I am finding myself using the `expect(wrapper.find("selector").exists()).toBe(true)` evaluation reptitively, and it's a rather verbose chain.  Setting up a small helper allows me to keep my examples a little more concise.  I plan to migrate this to our `test_helper` file after this example so I can import this helper method in other spec files.

Now we can take a first look at testing some state changes.  Before we get to our UI interaction though, I want to put one of this component's instance method under test directly.

``` javascript(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

describe("SideBarPopout.toggleVisibility", ()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("reverses visibilty if specific value not given", () => {
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(false);
  });
  
  it("assigns visibility specified", () =>{
    w.instance().toggleVisibility(true);
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility(false);
    expect(w.state("visible")).toBe(false);
  });
});
```

Enzyme provides a method `instance` on all our wrappers that will allow us to interact with the specific instance of our component inside our wrapper.  Once we have that instance, we can user normal method chaining to activate instance methods of the component; in this case `toggleVisibility`.

I am starting with this test so that we can ensure this certral function is impacting the state as we expect.  It should either flip the current visibilty value to it's inverse, or assign the specific visibility if one is passed to the method.  We then use another Enzyme method `getState` to as you might expect, get our state.

Now we can turn to some UI interactions.

``` javascrip(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

- describe("SideBarPopout.toggleVisibility", ()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("reverses visibilty if specific value not given", () => {
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(false);
-   });
-   
-   it("assigns visibility specified", () =>{
-     w.instance().toggleVisibility(true);
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility(false);
-     expect(w.state("visible")).toBe(false);
-   });
- });
  
describe("<SideBarPopout /> visible state",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("defaults to hidden", () => expectXInY("Sidebar[visible=false]",w));
  
  describe("will",()=>{
    beforeEach(() => {
      w.setState({visible: true});
      w.update();
    });
    
    it("change to visibility = false, and dispatch chapter route on chapter link",()=>{
      w.find("MenuItem[name='chapter1']").simulate("click");
      expectXInY("Sidebar[visible=false]",w);
      expect(test_props.dispatchRouteChapter).toBeCalled();
    });
    
    ["MenuItem[name='Close Menu']","SidebarPusher"].forEach(t =>{
      it("change to visibility = false on click of " + t,()=>{
        t = w.find(t);
        t.simulate("click");
        expectXInY("Sidebar[visible=false]",w);
      });
    });
    
    it("not change on click of MenuItem[link=false]", () => {
      w.find("MenuItem[link=false]").simulate("click");
      expectXInY("Sidebar[visible=true]",w);
    });
  });
});
```

The behaviors I want to put under test for our UI all apply when the component is in it's open state.  However, our component actually defaults to it's hidden state, so we'll need to do some setup before each of our test cases.  Before we do that though, its worth checking that our default is behaving as expected.

With that done, we can use a `beforeEach` to setup the component as we need it for all our other test cases.  To do this we will use `setState` to toggle our visibility to `true`, and then call an `update` method on our wrapper to trigger it to render again with this new state in place.  We need that explicit call to `update` because shallow rendered components don't rerender if our state changes.  We haven't run into this previously, because Enzyme automatically calls `update` on our wrapper after each simulated event.  However, when working with instance methods or setting state directly, we need to intercede and manually tell enzyme we want it to update.

With our component now visible, we can check our sidebar is holding or updating this state appropriatly.  Our link to chapter one, when clicked, should cause the menu to close, and also invoke our `dispatchRouteChapter` mock.  The Signout link, close link, and clicks of the layer's faded area off-menu should also set our visibilty to `false`.  However, our link ddenoting the current active chapter which is disable should **not** cause the siddebar to close when clicked.