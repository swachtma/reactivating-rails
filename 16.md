# Chapter 16: Refactor and Test

## Jumping in Here

If you have not been following along with code examples and wanted to jump in here, you can use our [Chapter16Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter16Starter) branch as a place to join in.

## Author's Note

As I move into this chapter, I am taking a moment to update to the latest available `react-scripts`.  This step is optional if you are following along in your application.  As I prepare for launch, I wanted to ensure I was working with the latest stable release of this package, since it is central to my application.

## Setting Up ESLint

I'm going to be running ESLint frequently as I move through this refactor to clean up some of my code.  I want to trigger lint to run from my command line, which is not currently supported by `react-scripts` natively.  However, we can make some quick edits to our `package.json` file to enable this functionality.

``` json(/reactive-client/package.json)
{
  "name": "reactive-client",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://138.197.14.5:3000",
  "dependencies": {
    "axios": "^0.16.2",
    "clipboard": "^1.7.1",
    "history": "^4.7.2",
    "markdown-it": "^8.4.0",
    "react": "^16.3.1",
    "react-dom": "^16.3.1",
    "react-redux": "^5.0.6",
    "react-scripts": "1.1.4",
    "redux": "^3.7.2",
    "redux-first-router": "0.0.16-next",
    "redux-first-router-link": "^1.4.1",
    "redux-first-router-restore-scroll": "^1.2.1",
    "redux-persist": "^5.5.0",
    "redux-saga": "^0.16.0",
    "semantic-ui-react": "^0.75.1"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test --env=jsdom",
    "eject": "react-scripts eject",
+     "lint": "node_modules/eslint/bin/eslint.js src"
  },
  "devDependencies": {
    "chai": "^4.1.2",
    "redux-devtools-extension": "^2.13.2"
  }
}
```

Typically, you would want to run ESlint's `--init` command to generate a configuration file.  However, we are going to generate a config file manually, and use it to extend an existing configuration for React apps.

``` javascript(/reactive-client/.eslintrc.js)
module.exports = {
  "extends": "./node_modules/eslint-config-react-app/index.js",
  "rules"  : {
    "key-spacing": [
      "error"
    ]
  }
}
```

Now you can run your lint with the command `npm run lint`.  Be aware, if you have lint errors among files you check with this command, NPM is going to bark an error at you.  Don't worry, that's normal.  When your lint rules find an error, they return an error code to NPM, which in turn warns you of the failure.  This error is useful if you are planning to add this linting step to a more substantial build task, and you don't want the task to proceed if your lint fails.  However, the errors it produces when manually executing your lint can be misleading.

## Declaring Proptypes

As we refactor, we are also going to add PropType declarations to our components.  PropTypes allow us to declare expected props of each component and define what primitive type we expect in each.  The advantage of doing this is twofold; for one, it helps to alert us if our components suddenly begin to receive data in an unsupported format.  Also, having a PropType declaration helps us understand what each component needs to receive to render correctly.

PropTypes once shipped as part of `React` itself, however, it now lives in a separate dependency, and we need to include it explicitly.

``` javascript
import PropTypes from 'prop-types';
```

## Conventions for this Chapter

I'm going to approach this chapter differently than previous examples.  Until now, I have documented and explained almost every change I have made to our application.  Now, seeking to make an application wide refactor, that becomes impractical.  This chapter I am going to focus on files that best demonstrate concepts I am introducing. Use this as an opportunity to take a look at other components yourself, and try a refactor on your own.  If you want to then compare your work to my own, check out the GitHub tag for the next chapter's starter to see where I landed.

## Refactoring for Clarity

I'm going to start this process by revisiting our CodeBlock component and attempting to clarify its design.  The CodeBlock component is our most complex presentational component; it relies on several external classes (`CodeFence` and `CodeSection`) to parse and prepare its props.  Then the CodeBlock component itself leverages several other child components, such as CodeSection and CodeHeader to divide the visual layout into manageable pieces. It also contains instructions from the Responsive component we worked with during our last chapter.  To make things a little more complicated, we also use lifecycle methods inside several of our child components to run HighlightJS' syntax highlighting.

While I think we've done a reasonably good job of dividing our lines of work into logical units, I think we could still make some improvements.

Let's start at the top and make our way down the rendering tree.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeHeader from './code_header';
import CodeSection from './code_section';

const styles = {
 codeBlockStyle: {
   marginBottom: "16px"
 },
 blockBodyStyle: {
   padding: "10px 0",
   border: "1px solid #021a40",
   backgroundColor: "#f8f8f8",
   overflowX: "scroll"
 }
};

class CodeBlock extends Component {
+   static propTypes = {
+     node: shape({ id: number, content: string }).isRequired
+   };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
+     this.section_refs = [];
  }
  
  componentDidMount(){
  if(this.triggerCopy){
    let button = this.triggerCopy.querySelector("button.copy");
    return new clipboardJS(button, {
      text: () => this.code_fence.copy
    });
  }
  }
  
  renderCodeSections = (sections) => {
    return Array.from(sections, s => {
      return(
        <CodeSection ref={s => this.section_refs.push(s)} block_type={this.code_fence.block_type}
        priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
      );
    });
  };
  
  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  };
  
+   render() {
+     let {node_id, block_type, block_path, sections} = this.code_fence;
+     return (
+       <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
+       id={"code_block_" + node_id} className={"language-" + block_type}>
+         { block_path && 
+           <CodeHeader block_path={block_path} collapseHandler={this.collapseSections}
+           triggerRef={(trigger) => this.triggerCopy = trigger} /> 
+         } 
+         <div style={styles.blockBodyStyle}>
+           { this.renderCodeSections(sections) }
+         </div>
+       </div>
+     );
  }
}

export default CodeBlock;
```

I've reorganized my imports at the top of this file to ensure I import my dependencies first, followed by a line break, and then my internal files.  I have also restructured my CSS objects to all belong to a single `styles` object as we saw in previous chapters.

In our component class, we now have our first use of `prop-types`.  Notice that my import from the `prop-types` dependency lists the individual types I am using in this component, rather than the entire library.  That saves me from the need to chain all of my declarations through `propTypes`.  In this case, I am using shape to declare that my component must receive an object with a numeric ID, and a string of contents.  I've placed this block above my constructor so that it is immediately clear what props my component requires.

I moved our declaration of `this.section_refs = []` inside our constructor. This instance value was defined previously inside our `renderCodeSections` method, but for clarity, I want to have all my instance values for the class declared in my constructor.

Our render method is now using object destructing, similar to how we have destructured our props in the previous chapter.  Here, we are destructing `this.code_fence`, to make the parsed values returned by our class more accessible.  This change allows us to remove a lot of `this.code_fence.somethingelse` noise from our rendered content.

Finally, our render method has abandoned our `renderHeaderIf` method entirely.  This function's only job was to perform a test that a `block_path` was available for the node, and if so print a `CodeHeader`.  Having an extra instance method on our class for such a small job seemed silly in hindsight when we can easily perform the test in our component's render method.  I've adopted a short-circuit `&&` evaluation to perform this logic test.  Used in this context, the `&&` operator only evaluates its right side if the left side evaluates truthy.  In this case, we leverage this to conditionally print a streamlined `if` test that has no `else` condition (where we might instead use the ternary operator).

## How Stuff Works Vs. How Stuff Looks

There's another change for this component that's gnawing at me.  `CodeBlock` contains a large amount of behavioral code.  We're supplying our collapse and expand method, binding our copy/paste action using the component's lifecycle method, and preparing data using our `CodeFence` and `CodeSection` classes.  There's nothing technically wrong about this, but it's creating noise that makes it difficult to parse out what's happening in the component.  If we want to make presentational changes in the future, we'll need to do so amidst all of that confusion.

Previously we've used container components primarily to create a layer between Redux and our application.  However, a more flexible definition of containers would give them purview over how our components behave; leaving our components free to dictate how things look.

`CodeBlock` is doing a lot of both.  I am going to refactor again to split out a container `CodeExample` to handle these behavioral tasks.  We'll also relocate the data cleanup classes currently living in `components/lib` to the container directory to clarify their purpose.  Here's how that looks.

``` javascript(/reactive-client/src/containers/code_example.js)
import React, { Component } from 'react';
import { shape, number, string } from 'prop-types';
import clipboardJS from 'clipboard';

import CodeFence from './lib/code_fence';
import CodeBlock from '../components/nodes/code_block';

class CodeExample extends Component {
  static propTypes = {
    node: shape({ id: number, content: string }).isRequired
  };
  
  constructor(props){
    super(props);
    this.code_fence = new CodeFence(props.node);
    this.section_refs = [];
  }
  
  componentDidMount(){
    if(this.triggerCopy){
      let button = this.triggerCopy.querySelector("button.copy");
      return new clipboardJS(button, {
        text: () => this.code_fence.copy
      });
    }
  }

  collapseSections = (bool) => {
    this.section_refs.forEach((ref) => {
      if(ref){ ref.setCollapse(bool) }
    });
  }
  
+   addSectionRef = s => this.section_refs.push(s);
  
+   attachCopyTrigger = (trigger) => this.triggerCopy = trigger;
  
  render() {
    return (
+       <CodeBlock 
+         node={this.code_fence} section_refs={this.section_refs}
+         collapseSections={this.collapseSections} addSectionRef={this.addSectionRef}
+         attachCopyTrigger={this.attachCopyTrigger}
+       />
    );
  }
}

export default CodeExample;
```

Most of this code is a direct migration from our `CodeBlock` component.  Our render method is simply calling our original `CodeBlock` and passing through the items it needs as props.

There's one small change, we've added two new functions `addSectionRef` and `attachCopyTrigger` to this container so that we can pass them as props.  Previously, `CodeBlock` defined these functions inline as props such as `triggerRef={(trigger) => this.triggerCopy = trigger}`.  This pattern creates a weakness in our render cycle that recreates new instances of these functions each time the component rerenders.  By passing them as props from a parent, we can mitigate that problem, and allow all our child components to use the same function provided by the parent. We also remove noise from our child components.

Here's what `CodeBlock` looks like after these changes.

``` javascript(/reactive-client/src/components/nodes/code_block.js)
import React, { Component } from 'react';
import { shape, number, string, array, func } from 'prop-types';

import CodeHeader from './code_header';
import CodeSection from './code_section';

const styles = {
  codeBlockStyle: {
    marginBottom: "16px"
  },
  blockBodyStyle: {
    padding: "10px 0",
    border: "1px solid #021a40",
    backgroundColor: "#f8f8f8",
    overflowX: "scroll"
  }
};

class CodeBlock extends Component {
  static propTypes = {
    collapseSections: func,
    attachCopyTrigger: func,
    node: shape(
      { node_id: number, block_type: string, block_path: string, sections: array }
    ).isRequired
  };

  renderCodeSections = () => {
    let { addSectionRef, node } = this.props;
    return Array.from(node.sections, s => 
      <CodeSection ref={addSectionRef} block_type={node.block_type} 
      priority={s.priority} contents={s.contents} key={s.section_id} section_id={s.section_id} />
    );
  };
  
  render() {
    let { collapseSections, attachCopyTrigger, node } = this.props;
    let { node_id, block_type, block_path } = node;

    return (
      <div style={styles.codeBlockStyle} key={"code_fence_" + node_id}
      id={"code_block_" + node_id} className={"language-" + block_type}>
        { block_path && 
          <CodeHeader block_path={block_path} collapseHandler={collapseSections}
          triggerRef={attachCopyTrigger} /> 
        } 
        <div style={styles.blockBodyStyle}>
          { this.renderCodeSections() }
        </div>
      </div>
    );
  }
}

export default CodeBlock;
```

I think we're ready to move deeper into our some of our other child components for this element.  I am satisfied for the moment with the refactoring we did for our `CodeHeader` component in chapter 15, so let's turn our attention next to `CodeSection`.

``` javascript(/reactive-client/src/components/nodes/code_section.js)
import React, { Component } from 'react';
import {string, array, oneOf } from 'prop-types';

import CodeFull from './code_full';
import CodeCollapsed from './code_collapsed';

const styles = {
  codeSectionStyle: {
    display: "table-row",
    padding: "0 5px",
    lineHeight: "100%"
  },
  codeGutterStyle: {
    display: "table-cell",
    padding: "0 5px"
  },
  codeBodyStyle: {
    margin: 0,
    display: "table-cell",
    width: "100%",
    paddingRight: "10px",
  }
};

class CodeSection extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string,
    priority: oneOf(["low","normal","high"])
  };
  
  constructor(props){
    super(props);
    this.state = {
      collapsed: props.priority === "low" ? true : false
    };
  }
  
+   toggleCollapse = (e) => 
+     this.props.priority === "low" && this.setState({collapsed: !this.state.collapsed});
+ 
+   setCollapse = (bool) =>
+     this.props.priority === "low" && this.setState({collapsed: bool});
+     //called by reference when +/- buttons are clicked in CodeHeader

  render() {
    let { section_id, priority } = this.props;
    let { collapsed } = this.state;
    let icon = collapsed ? "plus" : "minus"; 
    
    return (
      <div className={priority+"PrioritySection"} onClick={this.toggleCollapse} style={styles.codeSectionStyle}>
        <div className="codeGutter" style={styles.codeGutterStyle}>
          <i className={"fa fa-"+ icon +"-square-o"}></i>
        </div>
        <div className="codeBody" style={styles.codeBodyStyle} id={section_id}>
          { collapsed ? <CodeCollapsed {...this.props} /> : <CodeFull {...this.props} /> }
        </div>
      </div>
    );
  }
}

export default CodeSection;
```

You should be comfortable with these changes at this point.  One thing to note though is that I'm refactoring a few of this component's methods to use an abbreviated arrow function syntax `() => return-value;` which implicitly returns the value of a function with a single line expression.  I'm using this syntax, combined with the short-circuit `&&` operator we introduced earlier to remove a large amount of bracket spaghetti caused by our function bodies, and the if-statements we had in our `toggleCollapse` and `setCollapse` methods.

Our last two components from this group `CodeCollapsed` and `CodeFull` don't need much work beyond adding a propTypes declaration, and a little cleanup with object destructuring.

``` javascript(/reactive-client/src/components/nodes/code_collapsed.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeCollapsed extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_collapsed"));
  }
  
  render() {
    let { contents, section_id, block_type } = this.props;
    return (
      <code id={section_id+"_collapsed"}>
        <pre className={block_type}>
          <div>
            {contents[0]} 
            <i className="fa fa-arrows-h" aria-hidden="true"></i>
            {contents[contents.length-1].trim()}
          </div>
        </pre>
      </code>
    );
  }
}

export default CodeCollapsed;
```

``` javascript(/reactive-client/src/components/nodes/code_full.js)
/* global hljs */
import React, { Component } from 'react';
import {array, string} from 'prop-types';

class CodeFull extends Component {
  static propTypes = {
    section_id: string.isRequired,
    contents: array.isRequired,
    block_type: string.isRequired
  }
  
  componentDidMount(){
    hljs.highlightBlock(document.getElementById(this.props.section_id+"_full"));
  }
  
  render() {
    let {section_id, contents, block_type } = this.props;
    return (
      <code id={section_id+"_full"}>
        <pre className={block_type}>{contents.join("\n")}</pre>
      </code>
    );
  }
}

export default CodeFull;
```

## Function Components

There's one other transformation I'm going to make to our components where we are able, and that is moving away from class components in favor of functions where possible.

I plan to use this format in my components where they don't need to maintain state or have lifecycle methods we need to observe during their rendering.  These features are unsupported in function components (at least so far).  However, they work quite well in cases where we have a purely visual component.

Let's look at an example; our `AlertList` component before and after the change.

``` javascript(/reactive-client/src/components/alert_list.js)
import React, { Component } from 'react';

alertStyle: {
  padding: "15px",
  marginBottom: "20px",
  border: "1px solid transparent",
  borderRadius: "4px"
},

alertLevels ={
  info: {
    backgroundColor: "#d9edf7",
    borderColor: "#bce8f1",
    color: "#31708f"
  },
  warning: {
    backgroundColor: "#fcf8e3",
    borderColor: "#faebcc",
    color: "#8a6d3b"
  },
  success: {
    backgroundColor: "#dff0d8",
    borderColor: "#d6e9c6",
    color: "#3c763d"
  },
  danger: {
    backgroundColor: "#f2dede",
    borderColor: "#ebccd1",
    color: "#a94442"
  }
};

class AlertList extends Component {
  renderAlertMessages = (alerts) => {
    return alerts.map((a) => 
      <div 
        key={a.timestamp}
        className={"alert alert-" + a.level }
        style={Object.assign(alertStyle,alertLevels[a.level])}
        children={a.message}
      />
    );
  }
  
  render() {
    return (
      <div className={"alert_list_" + this.props.scope}>
        { this.renderAlertMessages(this.props.alerts) }
      </div>
    );
  }
}

export default AlertList;
```

Overall our component is already reasonably concise.  However, compare that to the refactored example below.

``` javascript(/reactive-client/src/components/alert_list.js)
import React, { Component } from 'react';
import {string, array} from 'prop-types';

const styles = {
  alertStyle: {
    padding: "15px",
    marginBottom: "20px",
    border: "1px solid transparent",
    borderRadius: "4px"
  },

  alertLevels: {
    info: {
      backgroundColor: "#d9edf7",
      borderColor: "#bce8f1",
      color: "#31708f"
    },
    warning: {
      backgroundColor: "#fcf8e3",
      borderColor: "#faebcc",
      color: "#8a6d3b"
    },
    success: {
      backgroundColor: "#dff0d8",
      borderColor: "#d6e9c6",
      color: "#3c763d"
    },
    danger: {
      backgroundColor: "#f2dede",
      borderColor: "#ebccd1",
      color: "#a94442"
    }
  }
};

AlertList.propTypes = {
  scope: string,
  alerts: array
};

function AlertList(props){
  let { scope, alerts } = props; 
  
  alerts = alerts.map((a) => {
    let ac = "alert alert-" + a.level;
    let as = Object.assign(styles.alertStyle,styles.alertLevels[a.level]);
    return <div key={a.timestamp} children={a.message} className={ac} style={as} />;
  });
  
  return <div className={"alert_list_" + scope}>{ alerts }</div>;
}

export default AlertList;
```

We're able to remove our render function entirely since a function component renders its return value implicitly.  I've also stripped out the `renderAlertMessages` function declaration in favor of operating directly on the list of alerts in our props to map the raw data into our `div` elements.  These two changes allow us to us one destructing call to make our prop values available across the entire function body, and in turn, mitigate the need to pass around data in method parameters such as `this.renderAlertMessages(this.props.alerts)`.

Javascript's function hoisting ensures our function is defined and available before the rest of our script executes.  So we can keep a similar convention to our class components, defining props near the top of the component.

## Setting Up for Component Tests

Our components are the one area of our application flying completely untested.  Now that we have settled our visual design, I think its time I stopped stalling and placed some of the critical aspects of our UI under test.  Luckily, create-react-app has done most of the heavy lifting by making Jest available to us.  However, I am going to add a library, `enzyme` to help us render our components in isolation so we can test some assumptions about each.

We need to use NPM to install a dependency for Enzyme, and an adaptor to allow it to work with our specific version of React:

```
npm i --save-dev enzyme enzyme-adapter-react-16
```

To get a sense of how Enzyme works, let's start by setting up App.js with an Enzyme configuration.

``` javascript(/reactive-client/src/App.test.js)
import React from 'react';
import {Provider} from 'react-redux';
import ReactDOM from 'react-dom';
+ import { configure } from 'enzyme';
+ import Adapter from 'enzyme-adapter-react-16';

import buildStore from './reducers/store';
import App from './App';

+ configure({ adapter: new Adapter() });

let { store } = buildStore();

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<Provider store={store}><App /></Provider>, div);
});
```

We're going to need this setup and dependency management inside each of our component tests.  To make that easier to manage, export the enzyme configuration to a module.  We'll place this helped in our client root to make it easily accessible.

``` javascript(/reactive-client/src/test_helper.js)
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

export default configure({ adapter: new Adapter() });
```

Enzyme provides us with several rendering options to help us test our components.  Whenever possible, I use the `shallow` method, which renders the component we pass it directly, without spinning through each of the children that might otherwise render in our tree.

Limited child rendering minimizes the amount of mocking needed to test our components.  Instead of trying to test our entire component tree in one mass, we render each component in isolation and focus our tests on what that individual component is responsible for managing.

 A querying method `find`  helps check that our components are rendering the correct children when we need specific validation. For higher level observation, we can lean on Jest's `toMatchSnapShot()`.

``` javascript(/reactive-client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  it("renders div#app", ()=>expect(wrapper.find("div#app").exists()).toBe(true));
  it("renders AlertList", ()=>expect(wrapper.find("Connect(AlertList)").exists()).toBe(true));
  it("renders RouterSwitch", ()=>expect(wrapper.find("Connect(RouterSwitch)").exists()).toBe(true));
  it("renders NavigationMenus", ()=>expect(wrapper.find("Connect(NavigationMenus)").exists()).toBe(true));
});
```

Here we are testing that our `App` component is rendering each of its expected children.  However, it pays to remember that we can use javascript control statements to clean up these repetitive tests.

``` javascript(/reactive-client/src/App.test.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from './test_helper';
import App from './App';

describe("<App />", ()=>{
  const wrapper = shallow(<App />);
  it('matches the snapshot', () => { expect(wrapper).toMatchSnapshot(); });
  
+   let children = ["div#app","Connect(NavigationMenus)","Connect(RouterSwitch)","Connect(AlertList)"];
+   children.forEach((c) => it("renders " + c, ()=>expect(wrapper.find(c).exists()).toBe(true)));
});
```
These tests are almost right, but we have a weakness in `chapterProvider` whereby creating an anonymous class, `connect(Component)` is leading to a test failures.  To avoid ambiguity, let's refactor that container to set a name for the dynamically generated component.  This will help us test and debug our code by giving our applications concrete names to identify each item.

``` javascript(/reactive-client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => {
   return connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));
};

+ const chapterProvider = (WrappedComponent) => {
+   const C = (props) => {
+     return props.chapters !== [] ?
+       <WrappedComponent {...props} active_chapter={props.active_chapter || {id: -1, title: ""}} /> :
+       null;
+   };
+   Object.defineProperty (C, 'name', {value: WrappedComponent.name});
+   return C;
+ };

- const mapStateToProps = (state) => ({
-   active_chapter: state.chapters.find(
-    (chapter) => chapter.id === state.settings.active_chapter_id
-   ),
-   
-   next_chapter: state.chapters.find(
-   (chapter) => chapter.id === state.settings.active_chapter_id + 1
-   ),
-   
-   chapters: state.chapters.map((ch) => {
-     ch.title = ch.title.replace(/^chapter\s?/i,"");
-     return ch;
-   })
- });

- const mapDispatchToProps = (dispatch) => ({
-   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
- });

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

Let's apply what we've learned so far to another component, `GitHubIcon`.  I am setting up a spec directory in my `components` folder for all of my component tests to live.  Previously, I have placed spec files in the same directory as the item under test.  This folder structure becomes unwieldy with the number of component files we have.

See if you are comfortable with the following spec.

``` javascript(/reactive-client/src/components/spec/user_badge.spec.js)
/* global expect */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

describe("<UserBadge />", () =>{
  it("renders GithubIcon on !props.username", ()=>{
    let wrapper = shallow(<UserBadge />);
    expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
  });
  
  it("renders ProfileIcon on props.username", ()=>{
    let wrapper = shallow(<UserBadge username="TestDude" />);
    expect(wrapper.find("ProfileIcon").exists()).toBe(true);
  });
})

describe("<ProfileIcon />",()=>{
  let wrapper = shallow(<ProfileIcon username="TestDude" avatar="someurl.png"/>)
  console.log(wrapper.debug())
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  })
});
```

The only difference in the spec above is that we are passing props to our components to examine the resulting rendering.  We can do this using the same syntax we always have in our JSX.  

Our default component for this module uses the presence of a username to conditionally render either a sign-in badge or the user's GitHub Avatar after authentication.

Since `shallow` won't follow rendering into child components, we can import the `ProfileIcon` component directly, and shallow render it with some sample data to produce a more detailed snapshot.  Since this component isn't responsible for calling other child components, I'm content to forgo querying for specific nodes inside the rendered component hierarchy.  

However, since this component is receiving event handlers from its parents, we should probably make sure that the passed functions are getting called as their corresponding events trigger.  To do this, we can use Enzyme's simulated events, with a little help from Jest's mocks.

``` javascript(/reactive-client/src/components/spec/user_badge.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import UserBadge, { ProfileIcon } from '../user_badge';

- describe("<UserBadge />", () =>{
-   it("renders GithubIcon on !props.username", ()=>{
-     let wrapper = shallow(<UserBadge />);
-     expect(wrapper.find("Connect(GithubIcon)").exists()).toBe(true);
-   });
-   
-   it("renders ProfileIcon on props.username", ()=>{
-     let wrapper = shallow(<UserBadge username="TestDude" />);
-     expect(wrapper.find("ProfileIcon").exists()).toBe(true);
-   });
- });

describe("<ProfileIcon />",()=>{
+   let mockDispatch = jest.fn();
+   let mockHandler = jest.fn();
+   let wrapper = shallow(
+     <ProfileIcon username="TestDude" avatar="someurl.png"
+       dispatchSignalSignout={mockDispatch} handleSidebarVisibility={mockHandler} />
+   );
+   
+   it("calls function passed in dispatchSignalSignout on Signout click",()=>{
+     let link = wrapper.find("DropdownItem");
+     link.simulate("click");
+     expect(mockDispatch).toBeCalled();
+   });
+   
+   it("calls function passed in handleSidebarVisibility on focus",()=>{
+     let menubar = wrapper.find("Dropdown");
+     menubar.simulate("focus");
+     expect(mockHandler).toBeCalled();
+   });
  
  it("renders according to snapshot",()=>{
    expect(wrapper).toMatchSnapshot();
  });
});
```

Using the `find` method, we first locate the element with our event handlers attached.  Enzyme then supplies a very intuitive `simulate` method for triggering events such as clicks, focus, and others.  Once we trigger each event, we expect a call on the mock passed in our props.

## Testing Stateful Components

Let's look at one of our more complex component's that carries an internal state; `SideBarPopout`.  There are several UI interactions I want to have under test that all relate to the visibility of this component.  I want to ensure that the menu opens and closes according to the proper user actions.  

Before we get into tests for our state manipulation, let's set up tests to check our basic rendering.

``` javascript(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

const test_props = {
  chapters: [
    {id: 1, title: "Test Chapter 1"},
    {id: 2, title: "Test Chapter 2"}
  ],
  active_chapter: {id: 2, title: "Test Chapter 1"},
  dispatchRouteChapter: jest.fn()
};

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

describe("<SideBarPopout /> rendering",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("renders a link for each chapter", () =>{
    test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
  });
  
  it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
  it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
  it("renders according to snapshot",() => expect(w).toMatchSnapshot());
});
```

We're doing some simple check to ensure we are rendering all the expected nodes: a link for each chapter, our signout component, a close link, and finally a snapshot to give us some high level alerting if this component's rendering changes unexpectedly.

I'm introducing a small helper function `expectXInY`, because I am finding myself using the `expect(wrapper.find("selector").exists()).toBe(true)` evaluation repetitively, and it's a rather verbose chain.  Setting up a small helper allows me to keep my examples concise.  I plan to migrate this to our `test_helper` file after this example so I can import this helper method in other spec files.

Now we can take a first look at testing some state changes.  Before we get to our UI interactions though, I want to put one of this component's instance method under test directly.

``` javascript(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

describe("SideBarPopout.toggleVisibility", ()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("reverses visibilty if specific value not given", () => {
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility();
    expect(w.state("visible")).toBe(false);
  });
  
  it("assigns visibility specified", () =>{
    w.instance().toggleVisibility(true);
    expect(w.state("visible")).toBe(true);
    w.instance().toggleVisibility(false);
    expect(w.state("visible")).toBe(false);
  });
});
```

Enzyme provides a method `instance` on all our wrappers which allows us to interact with the specific instance of our component.  Once we have that instance, we can use normal method chaining to activate instance methods of the component; in this case `toggleVisibility`.

I am starting with this test so that we can ensure this central function is impacting the state as we expect.  It should either flip the current visibility value to its inverse or assign a specific visibility state passed to the method.  We then use another Enzyme method `getState` to (as you might expect), get our state.

Now we can turn to some UI interactions.

``` javascrip(/reactive-client/src/components/spec/side_bar_popout.spec.js)
/* global expect, jest */
import React from 'react';
import ReactDOM from 'react-dom';
import { shallow } from 'enzyme';

import config from '../../test_helper';
import SideBarPopout from '../side_bar_popout';

- const test_props = {
-   chapters: [
-     {id: 1, title: "Test Chapter 1"},
-     {id: 2, title: "Test Chapter 2"}
-   ],
-   active_chapter: {id: 2, title: "Test Chapter 1"},
-   dispatchRouteChapter: jest.fn()
- };

//helper method for the many prescence checks we want to prefrom
const expectXInY = (e,w) => expect(w.find(e).exists()).toBe(true);

- describe("<SideBarPopout /> rendering",()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("renders a link for each chapter", () =>{
-     test_props.chapters.forEach(c => expectXInY('MenuItem[name="chapter'+c.id+'"]',w));
-   });
-   
-   it("renders Connect(SideBarSignout)", () => expectXInY("Connect(SideBarSignout)",w));
-   it("renders a close link for the menu", () => expectXInY("MenuItem[name='Close Menu']",w));
-   it("renders according to snapshot",() => expect(w).toMatchSnapshot());
- });

- describe("SideBarPopout.toggleVisibility", ()=>{
-   let w = shallow(<SideBarPopout {...test_props} />);
-   it("reverses visibilty if specific value not given", () => {
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility();
-     expect(w.state("visible")).toBe(false);
-   });
-   
-   it("assigns visibility specified", () =>{
-     w.instance().toggleVisibility(true);
-     expect(w.state("visible")).toBe(true);
-     w.instance().toggleVisibility(false);
-     expect(w.state("visible")).toBe(false);
-   });
- });
  
describe("<SideBarPopout /> visible state",()=>{
  let w = shallow(<SideBarPopout {...test_props} />);
  it("defaults to hidden", () => expectXInY("Sidebar[visible=false]",w));
  
  describe("will",()=>{
    beforeEach(() => {
      w.setState({visible: true});
      w.update();
    });
    
    it("change to visibility = false, and dispatch chapter route on chapter link",()=>{
      w.find("MenuItem[name='chapter1']").simulate("click");
      expectXInY("Sidebar[visible=false]",w);
      expect(test_props.dispatchRouteChapter).toBeCalled();
    });
    
    ["MenuItem[name='Close Menu']","SidebarPusher"].forEach(t =>{
      it("change to visibility = false on click of " + t,()=>{
        t = w.find(t);
        t.simulate("click");
        expectXInY("Sidebar[visible=false]",w);
      });
    });
    
    it("not change on click of MenuItem[link=false]", () => {
      w.find("MenuItem[link=false]").simulate("click");
      expectXInY("Sidebar[visible=true]",w);
    });
  });
});
```

The behaviors I want to put under test for our UI all apply when the component is in its open state.  However, our component defaults to its hidden state.  We need to do some setup before each of our test cases.  Before we do that though, it's worth checking that our default is behaving as expected.

With that done, we can use a `beforeEach` to set up the component as we need it for all our other test cases.  Using `setState`, we toggle our visibility to `true`, and then call an `update` method on our wrapper to trigger it to render again with this new state in place.  We need that explicit call to `update` because shallow rendered components don't re-render if our state changes.  We haven't run into this previously, because Enzyme automatically calls `update` on our wrapper after each simulated event.  However, when working with instance methods or setting state directly, we need to intercede and manually tell enzyme we want it to update.

With our component now visible, we can check our sidebar is holding or updating this state appropriately.  Our link to chapter one, when clicked, should cause the menu to close, and also invoke our `dispatchRouteChapter` mock.  The Signout link, close link, and clicks of the layer's faded area off-menu should also set our visibility to `false`.  However, our link denoting the current active chapter which is disabled should **not** cause the sidebar to close when clicked.

## Critical Container Refactors

Before we wrap, we need to look into a few of our container elements to correct a serious error I made in my initial design.  Have a look at the example below and see if you can spot the problem.

``` javascript(/reactive-client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

const filtered_nodes = (nodes, chapter) => {
  return nodes.filter((node) => { return node.chapter_id === chapter });
};

const mapStateToProps = (state) => ({
  nodes: filtered_nodes(state.nodes,state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

The way I have designed this component is causing our application to run through extra render cycles for everything that happens downstream of this container.  Most notably, every time there is a state change (even in an unrelated section of our state tree), we are re-rendering our list of nodes.

Why is this happening?

Our connect function's use of the `Array.filter` method is the source of the problem.  Filter produces a new array instance containing only elements of the original array that meet our test criteria.  React doesn't make a deep comparison of our array's content to determine if it needs to render a component anew.  Instead, it relies on us to keep an immutable state on its behalf so that its tests for rendering end with a simple referential check.  If a component receives a new array instance, it renders anew, even if the new array has the same shape as the last render cycle

My filter method produces a new array each time its run.  What is especially problematic is that our `connect` function subscribes to all updates to our state tree; not just the nodes branch we're interested in for this container.  Have a look at our reducer for a quick refresher.

``` javascript(/reactive-client/src/reducers/nodes.js)
import * as constants from '../constants/nodes';

let default_state = [];

- export const sortNodes = (nodes) => {
-   return nodes.sort((a,b) =>{
-     if(a.chapter_id === b.chapter_id){
-       return a.id - b.id;
-     } else
-     {
-       return a.chapter_id - b.chapter_id;
-     }
-   });
- };

+ const nodesReducer = function(state = default_state,action){
+   switch (action.type) {
+     case(constants.LOAD_NODES):
+       return [...sortNodes(action.payload)];
+     default:
+       return state;
+   }
+ };

export default nodesReducer;
```

We've done our job correctly here; our `nodesReducer` is only managing one action to load our list of nodes into our state tree on our `LOAD_NODES` action.  On a load, we use the spread operator to assign all members of the array to a new array literal; allowing React to spot the change in our state quickly.  Remember though that **all** actions get passed through **all** of our reducers.  

That means that any other action dispatched evaluates in `nodesReducer`.  Since our action types won't match the switch conditions, other actions fall through to our default case and return our unaltered state.  React sees that our reference for our nodes array is unchanged, and skips any render cycles dependent on that part of our state.  That's how it should work.

It all goes wrong when `connect`, subscribed to our store changes, receives that unaltered reference to our existing state.  It picks up the unchanged state, and happily churns through its filter operation, producing a **new** list of nodes, and supplying that to React.

Rendering this list of nodes is perhaps the most expensive operation of our client-side app.  Printing an extensive list of React elements, and then running additional work after the components mount to add syntax highlighting using `highlightJS`.  It's not something we want to repeat if we don't need to.  Let's look at how we can fix this.

``` javascript(/reactive-client/src/containers/filtered_nodes_list.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ export class FilteredNodeList extends Component {
+   render(){
+     const { nodes, active_chapter_id } = this.props;
+     const node_list = nodes.filter(n => n.chapter_id === active_chapter_id);
+     return node_list && node_list.length ? <NodesList nodes={node_list} /> : null;
+   }
+ }

const mapStateToProps = (state) => ({
  nodes: state.nodes,
  active_chapter_id: state.settings.active_chapter_id
});

export default connect(
  mapStateToProps,
  null
)(FilteredNodeList);
```

Here we've dumbed down our `mapStateToProps` function to keep a simple subscription to the elements of our state we need.  To offset this, we've reworked `FilteredNodeList` to do the heavy lifting; using it to produce our filtered list of nodes, and moving forward with rendering our child components only if we have a list of elements ready to print. 

This approach helps us solve our extra render cycles as well because React's render function only runs inside our high order component with updated props given to the component.  In this case, that means we have received a fresh array of nodes, or the `active_chapter_id` has changed, requiring us to reevaluate our filtered list.

One more thing before we move on.  Let's make this component a little easier to get inside for testing.

``` javascript(/reactive-client/src/containers/filtered_nodes_list.js)
import React, { Component } from 'react';
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ export const nodesProvider = (WrappedComponent = NodesList) => 
+   class extends Component {
+     static displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
+     
+     render(){
+       const { nodes, active_chapter_id } = this.props;
+       const node_list = nodes.filter(n => n.chapter_id === active_chapter_id);
+       return node_list && node_list.length ? <WrappedComponent nodes={node_list} /> : null;
+     }
+   };

- const mapStateToProps = (state) => ({
-   nodes: state.nodes,
-   active_chapter_id: state.settings.active_chapter_id
- });

export const connectToNodes = (WrappedComponent) =>
  connect(mapStateToProps, null)(nodesProvider(WrappedComponent));
  
export default connectToNodes();
```

Instead of configuring our HOC as a static class `FilteredNodeList`, we have refactored to have a new function `nodesProvider` produce a component class dynamically, which will, in turn, render a wrapped component with our prepared props.  This refactor brings two advantages; we're now able to reuse this functionality to connect any component we might need to with our filtered list of nodes.  Reusability aside, we also gain a way to test this container without needing to go to the trouble of mocking our redux store.

``` javascript(/reactive-client/src/containers/filtered_nodes_list.spec.js)
/* global expect */
import React, { Component } from 'react';
import { shallow } from 'enzyme';

import config from '../test_helper';
import { nodesProvider } from './filtered_nodes_list';

let defaultProps = {
  active_chapter_id: 1,
  nodes: [
    {id: 1, chapter_id: 1, node_type: "header", content: "Node 1"},
    {id: 2, chapter_id: 1, node_type: "paragraph", content: "Node 2"},  
    {id: 3, chapter_id: 2, node_type: "header", content: "Node 3"},  
  ]
};

class MockComponent extends Component {}
const MockContainer = nodesProvider(MockComponent);

describe("nodesProvider", ()=>{
+   it("renders wrapper only with nodes matching active_chapter_id", ()=>{
+     let w = shallow(<MockContainer {...defaultProps}/>);
+     expect(w.find("MockComponent").props().nodes.length).toBe(2);
+   });
  
  it("render nothing if no nodes match filter", () => {
    let w = shallow(<MockContainer nodes={[]} active_chapter_id={1} />);
    expect(w).toMatchSnapshot();
  });
});
```

By moving our logic operations for selecting nodes out of our `mapStateToProps` function and into a High Order Component, we can now test our filtering results without needing to go the trouble of mocking a Redux store.  We can simply render the HOC and manually pass props we want to test.  Since our `connect` usage is now limited to simple mapping of or store state into component props, I'm comfortable leaving that code untested, and relying on react-redux's tests for this simple behavior.

Before moving on, we need to make a similar refactor to our `chapterProvider` function.

``` javascript(/reactive-client/src/containers/chapter_provider.js)
import { connect } from 'react-redux';
import React, { Component } from 'react';

import ChapterFooter from '../components/chapter_footer';
import NavigationMenus from '../components/navigation_menus';
import { routeChapter } from '../actions/routes';

export const connectToChapters = (WrappedComponent) => 
  connect(mapStateToProps,mapDispatchToProps)(chapterProvider(WrappedComponent));


export const chapterProvider = (WrappedComponent) => class ChapterFilter extends Component {
  static displayName = WrappedComponent.displayName || WrappedComponent.name || 'Component';
  
  render(){
    const { active_chapter_id, chapters, ...otherProps } = this.props;
    const active_chapter = chapters.find(c => c.id === active_chapter_id);
    const next_chapter = chapters.find(c => c.id === active_chapter_id + 1);
    
    const cleaned_chapters = chapters.map( c =>{
      c.title = c.title.replace(/^chapter\s?/i,"");
      return c;
    });
    
    return  chapters && chapters.length ? 
      <WrappedComponent active_chapter={active_chapter || {id: -1, title: ""}}
        next_chapter={next_chapter} chapters={cleaned_chapters} {...otherProps} /> : null;
  }
};

const mapStateToProps = (state) => ({
  chapters: state.chapters,
  active_chapter_id: state.settings.active_chapter_id
});

const mapDispatchToProps = (dispatch) => ({
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedChapterFooterLink = connectToChapters(ChapterFooter);
export const ConnectedNavigationMenus = connectToChapters(NavigationMenus);
```

We'll also add some test coverage for this container.

``` javascript(/reactive-client/src/containers/chapter_provider.spec.js)
/* global expect */
import React, { Component } from 'react';
import { shallow } from 'enzyme';

import config from '../test_helper';
import { chapterProvider } from './chapter_provider';

let defaultProps = {
  active_chapter_id: 1,
  chapters: [
    {id: 1, title: "Chapter 1: Stuff"},
    {id: 2, title: "Chapter 2: Things"},  
    {id: 3, title: "Chapter 3: Stuff & Things"}
  ]
};

class MockComponent extends Component {}
const MockContainer = chapterProvider(MockComponent);

describe("chapterProvider", ()=>{
  it("selects active and next chapter", ()=>{
    let w = shallow(<MockContainer {...defaultProps}/>);
    expect(w.find("MockComponent").props().active_chapter.id).toBe(1);
    expect(w.find("MockComponent").props().next_chapter.id).toBe(2);
  });
  
  it("passes cleaned titles to WrappedComponent", ()=>{
    let w = shallow(<MockContainer {...defaultProps}/>);
    expect(w.find("MockComponent").props().chapters[0].title).toBe("1: Stuff");
  });
  
  it("render nothing if no nodes match filter", () => {
    let w = shallow(<MockContainer chapters={[]} active_chapter_id={1} />);
    expect(w).toMatchSnapshot();
  });
});
```

## Wrapping Up

We have looked at all the tools and strategies needed to roll out component testing throughout our application for both our containers and dumb components.  If you would like additional practice, work with some of the other component's we didn't cover explicitly and make sure you are comfortable with different scenarios.

If you get stuck on something, consult the starter commit at the beginning of our next chapter to compare your work to my own.

Otherwise, move on to the next chapter, where we cover deploying our application to production for the first time.