# Chapter 8: Managing API Connections with Sagas

It is time we got serious about how we manage our requests to our API.  So far, we have stuck them in somewhat haphazardly as we have run into requirements for data in our application.  We saw first-hand in Chapter 6 how that can become problematic when demand for data ran its course before our API request had a chance to complete.

In general, React discourages managing API requests as part of your render cycle.  It almost always leads to React running extra render cycles that would not otherwise be required.

Instead, we want to transition our API request to happen as a side effect of actions dispatched to our Redux store.  To do this, we will be introducing Redux Saga into our application.

## Jumping in Here

If you have not been following along with code examples and wish to jump in here, you can use our [Chapter7Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter7Starter) branch as a place to join in.

## What About Thunk?

If you have used React/Redux for any amount of time, you have probably heard of a very popular Middleware redux-thunk (or simply Thunk).

Thunk is a middleware for Redux that adds an ability for you to dispatch actions which return functions, instead of the traditional plain JavaScript objects.  Take a look at this simplified example Thunk.

``` javascript
  const loadChapterUnlessComplete = () => {
    return (dispatch,getState) => {
      if(getState().chapters === []){
        // Manage API call
        dispatch(actions.loadChapters(payload));
      }
    }
  }
```

Instead of your action creators being simple object factories,  they return functions which can optionally receive the `dispatch` and `getState` functions from our store.  This design allows our return functions to evaluate the current state of the store, and dispatch additional actions as needed.  In the simplified example above, we see a check of the state of our `chapters` state tree in the store.  If we find the store has already loaded chapters, we short-circuit the API call. Otherwise, we fire the API and dispatch another action once we have the data.

Thunk is a very popular, and very powerful middleware.  So why am I not using it?  I have a personal preference for a different tool.

There are a few things I do not like about Thunk, but most of them are trivial.  The change away from dispatching only simple objects, to me, obscures the beautiful simplicity of Redux itself.  I like being able to know that when I am looking at a store dispatch, I am looking at a simple JavaScript object. 

And an extension to this is testing.  I find testing Thunk to be more of a headache to test than Redux Saga.  With Thunk I find myself spending more time trying to figure out how to mock my tests than I do writing code. 

That said, Thunk is a very common middleware, so being at least passingly familiar with it would do you right if you want to explore it outside of this project.  It is also worth noting that our router, Redux-First-Router supports thunks.  So much so in fact, that without even installing the Thunk middleware, you can setup your route map to dispatch a Thunk in response to a routing action.  So Thunk is a very easy tool to integrate with the stack we are already using if you wish to leverage it in one of your projects.

## Redux Saga

We are using Redux Saga instead of Thunk to manage our API connections, as well as any number of other complicated state transformations.  

If you have not been introduced to Sagas before, you might want to do a little studying about what a Saga is, before we even dive into learning about Redux-Saga.  There's a video suggested on Redux-Saga's documentation site about sagas as a design pattern, which gives [an excellent introduction to using Sagas](https://www.youtube.com/watch?v=xDuwrtwYHu8) to simplify asynchronous programming.  Watch it as some optional homework if you would like some background.

### ES2015 Generator Functions

Before we can dive into Sagas, we need to spend a little time talking about generator functions, a new piece of ES2015 syntax.

At their simplest, I would describe generator functions as special functions that can stop and resume their execution; surrendering control to other areas of our applications, and regaining control when the generator has the information needed to advance.  Generator functions are declared using the special `function*` keyword, and just like functions, can accept a list of parameters.  However, we typically think of functions running from beginning to end without interruption.  A function gets invoked, and it either runs until it returns a value (which maybe be undefined), or something causes us to break, and terminate execution.

A generator, however, has access to a special keyword `yield`, which passes control of execution off to another thread of our application.  On the next generator invocation, execution resumes where it left off and carries on until the next yield of the generator, or completion of the function.  The context of generator functions (their scope inside the function's body) persists over their entire lifecycle.

When first invoking a generator, it does not begin execution.  Instead, it returns what is known as an iterator, which provides us with a `.next()` method.  The iterator is used to manage the execution of our generator as control is resumed and surrendered over the generator’s lifecycle.  Let's look at some examples.

``` javascript
function* countForever(){
  let count = 1;
  while(true){
    console.log(count);
    count += 1;
    yield
  }
}

let counter = countForever();
// No console log here, instead we receive our iterator function.

counter.next()
//Console: 1
counter.next()
//Console: 2
counter.next()
//Console: 3
```

Several things of note here.  First, appreciate our infinite while loop. 
 Usually, we would avoid creating an infinite loop in our functions as they would permanently trap execution.  However, this highlights an important feature of generators; since each yield statement suspends execution until the next time `iterator.next()` is called, we do not lock our application.  Instead, this infinite loop ensures our generator never reaches its finished state, and happily keeps counting for as long as we need.

We have not mentioned that each time your generator reaches a yield, it can also return a value.  In our previous example these would have looked like the following: `{value: undefined, done: false}`.  

A yield can be used to pass back a value from inside the generator.  The `done` attribute exists to alert us when the generator has reached the end of its execution lifecycle (no remaining yields).

In this case, our generator’s infinite loop ensures we never reach the done state of this generator.  Moreover, since the state of the generator persists until its completion, it stays there, waiting to yield us the next number in the sequence each time we invoke `next()` on the iterator.

We can also use the iterators `next` method to pass values back into the generator.  Let's take a look.

``` javascript
function* countWithMeForever(){
  let count = 1;
  console.log("Let's count together!")
  
  while(true){
    let next = yield
    if(next === count){
      console.log(count + "!");
    } else {
      console.log("I think you meant " + count = "...");
    }
    count += 1;
  }
}

let counter = countForever();
// No console log here, instead we receive our iterator function.

counter.next()
//Console: Let's count together!
counter.next(1)
//Console: 1!
counter.next(2)
//Console: 2!
counter.next(2)
//Console: I think you meant 3...
```

Now, our counter cheerily counts along with you on each invocation of our iterator’s `next` method.  The value passed through next can be assigned through our yield statements inside our generator.  This passed value allows our counter to parrot back numbers as we pipe them in, or to admonish us if we happen to lose count along the way.

The code we have worked with here has been synchronous, and that makes our examples a bit contrived.  The power of generators shines when we begin working with asynchronous actions.  Our generators can dispatch work to an asynchronous function and then yield control of execution to other threads while waiting for a response.  Then pick right back up where they left off once data is available to continue.

Redux Saga makes heavy use of generators to do just that.  Even better, the Redux Saga middleware by-in-large manages our iterators for us with middleware and gives us a library of helper methods called effects to help orchestrate asynchronous operations.

### Installing Redux Saga

Before we go any further into the details, let's get the installation of Redux saga behind us.  Start with the package install `npm install --save redux-saga`.

Then we need to make modifications to our store to include Redux Saga's middleware.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import createSagaMiddleware from 'redux-saga'
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
- const routeMap = {
-   // Routes here "ACTION_NAME":"/some/route"
-   [ROUTES.HOME_ROUTE]: "/",
-   [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
- };

- const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer } = connectRoutes(
-   history,
-   routeMap,
-   { restoreScroll: restoreScroll() }
- );

const reducers = combineReducers({location: routeReducer, settings, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();
const middlewares = applyMiddleware(routerMiddleware, sagaMiddleware);

const store = createStore(
  reducers, composeWithDevTools(routerEnhancer, middlewares)
);

export default store;
```

We now include the `createSagaMiddleware` factory to generate the Redux Saga middleware .  Then that returned middleware is being included in our `applyMiddleware()` chain to tie it to our store.

Just like that, we are now ready to write our first saga.

## Saga Watchers and Workers

Redux Saga is designed to watch your dispatched store actions and intercede to manage more complicated operations when it sees certain watched action types dispatched to the store.  Because of this pattern, you often hear Sagas described in terms of watchers and workers.

Let's start by writing our first watcher saga.  As suggested by the name, a watcher watches our store, waiting for actions with a specific `type` attribute to be dispatched.  When the dispatch is observed, the watcher then invokes a worker, which handles the needed operations.  My goal for this first iteration with Sagas is to finally remove our API calls from the lifecycle methods of our components and to set up a new mechanism to instantiate our store with chapter and node information.

We have the perfect infrastructure to do this already in place, given to us by our routing.  It seems that we should tie the requests for chapters/nodes to our routes that require this information.  That way, in the future, if we add additional static pages that don't require the book contents, we can delay loading until we are sure we need the content.  This arrangement might save our API from processing unneeded requests.  Luckily, since our routing already dispatches actions to represent route changes, this is all just begging to be unified.

## Our First Saga

We are going to be using Sagas as another significant layer of our client infrastructure, so I prefer to store them in a dedicated application folder.  Create a new file/folder at `src/sagas/routes.js`.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
import { takeEvery } from 'redux-saga/effects';

import routes from '../constants/routes';

export function* watchBookRoutesSaga(){
  yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
};
```

To start, we have set up a watcher for our application’s home and chapter routes.  We are using the same constants file we have used in other areas of the application to plug into the `type` values that dispatch when these routes fire.

The watcher itself is a generator function, and we are using an effect provided by Redux Saga to manage our watch of the chapter and home route paths.  

When we ran through our crash course on generators, we were directly managing the iterator and its invocations of the `next()` method.  Our work with Redux saga is considerably easier because the Redux Saga middleware manages the iterators of our generator functions.  The generators we define use helpers provided by Redux Saga to yield everyday JavaScript objects.  These objects will give different instructions to the middleware on how to manage our iterators, and by extension manage our asynchronous actions.

In this case, `takeEvery` fires our paired generator (in this case `instantiateBook`) every time the `HOME_ROUTE` or `CHAPTER_ROUTE` action dispatch.  

As an alternative example, we could use the `takeLatest` effect, which would also begin the `instantiateBook` saga each time a matching route was dispatched.   However, `takeLatest` has the additional effect of canceling any previous instances of `instantiateBook` that might have been underway already when the latest matching dispatch was observed.

I also want to be clear that we could tie a watcher saga to **any** action type that might dispatch to our store.  That includes actions that might not do anything at all, except trigger a saga.

Redux Saga simplifies the more complex operations of managing our generators, giving us a set of side effects that let us plan our sagas according to how we want our asynchronous actions managed.  
Our generators yield simple objects to dictate instructions about how operations should run.  A simplicity which we'll really come to appreciate when we start to test our sagas.

Let's look at a worker now.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
import { takeEvery, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';

export function* instantiateBook(){
  try{
    const response = yield call(axios.get,'/api/nodes');
    yield put(loadNodes(response.data));
    
  }
  catch(e){
    console.log(e);
  }
} 

- export function* watchBookRoutesSaga(){
-   yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
- };
```

We are introducing several more side effects now from Redux Saga.  Our generator wraps its work in a try/catch block.  This step allows us an easy way to split off our error management in the future when we are ready to add more complex error handling.  For now, focus on the try branch.

Out first yield is using a side effect `call`, which causes the invocation of the function passed to the effect.  When that function resolves, the resulting value of the call passes to our yield statement.  Call accepts the function we wish to invoke as its first parameter, and then a list of parameters we wish to pass to that function.  So the result of this `call` side effect is the invocation of `axios.get("/api/nodes")`, and the resulting response is assigned to our const `response`.

From there, we come to another yield, which is using the `put` side effect.  The `put` side effect is used to dispatch actions to our store.  So in this case, once we have the response back from our API, we dispatch the resulting data using our loadNodes action creator.

Before we finish wiring this in, let's do one more housekeeping step.  Create a new file, `src/sagas/root.js`, and fill in the following code.

``` javascript(/reactive-client/src/sagas/root.js)
import { all } from 'redux-saga/effects';
import { watchBookRoutesSaga } from './routes';

export default function* rootSaga(){
  yield all([
    watchBookRoutesSaga()
  ]);
}
```

As we create more sagas, each needs to be passed to our saga middleware to connect them to our store.  Our root saga serves as the entry point for all of our watchers, running in parallel using the `all` effect.  It is worth noting that our sagas, can themselves invoke other sagas like this to manage several complex interactions at once.  This rootSaga is simply giving us a single point of entry which allows us to bind all other sagas to the store.  However, you might write a saga, which itself uses several smaller sagas to manage units of work.

Finally, we need to make a few more modifications to the store in `src/reducers/store.js`.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import createSagaMiddleware from 'redux-saga'
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';
+ import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

+ const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = connectRoutes(
+   history,
+   routeMap,
+   { restoreScroll: restoreScroll(), initialDispatch: false }
+ );

const reducers = combineReducers({location: routeReducer, settings, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

const store = createStore(
  reducers, composeWithDevTools(routerEnhancer, middlewares)
);

+ sagaMiddleware.run(rootSaga);
+ initialDispatch();

export default store;
```

First, we need to modify our router setup where we invoke `connectRoutes`.  We are now assigning a new return value `initialDispatch`, and also passing a new option `initialDispatch: false` in our options block.

Normally, Redux First Router fires the initial route's dispatch immediately upon connection to our store.  This default causes us a timing problem though with redux-saga.  Note the new line `sagaMiddleware.run(rootSaga);` which starts our sagas.  Our saga middleware's `run` method cannot fire until after store creation.  So if we allow redux-first-router` to manage its initial dispatch, our sagas are not set up to listen for the dispatched route action in time.  

To solve this, we are now manually firing the `initialDispatch` method after running our sagas.

Now, let's update our `App.js` component so it can cease managing our API call for nodes.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import './App.css'

import ReaderPane from './components/reader_pane';
import MenuBar from './components/menu_bar';
import FilteredNodesList from './containers/filtered_nodes_list';

class App extends Component {
  render() {
    return (
      <div id="app">
        <MenuBar />
        <ReaderPane>
          <FilteredNodesList />
        </ReaderPane>
      </div>
    );
  }
}

export default App;
```

Doesn't that look much nicer?  We can say goodbye to our `componentWillMount` API call.  Since we no longer need the component to dispatch our `loadNodes` action, we can also cut `mapDispatchToProps`, and disconnect the component itself from the Redux store.  Plus we get to strip out all the modules we no longer need.  All those changes leave us with a nice simple UI rendering component.

Reload the application and make sure everything is running smoothly under you new saga based setup.

## Spying on our Sagas

Before we move on, let's look at the yield values of our saga thus far.  I am going to assign our worker saga `instantiateBook` to our browser's window object so that I can do some quick examples in the console.  Let's look at just the worker and see what happens as we manually manage its iterator function.

![Instantiate Book Iterator](/images/8/SagaGeneratorExample.png)

First, just as we did in our generator examples at the start of this chapter, I am calling the generator and assigning the returned iterator to a variable, `saga`.

When I invoke `saga.next` the first time, the code runs up to our first yield statement, and in this case, our first side effect.  Our side effects always return simple objects, which are in turn managed by our middleware.  I am using `JSON.stringify` to make the example more readable.  The returned object details the side effect redux saga should use (`call`), and the information needed to manage the call.

the next time we invoke `saga.next` we are assigning the returned value of our yield to the `response` variable.  This assignment means our generator expects `next` to include a value on its next invocation.  In this case, that value should be a response object, with an attribute `data`. That response will contain a list of nodes returned from our API.  

This time, when we invoke `next` with the return data, our generator resumes running after the first yield and runs to the next, which contains our use of the `put` effect.  

Our generator again returns a JavaScript object for our middleware with instructions on how to perform the `put` effect.  In this case, dispatching our action `loadNodes` to the store.

We are taking this pause to help you understand how the saga middleware is managing our generators to orchestrate asynchronous actions like our API call.  You should also see that we can control the next step the generator takes by altering the value given to `next` each time the iterator is advanced.  This demonstration is the same strategy we use to implement tests against our generators.

## Managing the Chapter Load

Let's add in the request for our chapters so that we can remove that API code from our components as well.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
import { takeEvery, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
+ import { loadChapters } from '../actions/chapters';

export function* instantiateBook(){
  try{
    const response = yield call(axios.get,'/api/nodes');
+     const chapterResponse = yield call(axios.get,'/api/chapters');
    yield put(loadNodes(response.data));
+     yield put(loadChapters(chapterResponse.data));
  }
-   catch(e){
-     console.log(e);
-   }
} 

- export function* watchBookRoutesSaga(){
-   yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
- };
```

Now, we can update the `controlled_chapter_menu_items.js` container since we will no longer need it to provide our loadChapters action creator.

``` javascript(/reactive-client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  active_chapter: state.chapters.find(
   (chapter) => chapter.id === state.settings.active_chapter_id
  ),
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

The `chapter_menu_items.js` component can be updated as well to remove our API related code.

``` javascript(/reactive-client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';

export default class ChapterMenuItems extends Component {
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
          active: chapter.id === this.props.active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
    if(this.props.chapters !== [] && this.props.active_chapter){
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
          value={this.props.active_chapter.id}
          text={this.props.active_chapter.title}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
    } else {
      return null;
    }
  }
}
```

Allow the application to reload, and your sagas should now be adequately managing the instantiation of our book contents.  We can still make some improvements though.

If you look at the network tab of your browser, you can see evidence of the weakness of our current instantiateBook saga.  Because yield surrenders control of execution until the API call resolves, our two task run in sequence; first the API call for nodes fires, and our generator waits for a response.  Then the API is queried again for our chapters and again waits for a response.

If you look at the timing of the network requests, you can see this play out.  In one test I ran, my `/api/nodes` request was able to start at ~900ms, while the request for chapters delayed until 1.6 seconds had passed.

![Nodes Sequenced Request](/images/8/NodesSequenceRequest.png)
![Chapters Sequenced Request](/images/8/ChaptersSequenceRequest.png)

### Running Requests in Parallel

If we rework our Saga a bit, we can run these requests in parallel using a side effect we mentioned before in our rootSaga but did not examine.

The `all` effect allows us to run an array of tasks in parallel, and our saga does not advance until all of the requests resolve.  Or if one of the request fails, the entire saga will end in an error.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
+ import { takeEvery, put, call, all } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';

export function* instantiateBook(){
  try{
+     const [nodes, chapters] = yield all([
+       call(axios.get,'/api/nodes'),
+       call(axios.get,'/api/chapters')
+     ]);
    
+     yield all([
+       put(loadNodes(nodes.data)),
+       put(loadChapters(chapters.data))
+     ]);
  }
  catch(e){
    console.log(e);
  }
} 

- export function* watchBookRoutesSaga(){
-   yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
- };
```

Now when I check my network requests, I see both requests going out at the same time (and the whole process of our saga wrapping up more quickly I might add).

There's something else though we have to fix though.  Flip between a few different chapters.  What’s happening?  We tied this saga to the `CHAPTER_ROUTE` dispatch so that if someone came into our application on a link to a specific chapter, we'd still instantiate the book.  However, once we have done that, it would be nice if we did not continue to harass the API for that same information over and over again.

Don't worry; there is an effect for that.

### Checking Store Values in a Saga

Let's add a check to the beginning of our saga to verify we need to fire our API requests.

``` javascript(/reactive-client/src/sagas/instantiate_book.js)
+ import { takeEvery, select, put, call, all } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';

export function* instantiateBook(){
+   const dehydrated = yield select((state) =>{
+     return !(state.chapters.length && state.nodes.length)
+   });
  
+   if(dehydrated){
-     try{
-       const [nodes, chapters] = yield all([
-         call(axios.get,'/api/nodes'),
-         call(axios.get,'/api/chapters')
-       ]);
-       
-       yield all([
-         put(loadNodes(nodes.data)),
-         put(loadChapters(chapters.data))
-       ]);
-     }
-     catch(e){
-       console.log(e);
-     }
+   }
} 

- export function* watchBookRoutesSaga(){
-   yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
- };
```

The `select` effect invokes a selector function you define for it, which receives access to our current store state.  In our example, we are using select to check if either `nodes` or `chapters` has a length of 0 (falsey), and if so flagging our book as "dehydrated".  If the saga advances in this dehydrated state, then it executes our API queries. 

One last thing though, let's set up our selector function as a standalone exportable, that way it is easier to grab for testing.

``` javascipt
import { takeEvery, select, put, call, all } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';

+ export const checkBookHydration = (state) => {
+   return !(state.chapters.length && state.nodes.length)
+ }

export function* instantiateBook(){
+   const dehydrated = yield select(checkBookHydration);
  
-   if(dehydrated){
-     try{
-       const [nodes, chapters] = yield all([
-         call(axios.get,'/api/nodes'),
-         call(axios.get,'/api/chapters')
-       ]);
-       
-       yield all([
-         put(loadNodes(nodes.data)),
-         put(loadChapters(chapters.data))
-       ]);
-     }
-     catch(e){
-       console.log(e);
-     }
-   }
} 

- export function* watchBookRoutesSaga(){
-   yield takeEvery([routes.HOME_ROUTE, routes.CHAPTER_ROUTE], instantiateBook);
- };
}
```

## Sagas Shine in Testing

We have our API interactions successfully migrated into our Saga.  Now we should probably put this under test before we move on.

Before we touch our saga, let's write some tests for our selector function.  When we test our saga actions, we feed `next()` with the expected return values of each yield.  This direct management of our iterator's progression means the actual logic of our selector function is not be under test unless we explicitly test that code in isolation.  Since it took me about 4 tries to get the logic test right when I wrote it; I should probably test it.

``` javascript(/reactive-client/src/sagas/instantiate_book.spec.js)
import { checkBookHydration } from './instantiate_book';

describe("checkBookHydration", ()=>{
  const cases = [
    {state: {nodes: [], chapters: [] }, outcome: true},
    {state: {nodes: ["populated"], chapters: [] }, outcome: true},
    {state: {nodes: [], chapters: ["populated"] }, outcome: true},
    {state: {nodes: ["populated"], chapters: ["populated"] }, outcome: false}
  ];
  
  cases.forEach((test_case) =>{
    test("provides expected outcome", () =>{
      expect(checkBookHydration(test_case.state)).toEqual(test_case.outcome);
    });
  });
});
```

We are using a trick we have not seen so far for Jest.  I am creating an Array of sample data and using the `Array.forEach` method to apply an assertion to each member.  We are supplying sample data, and our expected outcome to each test run.  In this case, we expect our selector to return true in any state where it encounters at least one empty Array.

Now, let's move on to our Saga itself.

``` javascript(/reactive-client/src/sagas/instantiate_book.spec.js)
/* global expect */
import { instantiateBook, checkBookHydration } from './instantiate_book';
import { select } from 'redux-saga/effects';

- describe("checkBookHydration", ()=>{
-   const cases = [
-     {state: {nodes: [], chapters: [] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: [] }, outcome: true},
-     {state: {nodes: [], chapters: ["populated"] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: ["populated"] }, outcome: false}
-   ];
-   
-   cases.forEach((test_case) =>{
-     test("provides expected outcome", () =>{
-       expect(checkBookHydration(test_case.state)).toEqual(test_case.outcome);
-     });
-   });
- });

describe("instantiateBook", () =>{
  var saga = instantiateBook();
  
  test("begins by checking hydration of book nodes/chapters",() =>{
+     expect(saga.next().value).toMatchObject(select(checkBookHydration))
  })
  
  test("ends saga if book is not dehydrated",() => {
+     expect(saga.next(false).done).toEqual(true);
  })
});
```

We are going to be pacing through our generator using the `next` method of our returned iterator.  Notice that when I set up my test in the `describe` block, I am purposefully **not** using a `beforeEach` block.  We do not want the test to tear down and reset our generator back to the beginning each time we test an assertion.  Instead, our tests flow in one continuous stream for the saga.

To begin, we are testing the first return of `saga.next()`, and its value should be our call to the `select` effect.  Remember that the saga middleware is going to handle the actual execution of this effect, we just need to verify our saga is dictating the correct effects at each step of the journey.  Therefore, we test the value of `saga.next().value`, against the expectation that it should contain an object representing the `select` effect, and use our `checkBookHydration` selector method as its selector function.

The next test moves the saga forward again.  This time we are supplying a value into `next()`, this is essentially a mock for your saga.  We do not need the service to be mocked or to execute our `select` effect.  We just need to know that if the saga gets a certain value passed back to `yield` that it performs the next step we expect.  If this case, if the test for dehydration proves false, we expect the saga to be done.  So we can test that the object returned is marked `done: true`.

Now we have a problem though.  We just resolved our generator, but we did not test the dehydrated branch.  We could start the next test by setting up a new iterator, and invoking `saga.next()` and then `saga.next(true)`.  However, it would be a real headache, and not a very clear test.

Luckily, redux-saga ships with a helpful method we can use to make this easier, `cloneableGenerator`.  Let's look at that helper in action.

``` javascipt(/reactive-client/src/sagas/instantiate_book.spec.js)
/* global expect */
import { instantiateBook, checkBookHydration } from './instantiate_book';
import { cloneableGenerator } from 'redux-saga/utils';
import { select, all, call, put } from 'redux-saga/effects';
import axios from 'axios';

import { loadNodes } from '../actions/nodes';
import { loadChapters } from '../actions/chapters';

- describe("checkBookHydration", ()=>{
-   const cases = [
-     {state: {nodes: [], chapters: [] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: [] }, outcome: true},
-     {state: {nodes: [], chapters: ["populated"] }, outcome: true},
-     {state: {nodes: ["populated"], chapters: ["populated"] }, outcome: false}
-   ];
-   
-   cases.forEach((test_case) =>{
-     test("provides expected outcome", () =>{
-       expect(checkBookHydration(test_case.state)).toEqual(test_case.outcome);
-     });
-   });
- });

describe("instantiateBook", () => {
  var saga = {}
+   saga.gen = cloneableGenerator(instantiateBook)();
  
  test("begins by checking hydration of book nodes/chapters",() => {
    expect(saga.gen.next().value).toMatchObject(select(checkBookHydration))
+     saga.dehydrated = saga.gen.clone();
+     saga.hydrated = saga.gen.clone();
  })
  
  describe("BRANCH dehydration === false ", ()=> {
    test("ends saga",() => {
      expect(saga.hydrated.next(false).done).toEqual(true);
    });
  });
  
  describe("BRANCH dehydration === true", ()=> {
    test("begins /api/nodes && api/chapters requests", ()=> {
      expect(saga.dehydrated.next(true).value).toEqual(all([
        call(axios.get,'/api/nodes'),
        call(axios.get,'/api/chapters')
      ]));
    });
    
    test("dispatches loadNodes and loadChapters with returned data", ()=> {
      let [nodes, chapters] = [
        {data: [{content: "Test node"}]},
        {data: [{title: "Test Chapter"}]}
      ];
      
      expect(saga.dehydrated.next([nodes, chapters]).value).toEqual(all([
        put(loadNodes(nodes.data)),
        put(loadChapters(chapters.data))
      ]));
    });
  });
});
```

When we set up our generator, we are instantiating it with the method `cloneableGenerator` which allows us to clone a snapshot of our generator’s current state at any time.  Our first test proceeds as normal, but before we close the test, we are setting up for the hydrated/dehydrated logic split in our saga.  I prefer to keep all my saga branches in an object so that I can use the dot-naming syntax to give a descriptor of where each saga is in its lifecycle.  Therefore the branches I create are called `hydrated` and `dehydrated`.

We then open a new describe block for each branch and carry our testing forward.  The false branch only has one additional test ensuring our generator shows finished after we prove our book state to be hydrated.

The `dehydrated` branch begins by testing that our API calls fire if `dehydrated == true`.  As we did with our first `select` test, we are invoking the same effects we expect the generator to use in our tests, and comparing the objects returned.  In this case, using `all` and several `call` generators.

The `dehydrated` branch then advances again, this time ensuring that our `loadChapters` and `loadNodes` actions are both dispatched to our store when yielded data from our API calls.

That gives us a pretty robust test for our saga.  The only thing missing is a test of our errors branch.  Since we are console logging this error, we are getting some pollution in our test reports when our App component gets mounted and attempts to make these API calls and fails.  We can clean this up later as we consider how to handle displaying these messages in our application.

## Wrapping Up

This chapter was mainly a refactor of our application.  We did not come away with any new features to show for our efforts, but a fundamental piece of our application architecture functions in a much more scalable, and testable manner.  Between Redux, Redux-First-Router, and Redux Saga we have our entire application built to make our store the single system of record for our application.  Now the fun begins, to this point, the amount of state we managed has been minimal, and it is arguable we probably could have built this application easily in vanilla Rails.  

Now with that the groundwork set, we can start thinking about more complicated state change on the client-side, and build some features that will really make our application shine.  See you in chapter 8!
