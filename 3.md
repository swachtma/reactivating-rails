
# Chapter 3: Loading and Displaying Basic Content

We will be working in both our API and client project directories for this chapter as we attempt to bootstrap a minimum viable first iteration of our reader.  I will give a warning going in that we are going to do some things wrong this chapter for the sake of doing them quickly and allowing us to focus on new areas of our stack as we add them in one at a time.  Try not to sweat the details of anything being perfect at this point; we are putting up a scaffold of better things to come. 

## Start with the Hotdogs

Jason Fried's [Rework](https://www.amazon.com/Rework-Jason-Fried/dp/0307463745/ref=tmm_hrd_swatch_0?_encoding=UTF8&qid=1502762510&sr=8-1), might be the best programming book I have ever read.  Maybe that is an odd claim, considering that the book has not one single line of code among its pages.  However, Rework reads like a manifesto for builders; whether that is builders of businesses or software.  Given Basecamp's connections to the very root of the Rails community, I think it makes an excellent place for us to turn for guidance as we embark on the first iteration of our project.

One of Rework's teachings is that we should strive to focus on the most crucial part of a thing first.  We should endeavor not to be distracted by the accouterments until we have the basics handled.  The analogy Jason uses is that of a hot dog cart.  Put plainly; he says if you are going to open a hot dog cart, the first thing you should focus your attention on, is the hotdogs.  Avoid focusing on the buns, the condiments, the cart, the marketing, or staffing. You need hotdogs.

I find this be a particularly apt analogy, because if there is one thing you probably **don't** want to focus on the inner workings of in much detail... it is a hotdog.  Given a choice between hot dogs, and anything else on the cart, I would rather avoid knowing too much about the hotdogs.

Why focus on tube meats when we could dive into the gleaming design of our cart?  The materials, the colors, the inspired logo, or a witty name.  I could spend a month or two here alone.

We could focus our first foray into our application, on all the trimmings we could add.  We are obviously going to need Redux, so we might as well install that now.  How will we turn our markdown into beautiful HTML?  Maybe someone already has a parser written we can use or adapt.  Maybe we should go looking for a gem.  What about our routing; should we just go ahead and install react-router now, or maybe redux-little-router is a better fit for our stack? I would hate to choose the wrong one, so maybe I should read some blogs about the pro and cons...

Or, we could make hotdogs.  Not sexy, but right now anything else would be a distraction.

So, what is our application at its core? If we are building a reader, then I suppose the first feature we should scratch off the list, is providing something to read.

## Starter Setup

If you are jumping in here and want to set up the app locally, you can clone the branch snapshot:
`git clone -b Chapter2Starter https://github.com/swachtma/reactivating-rails-app.git`

## Simple Requirements

I find it is best to write out requirements each time I iterate over an application, and the first iteration can be the most difficult.  When you have a blue sky in front of you, everything seems simultaneously possible, and impossible.  We need to pick out some business rules that are big enough to get us started, but not so big that our first iteration gets away from us.

Here's a shortlist of ideas:
* We need to import a selection of .md files and display their contents to our users.
    * This could be done directly in React, or in Rails with information passed to React. 
    * We need some way of enforcing the content's order.
    * We want to support the continued crowdsourced editing of the project in the long term via GitHub.  That likely means a need for a division of content, a single document containing an entire book could make tracking changes/suggesting updates unwieldy.
        * We could enforce strict naming conventions
        * We could create simple rules (chapters ordered alphabetically by file name)
* We need a way to pass this information to our React views and display it.
    * We could pass all the content in its original text-blob format directly from the files
    * We could create an object structure that organizes information into chapters, sections, paragraphs.
    * We could create an ordered array of the document/book from begging to end.

That is my shortlist of features I am considering for iteration 1.  Not all of my ideas are crisp.  Some aren't even features.  They are business rules that are beginning to cause me worry.  However, at its root, our problem seems simple: we need to read content in, and we need to display it.  

With several ideas on the table, we need to pick a direction, and I am inclined to lean towards the simplest approach in most cases.  However, if I am honest; this is an area that often vexes me as a programmer.  The simplest approach I can see does not lead me in the direction my gut tells we are going in the medium, let alone long term.

For example, we could import our markdown files directly with our React client, and cut the server out entirely in preliminary stages of our application.  In fact, we could go very far indeed without ever involving an API server.  

However, since we know that is the path in front of us, (it is a book about using React with Rails after all), it seems a shame to architect things on the client side just to then migrate them to the API.

With that in mind, here's my compromised spec:
* Rails should expect a collection of markdown files in a project directory.
    * These files are to be read by the API and sent as a response when requested by the client.
* When the client boots, it should request the book content from the API.
* When the client receives content, it should render the text to the screen.

Not as simple as we could make it, but this is the most distilled version of our project intent I can create at this moment.  

## Reading on Rails

We could start building this spec on the client or the API side.  Where to begin is mostly a matter of preference.  I have long been a fan of view first design; building the UI, and getting that right before I line up the guts of the application to support it.  However,  I must say, when working against an API, I feel somewhat free of that constraint.  Because, at the risk of spoiling the surprise, when building an API your "view" is going to look something like:

```
{"oh gee": "what a shock, it is a bunch of JSON "}
```

Moreover, given that we can rearrange that view in about 2 shakes of a capybara's tail, I am not that inclined to fret over it.  Plus, starting with the API saves me the trouble of mocking an API for the sake of starting on the client.  So that s the way I am going to go.  

### Project Planning

We need a place inside our rails application to house our book contents in their raw markdown document form.  Since that does not fit inside our standard MVC architecture of Rails, we need to carve out some space.  I am inclined to use the `lib/` directory of our project, as in the future I expect this book import might be a process we run on a scheduled or triggered basis.  Since Rails 5 expects scheduled tasks to live in `lib/tasks`, this seems like the perfect place.

Navigate to the `lib/` directory in your terminal.  Then we need to retrieve the books files.  You can clone them from the book's GitHub repository with the command: 

`git clone https://github.com/swachtma/reactivating-rails`.

Cloning the repository creates a new directory `reactivating-rails` which contains all the book's raw .MD files, and well as an `images/` directory.

### Out with the Old

We are not going to be needing our API proxy smoke test any longer.  Before we move forward, let's clear some of the old brush:
```
rm ~/reactive-api/app/controllers/api/smoketest_controller.rb`
```

You can also delete the route from `config/routes.rb`:
``` ruby(/reactive-api/config/routes.rb)
get 'smoketest/example'
```

### In with the New

Now we can generate a new controller for sending our book contents to our client.  Also, we can demo another generator feature we neglected to use when setting up our smoke test in the previous chapter.

Run the following in your Rails project directory:

`bin/rails generate controller api/book index`

Notice the use of `api/controller` in our generator command.  That tells Rails to create our controller action inside the api directory we created in the previous chapter.  It also makes that Controller Class part of the `Api` namespace automatically and sets up a matching namespaced route.  Not bad for one command.

That said, while this is close to what I want, the generated route lands our index at `localhost/api/book/index`, but conventions for index actions do not typically require you to include *index* explicitly in the route.  Let's update `config/routes.rb` as follows:

``` ruby(/reactive-api/config/routes.rb)
namespace :api do
  get 'book/', to: "book#index"
end
```

I am choosing to use an index action here since we are planning to deliver the whole book's contents in one pass.  A `#show` action might feel more aptly named given the intent of this route. Standard convention though would expect a `show` action to accept an ID parameter in the route.  That ID parameter would dictate specific contents to display.  Since we are going to be loading the book in full, `#index` seems to be the better fit for now.  I expect in the long term we may say goodbye to this controller entirely, as we transition to serving sub-sections of the book, out of several different controllers. 

### Fat, Fat, Fat Controller

We are about to write some ugly Rails.  We are going to cram more stuff into one controller than is wise, or acceptable.  I need you to bear with me.  This first pass is not the code we are going to use in the long term.  We are just looking for the most direct way to get started so that we have a foundation (even a shaky one) on which we can begin building our application.

Open the new book#index controller we just generated.

If we are going to display our book data inside the client, we first need to locate the book's chapter files.  Then we must examine each valid file, and convert the data inside into a format we can send easily to the client.

Let start with fetching the raw data:
``` ruby(/reactive-api/app/controllers/api/books_controller.rb)
def index
  book_dir = "lib/reactivating-rails/"
  raw_file_list = Dir.entries(book_dir)
  
  filtered_file_list = raw_file_list.select do |file|
    path = book_dir + file
+     File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)
  end
 end
```

First, we are fetching an array of all the files in our book's directory using `Dir.entries`.  Unfortunately for our purposes, this also returns entries such as `..` in our set.  We also pull back the `README.md` file that containing our GitHub project description for the book.  This README is a `.md` file, but not an actual chapter of the book's content.

We must set out some criteria for what gets included as content, and what does not.  So for now, let's use the `Array.select` method to narrow down our list of files.  `Array.select` allows us to pass each member of the array to a block, and returns a new filtered array containing only members whose values caused the block to evaluate `true`.

If our case we are evaluating 3 criteria in our block:
1. The member must be a file
2. The member must have the extension `.md`
3. The filename must not be `readme.md`

If you execute the above in an IRB console you should return something like:
`["0.md", "1.md"] `

Your list might be longer, as hopefully by the time you read this I have more than 2 chapters written.

Now we have our list of file names sorted out.  Next, we need to read those files and process their content into a format we can send to the client.  Trying not to stress the format of the JSON object structure this early in the game, I am inclined merely to construct an array of the book's contents, and pass that as the payload of this API endpoint.

``` ruby(/reactive-api/app/controllers/api/books_controller.rb)
def index
  book_dir = "lib/reactivating-rails/"
  raw_file_list = Dir.entries(book_dir)
  
-   filtered_file_list = raw_file_list.select do |file|
-     path = book_dir + file
-     File.file?(path) && File.extname(path) == ".md" && !/readme\.md/i.match?(file)
-   end
  
+   filtered_file_list.sort!
+   payload = []
+   filtered_file_list.each do |file|
+     File.open(book_dir + file).each { |line| payload.append(line) }
+   end
  
+   render json: {payload: payload}, status: 200
end
```

First, I am invoking a destructive `Array.sort!` method on my list of filtered names.  Hopefully, the original array I returned was already alphabetically sorted, but I think it is best we enforce this convention with a bit of code.  For now, we are relying on the names of our chapter files being alphabetically ordered to enforce the order of the book's content.  In my case, I am naming chapter files numerically as I write this book.

We also set up an empty `payload` array, to store the contents of the book's chapters.

Then we loop through each file in our list.  With each file, we read line by line, appending to our array as we go.  Ruby helpfully lets us enumerate through files line by line, so we do not need to do any special string parsing to pull this off.

So finally, we need to render our JSON response.  For now, we are going to use a simple object structure, passing only a single key `payload`, containing the array of book content.

Notice we're now passing a status code 200 with our JSON response.  The 200 code is an OK response.  In the future, other response codes might be used to pass back different error responses as well. For now, it is good habit to get into the practice of having a response code included in our route outcomes.

With all that in place, let's run a quick test with curl.  Our updated route should have the action hosted on http://localhost:3000/api/book, however the request proxy we set up in Chapter 1 should also ensure that we have that same resource available (by proxy), on port 8080 where our client application is bound.  Let's test both of those items in one pass using the command, `curl http://localhost:8080/api/book/`.

You should get back a fairly substantial block of JSON in the form:
``` json
{ "payload": [ ... ] }
```

With that in place, we have enough scaffolded that we can turn our attention to the client.

## Our First API Call

At this point, there is no real connection between our client and API.  However, now that we have some content ready for serving, we can change that.

We need a way to manage our API calls.  Technically, we could do this with vanilla JavaScript, but that would leave us to manage cross-browser support for XHR requests.  Personally, I'd rather not reinvent that wheel.  Instead, we can farm out the subtler details of our requests to a library called [Axios](https://github.com/axios/axios), which gives us a layer of abstraction to manage communication on a browser by browser basis.  Instead, Axios gives us a shared promise based architecture we can rely on to handle our API communication.

### Installing Axios

The installation process for Axios is simple as we can manage the whole thing through NPM.  Moreso, because unlike bundler, we can add packages to our project directly from the command line, without needing to update a package list stored in our application.

From your client directory, run:
`npm install axios --save`

That flag `--save` tells NPM that we want to update our package.json file with this dependency.  If you open your `package.json` file you should see `"axios": "^0.16.2"` listed among your dependencies (your version may vary).

### Setting the Default Component State

Keeping to the path of least resistance, we are going to modify the `App.js` component that CRA bootstrapped for us, rather than starting something from scratch.  Like our API first pass, we're going to be fattening up this component with some code it ought not own.  But this will get us quickly to the goals of our first iteration.

Before we even touch an API call, let's make some enhancements to our starter component `src/App.js`:

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
  constructor(props){
    super(props);
+     this.state = {
+       book_body: ["Loading, please wait..."]
+     };
  }
  
-   render() {
-     return (
-       <div className="App">
-         <div className="App-header">
-           <img src={logo} className="App-logo" alt="logo" />
-           <h2>Welcome to React</h2>
-         </div>
-         <div className="App-intro">
-         </div>
-       </div>
-     );
-   }
}

export default App;
```

Create React App sets up our application's starter component using the new ES6 class syntax, and generally if you are starting to use React at this stage in the game, or starting a new project; this is the syntax you want to use.  While there is still support for older syntax, the community is migrating in this direction.

Before we can connect our API to this component, we need to set up a state for it which we can modify when our content loads.  I also think, that since the loading of book content will happen asynchronously, we should also set some default/placeholder text that can be displayed in the event the load from our API takes a bit of time.

To set up a state for our component we are adding a constructor method to our class.  Inside the constructor, we instantiate a `state` object and create a property `book_body`, which stores an array.  Into this array, we have loaded a few lines of default text.  This structure seems an effective way to store our application default text for now since we know our API returns us the book's content in a matching array form.

Next, we need to render out that default text, again keeping in mind that we are going to have to repeat and update this process when the book loads.

For this, let's setup a function `renderContentBlocks`, which will return an updated array of HTML elements:

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
-   constructor(props){
-     super(props);
-     this.state = {
-       book_body: ["Loading, please wait..."]
-     };
-   }
  
+   renderContentBlocks = (content) => {
+     let content_blocks = [];
+     content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
+     return content_blocks;
+   }
  
  render() {
    return (
      <div className="App">
-         <div className="App-header">
-           <img src={logo} className="App-logo" alt="logo" />
-           <h2>Welcome to React</h2>
-         </div>
        <div className="App-intro">
+           { this.renderContentBlocks(this.state.book_body) }
        </div>
      </div>
    );
  }
}

export default App;
```

We are using the new ES6 arrow function syntax here as we do not want, or need, the function to create its own binding for `this`.  We expect this function to take one argument: an array of content.  We then set up a new empty array, using the `let` keyword to limit the variable's scope to this function block.  

Then, looping through each element in the passed `content` array, we wrap the text of each in HTML paragraphs and append the updated content into our `content_blocks` array.  Notice that we are also using the length of the array we are constructing to assign a `key` property to each element we add.  Unique key values are a necessary convention whenever you create a collection of elements like this for the render function of a component.  Finally, this array gets passed as the function's return value.

> **Note:** I feel obligated to point out here that the numerical index of an array makes a lousy key.  In the future, we can use our Active Record IDs to give these values more meaning and help ensure we do not overlap element key values.  However, we are bootstrapping for the moment, so forgive me

The last thing we need to do is render this content.  React helps us here by automatically rendering the contents of any array of HTML elements/components included in our JSX.  All we need to do is update the apps' starter text with a call to our newly created render function.

Before we wrap up, let's go ahead and update the page title as well.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import logo from './logo.svg';
import './App.css';

class App extends Component {
-   constructor(props){
-     super(props);
-     this.state = {
-       book_body: ["Loading, please wait..."]
-     };
-   }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
-     return content_blocks;
-   }
  
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
+           <h2>Reactivating Rails: A work in progress</h2>
        </div>
        <div className="App-intro">
+           { this.renderContentBlocks(this.state.book_body) }
        </div>
      </div>
    );
  }
}

export default App;
```

Now let's render that content out, and we should see our new defaults loading for us:

![Updated App.js Component with Showing Default Text](/images/2/AppCompDefaultState.png)

### Making the Call

With the groundwork in place, we are ready to add in our API call.

We are going to use the component’s lifecycle method `componenetWillMount` to fire our API call.  This function gets invoked one time for each component’s lifecycle.  Since we do not expect the book API to change frequently, that makes this lifecycle method a better fit for our request than others that might get called every time the component is updated.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
+ import axios from 'axios';
import logo from './logo.svg';
import './App.css';

- class App extends Component {
-   constructor(props){
-     super(props);
-     this.state = {
-       book_body: ["Loading, please wait..."]
-     };
-   }
  
  componentWillMount(){
+     axios.get("/api/book")
+     .then(
+       (response) => {
+         this.setState((prevState) =>{
+           return {book_body: response.data.payload};
+         });
+       }
+     )
+     .catch(
+       (error) => {
+         console.log(error);
+       }
+     );
  }
  
-   renderContentBlocks = (content) => {
-     let content_blocks = [];
-     content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block}</p>)});
-     return content_blocks;
-   }
  
-   render() {
-     return (
-       <div className="App">
-         <div className="App-header">
-           <img src={logo} className="App-logo" alt="logo" />
-           <h2>Reactivating Rails: A work in progress</h2>
-         </div>
-         <div className="App-intro">
-           { this.renderContentBlocks(this.state.book_body) }
-         </div>
-       </div>
-     );
-   }
}

export default App;
```

To start, we need to import Axios as a module within this component.

Since Axios is promise based, we can add its calls to our component’s lifecycle methods without it blocking our rendering.  When Axios receives its response, it returns execution to the `then` method chained to the promise, or the `catch` method in instances where the call produces an error.

For now, we are going to limit the `catch` branch of the promise to logging the error to the console. 

Right now, let's focus on the `then` branch of our promise.  We are expecting Axios to return a response object, which should house the content of our book at `response.data.payload`.  We then use the setState function of the component to update the book_body property of the state with the content we loaded.

setState receives an anonymous function, which in turn receives the previous (current) application state as a parameter.  The function is expected to return a **new** object representing the component state, **not** an updated copy of the previous state object.  Hence our function returns a new object, using the object literal syntax, and assigning the book_body attribute of this new object to the content we have loaded from our API.

When the component receives a new state, it is rendered again using that updated state, and we finally have a readable representation of our book.

![First rough render of our book content](/images/2/FirstBookRender.png)

## Refactoring the API logic

At this point, we have got our hotdog.   We have packed it full of unsavory bits, and I would rather no one ever know all that's going on inside.  Still, the end product is something that very minimally fulfills our needs.

Now it's time to run back through this code, and make some incremental improvements.

I am less concerned about our client for the moment because I foresee us abandoning this front-end implementation entirely as our needs evolve.  The API however, is already doing some things that are going to be around for the long term; namely locating and parsing our chapter files.  It is also doing them in a very inappropriate place. We probably won't be able to solve for all of that right now, but we can take some steps in the right direction.

I also think we should take a moment to implement some tests to support these features of our application that might be sticking around.

### A Good Place to Part Ways

If you are already confident in your abilities with Rails, this might be a good point for you to jump forward to Chapter 3.  For the remainder of this chapter, we are going to focus on refactoring our API code, installing Rspec, and laying down some foundational tests.  If you're up to speed on all of that, I suggest jumping forward to the commit at the beginning of Chapter 3.  That is the next chapter focusing on interactions between React and Rails.  If some exposure to Rails in isolation sounds helpful, stick with me for the next few sections.

### Refactoring Book#index

We need to skinny down our fat controller so that it is not managing the minutia of loading our book's content.  Instead, our action should focus on handling just the request/response process.

There are two steps crammed into this index action that certainly do not belong:
1. Locating relevant chapter files from a directory
2. Processing those files into a response format

We are going to skinny up our controller by moving each of these processes above into a standalone class.  For now, those class files should live in `controllers/concerns`, since we are invoking them in our controller actions (for now).

There is also one other substantial problem with our parsing of the chapter files.  We are treating each line of the files we read as its own block of content.  However, `.md` files have several elements in them that are block-level elements (meaning they store nested inline elements, or other blocks, as parts of a larger structure).  Since our parser treats every line as a new block, we are creating elements like ordered and unordered lists but wrapping each list item in a surrounding paragraph tag.

That is going to be a major headache when we try to parse this `.md` content into HTML.  So as we refactor the file parsing let's also try to extend our parse logic a bit to better deal with this case.

All this still ignores the glaring problem that we are reprocessing this response from raw content **every** time this request/action fires.  Easily addressed, but best deferred until we have Active Record models defined to lean on.

### Finding Files

Let's start with the file location problem since it is the easier of our two refactors.  

The end goal of this Class is to provide us a filtered array of files.  Right now, we are returning an ordered list of **only** the file names.  Only having access to the file names creates a burden in our controller action where we need to maintain the directory path as a standalone variable, and pass both the file array, and the path to our book's directory, as parameters to our parser.  Ideally, the file locator class would return a ready to use array with a full path of each file as its elements.

Let's start by simplifying our controller to the interface we would like the new class to provide.

``` ruby(/reactive-api/app/controllers/api/books_controller.rb)
class Api::BookController < ApplicationController
  def index
+     file_list = BookFileFinder.new("lib/reactivating-rails/").entries
    
    payload = []
+     file_list.each do |file|
+       File.open(file).each { |line| payload.append(line) }
+     end
    
    render json: {payload: payload}, status: 200
  end
end
```

Notice we have stripped out the directory traversal, and filtering of files from the controller action.  Instead, we'll be instantiating a new instance of `BookFileFinder`, and expecting it to provide an entries attribute: `file_list = BookFileFinder.new("lib/reactivating-rails/").entries`

The captured `file_list`, is then used by our parsing logic, which remains unchanged for now.  Now, let's set up the actual class.

``` ruby(reactive-api/app/controllers/concerns/book_file_finder.rb)
class BookFileFinder
  attr_reader :entries
  
  def initialize(path)
     @path = path 
     @entries = locate_chapter_files.sort!
  end
  
  def locate_chapter_files
     raw_file_list = expand_file_paths(Dir.entries(@path))
     filter_chapter_files(raw_file_list);
  end
  
  def filter_chapter_files(raw_file_list)
      filtered_list = raw_file_list.select do |file|
          File.file?(file) && File.extname(file) == ".md" && !/readme\.md/i.match?(file)
      end
  end
  
  def expand_file_paths(file_array)
    file_array.map do |file|
      @path + file
    end
  end
end
```

First, we declare an attr_reader for our class' intended interface, `entries`.  

Our class' `initialize` function expects one parameter, a path to our book's directory.  It also sets our `entries` attribute by kicking off our traversal of the files directory by invoking `locate_chapter_files`.  Most of the logic migrates over directly from our controller.  We have introduced the `expand_file_paths` method to the class to meet our new requirement of returning an array containing complete file paths.

Inside `expand_file_paths` we use the `Array.map` method to transform each member in the passed file array, concatenating the base `@path` variable onto each file name.  The logic then continues as we saw in our controller; the list of files is filtered to contain only chapter files, and finally the array is sorted alphabetically.

Now would be a good time to refresh your client, and ensure we have not broken anything during our refactor.

### Upgrading our Parser

Now that we have cleaned up our file finder a bit let's give a similar upgrade to our parsing logic.

A direct line by line import of our MD files is going to cause some issues because as we have mentioned, some elements of MD markup are blocks that span multiple lines.  We are going to do the majority of our parsing from MD to HTML on the client.  Except I think we can benefit from having a Ruby parsing implementation take a first pass for us.  When we are ready to store this information in our database, we can trust content splits along sensible units of work for our client.

We'll use this server-side pass through to cut our imported files into block elements of Markdown.  Note that we are not going to translate anything into HTML at this stage; which saves us some trouble managing HTML escapes as we pass data around.

To start, let's install the `commonmarker` gem (add `gem 'commonmarker'` to your gemfile).  Then run a `bundle install`.


``` ruby(reactive-api/app/controllers/concerns/book_file_parser.rb)
class BookFileParser
  attr_reader :payload
  
  def initialize(files_array)
     @files_array = files_array
     @payload = []
     parse_chapter_files
  end
  
  def parse_chapter_files
    @files_array.each do |file|
      raw_doc = File.read(file)
      md_doc = CommonMarker.render_doc(raw_doc)
      md_doc.each do |node|
        @payload.push(node.to_commonmark)
      end
    end
  end
end
```

Start by setting up an initializer to create two instance variables; `@files_array` and `@payload`.  Payload serves as the public interface of our class and is where we build the store of parsed content as we move through the book's files.

`parse_chapter_files` is running the actual processing of the MD files.  We are simply using the prepared list of book files from `BookFileFinder` to drive a loop of all our chapter files.  Note that we have changed to `File.read` rather than `File.open` as we used previously.  This change gives us the entire contents of the file as a string, rather than offering it for line by line consumption.

The entire contents of the raw files are passed to `CommonMarker.render_doc`.  CommonMarker translates the MD files into a map of nodes (A tree structure containing a top-down map of the elements in a document.  Starting at the top level with a document node, then traversing down into the top level of block elements, and from there to the nested elements inside.)

We can enumerate through the top level of this node map using `.each`.  As each top-level node of the document gets passed to the block, we instruct `CommonMarker` to give us back the node in markdown syntax so that we can provide it to the payload.

Now we can simplify our `book#index` action to use this class to construct our payload.

``` ruby(/reactive-api/app/controllers/api/books_controller.rb)
class Api::BookController < ApplicationController
  def index
    file_list = BookFileFinder.new("lib/reactivating-rails/").entries
+     payload = BookFileParser.new(file_list).payload
    render json: {payload: payload}, status: 200
  end
end
```



A quick render of our client shows that we have successfully solved the parsing process that we set out to fix.  Take a look at this updated list node in our rendered application.  There is still a long way to go to beautify this display, but the list elements are no longer cut into separate nodes.  That is a real first step.

![List item contents rendered as a single HTML element](/images/2/updatedListRender.png)

## Add Some Tests

Now that we have got some code that is beginning to stabilize, this seems like the right moment to add some tests.

I am going to forego testing book#index for now, as I do not expect it to remain with us for very long.  However, the two classes we built in our refactor are likely to last.  Having some tests on the public interfaces of these classes would serve as a place to start.

Let's begin by setting up Rspec (rspec-rails).  The documentation for [rspec-rails](https://github.com/rspec/rspec-rails) tells us to add the dependency in both the :test and :development groups of our gemfile.

``` ruby
group :development, :test do
  gem 'rspec-rails', '~> 3.6'
end
```

Bundle install, and then run the included generator to set up your `spec/` directory: `rails generate rspec:install`

I like my specs folder to mirror my application layout as much as possible, so I am going to create a new directory path for my tests:
`mkdir -p spec/controllers/concerns`

Also, to test our file processors, it would help to have some controlled test files to run tests against.  Execute the following commands in your terminal.

``` bash
cd spec/controllers/concerns
mkdir testbook/
touch testbook/readme.md
mkdir testbook/images
touch testbook/mockChapter.md
touch testbook/someFile.txt
```

Let's create a simple test for our file finder.

``` ruby(reactive-api/spec/controllers/concerns/book_file_finder_spec.rb)
require 'rails_helper'

RSpec.describe BookFileFinder do
  it "removes readme.md, directories, and non-md files from return" do
    path = "spec/controllers/concerns/testbook/"
    entries = BookFileFinder.new(path).entries
    expect(entries.length).to eq 1
    expect(entries[0]).to eq path+"mockChapter.md"
  end
end
```

As I often do, when writing this test, I found something I had not considered.  Currently, our path parameter could receive a value without a trailing slash.  Paths ending without a slash work fine for locating the files in the directory.  When we transform the array to contain full paths though, the lack of trailing slash might create a directory like `some_file_pathFILE.md` rather than `some_file_path/FILE.md`.  Let's issue a quick update to deal with this.

``` ruby(reactive-api/app/controllers/concerns/book_file_finder.rb)
class BookFileFinder
  attr_reader :entries
  
-   def initialize(path)
-      @path = normalize_folder(path) 
-      @entries = locate_chapter_files.sort!
-   end
  
  private
+     def normalize_folder(path)
+       path[-1] == "/" ? path : path + "/"
+     end
    
-     def locate_chapter_files
-        raw_file_list = expand_file_paths(Dir.entries(@path))
-        filter_chapter_files(raw_file_list);
-     end
    
-     def filter_chapter_files(raw_file_list)
-         raw_file_list.select do |file|
-             File.file?(file) && File.extname(file) == ".md" && !/readme\.md/i.match?(file)
-         end
-     end
    
-     def expand_file_paths(file_array)
-       file_array.map do |file|
-         @path + file
-       end
-     end
end
```

Our new `normalize_folder` method, checks the last character of the provided path.  If the path does not already terminate with a slash, one gets appended.  We are also taking this moment to mark the methods of this class as private; we are relying on our attr_reader `entries` for all interaction with this class.

We should probably also add a test for this new path normalization function since it is controlling a behavior tied to our class' public interface:

``` ruby(reactive-api/spec/controllers/concerns/book_file_finder_spec.rb)
require 'rails_helper'
RSpec.describe BookFileFinder do
-   it "removes readme.md, directories, and non-md files from return" do
-     path = "spec/controllers/concerns/testbook/"
-     entries = BookFileFinder.new(path).entries
-     expect(entries.length).to eq 1
-     expect(entries[0]).to eq path+"mockChapter.md"
-   end
  
+   it "enforces proper file path" do
+     path = "spec/controllers/concerns/testbook/"
+     bad_path = "spec/controllers/concerns/testbook"
+     expect(BookFileFinder.new(path).entries).to eq BookFileFinder.new(bad_path).entries
+   end
end
```

Done!  Now let's take a pass at the `BookFileParser` class.  First let's add some mocked content to our `mockChapter.md` file:

![mockChapter.md file contents](/images/2/mockChapter.png)

Now we can add tests for the class.

``` ruby(reactive-api/spec/controllers/concerns/book_file_parser_spec.rb)
require 'rails_helper'

RSpec.describe BookFileParser do
  it "creates payload of top-level blocks from array of MD files" do
    payload = BookFileParser.new(["spec/controllers/concerns/testbook/mockChapter.md"]).payload
    expect(payload.length).to eq 13
  end
end
```

I've included some MD content in our test file.  We do not own the majority of this code, so I am limiting our test to the assumption that for each "block" content element in our file we should return one member in our `payload` array.  Inline elements are not to create their own array members, nor do nested blocks.  Thus our expected length of the payload is 13 items.  It is not the most robust spec, but it validates our assumption that we are getting the basic block-level parse we intended from our `CommonMarker` gem.

Take a moment to mark your methods in `BookFileParser` as private, as we did in `BookFileFinder`.  Again, we are using the `payload` interface provided by our `attr_reader` as the only public interface of this class.

## Summary

That is the end of Chapter 2.  We are still looking pretty rough at this point, but we have met the goal of our first iteration.  A truly determined reader could sit down and slug their way through our book at this point. 

1. We set up an API action `book#index` to do a wholesale parse and pass of our book contents to the client.
2. We added our first API call to the client to retrieve this information.
3. We added some preliminary server-side parsing of our MD content to prepare for a more detailed client-side render in a future iteration.
4. Rspec has been installed, and some tests added as we refactored our controller action.

Now we move onto Chapter 3 and our next iteration.
