# Chapter 12: Managing Authenticated Requests

In chapter 11 we created our authentication system using GitHub's OAuth API and JSON Web Tokens.  This chapter introduces our first authenticated action; bookmarking, which returns users to their last-read or furthest-read locations.  

We also introduce error handling to ease recovery from catastrophic errors.  Finally, we add some persistent state client-side to retain user tokens across multiple visits.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch12-starter
```

**Note:** changes listed below in the section "Chapter 12 Setup Files" have already been included in the ch12-starter branch.

## Chapter 12 Setup Files

The examples below create a `bookmarks` reducer and some supporting UI components. Since previous chapters covered similar topics in detail, I am not providing in-depth explanations of these changes, allowing us to move more quickly to the new concepts introduced this chapter.

If you are following along, you should copy the following files into your local project.

### The Bookmarks Reducer

The following files build a reducer tracking two locations; a `last_read` position and a `furthest_read` position.  Both bookmark locations update from a single `SET_BOOKMARK_LOCATIONS` action.

``` javascript(/client/src/constants/bookmarks.js)
export const SET_BOOKMARK_LOCATIONS = "SET_BOOKMARK_LOCATIONS";
export const SET_BOOKMARK_OFFERED = "SET_BOOKMARK_OFFERED";
```

``` javascript(/client/src/actions/bookmarks.js)
import * as constants from "../constants/bookmarks";

export const setBookmarkLocations = (chapter_id) => ({
  type: constants.SET_BOOKMARK_LOCATIONS, payload: {chapter: chapter_id}
});

export const setBookmarkOffered = (bool) => ({
  type: constants.SET_BOOKMARK_OFFERED, payload: {prompt_shown: bool}
});
```

``` javascript(/client/src/actions/bookmarks.spec.js)
/* global expect */
import * as actions from './bookmarks';

describe("Bookmarks actionCreators", ()=>{
  describe("setBookmarkLocations(chapter_id)", ()=>{
    test("matches snapshot", () =>{
      expect(actions.setBookmarkLocations(1)).toMatchSnapshot();
    });
  });
  
  describe("setBookmarkOffered(true)",()=>{
    test("matches snapshot", () =>{
      expect(actions.setBookmarkOffered(true)).toMatchSnapshot();
    });
  });
});
```

``` javascript(/client/src/reducers/bookmarks.js)
import * as constants from '../constants/bookmarks';

const default_state = {
  prompt_shown: false,
  last_read: {chapter: 1},
  furthest_read: {chapter: 1}
};

export const buildLocations = (state, new_loc) => {
  let position = state.furthest_read.chapter < new_loc.chapter ? new_loc : state.furthest_read;
  return Object.assign({}, state, {last_read: new_loc, furthest_read: position});
};

const bookmarksReducer = function(state = default_state, action){
  switch (action.type) {
    case(constants.SET_BOOKMARK_LOCATIONS):
      return buildLocations(state,action.payload);
    case(constants.SET_BOOKMARK_OFFERED):
      return Object.assign({}, state, {prompt_shown: action.payload.prompt_shown});
    default:
      return state;
  }
};

export default bookmarksReducer;
```

``` javascript(/client/src/reducers/bookmarks.spec.js)
/* global expect */
import  bookmarksReducer, { buildLocations } from './bookmarks';
import * as actions from '../actions/bookmarks';

let defaultState = { prompt_shown: false, last_read: {chapter: 1}, furthest_read: {chapter: 1} };

describe("bookmarks Reducer", ()=>{
  describe("buildLocations",()=>{
    test("updates furthest_read only on progress",()=>{
      let bookmarks = buildLocations(defaultState,{chapter: 2});
      expect(bookmarks.furthest_read.chapter).toEqual(2);
      
      bookmarks = buildLocations(bookmarks,{chapter: 1});
      expect(bookmarks.furthest_read.chapter).toEqual(2);
    });
    
    test("always updates last_read",()=>{
      let bookmarks = buildLocations(defaultState,{chapter: 2});
      expect(bookmarks.last_read.chapter).toEqual(2);
      
      bookmarks = buildLocations(bookmarks,{chapter: 1});
      expect(bookmarks.last_read.chapter).toEqual(1);
    });
  });
  
  describe("bookmarksReducer",()=>{
    test("sets prompt_shown true on setBookmarkOffered(true) action",()=>{
      let state = bookmarksReducer(defaultState,actions.setBookmarkOffered(true));
      expect(state.prompt_shown).toEqual(true);
    });
    
    test("sets both bookmarks on setBookmarkLocations",()=>{
      let state = bookmarksReducer(defaultState,actions.setBookmarkLocations(2));
      expect(state.last_read.chapter).toEqual(2);
      expect(state.furthest_read.chapter).toEqual(2);
    });
  });
});
```

### Bookmark Modal UI

The following file changes build the UI control handling bookmark navigation.  This modal appears center-screen when users reach a chapter view/route with `bookmarks.prompt_shown` set to `false`.

``` javascript(/client/src/components/bookmark_modal.js)
import React, { Component } from 'react';
import { Button, Header, Icon, Modal } from 'semantic-ui-react';

class BookmarkModal extends Component {
  handleClose = () => this.props.dispatchSetBookmarkOffered(true);
  
  handleLastReadClick = () => {
    this.handleClose();
    this.props.dispatchRoutechapter(this.props.last_read.chapter);
  }
  
  handleFurthestReadClick = () => {
    this.handleClose();
    this.props.dispatchRoutechapter(this.props.furthest_read.chapter);
  }
  
  printLastReadButtonIf = (truthy) => {
    if(truthy){
      return (
        <Button color='yellow' onClick={this.handleLastReadClick} inverted>
          <Icon name='checkmark' /> Last read (Ch:{this.props.last_read.chapter})
        </Button>
      );
    }
  }
  
  render(){
    let last_read = this.props.last_read.chapter;
    let furthest_read = this.props.furthest_read.chapter;
    
    return(
      <Modal open={this.props.displayState} onClose={this.handleClose} basic size='small'>
        <Header icon='archive' content='Pick up where you left off' />
        <Modal.Content>
          <p>We've saved some bookmarks on your behalf.  Would you like to resume reading at one of these locations?</p>
        </Modal.Content>
        <Modal.Actions style={{textAlign: "center"}}>
          <Button basic color='red' onClick={this.handleClose} inverted>
            <Icon name='remove' /> No, stay here
          </Button>
          { this.printLastReadButtonIf(last_read !== furthest_read) }
          <Button color='green' onClick={this.handleFurthestReadClick} inverted>
            <Icon name='checkmark' /> Furthest read (Ch:{furthest_read})
          </Button>
        </Modal.Actions>
      </Modal>
    );
  }
}

export default BookmarkModal;
```

``` javascript(/client/src/containers/bookmarks_provider.js)
import { connect } from 'react-redux';

import BookmarkModal from '../components/bookmark_modal'
import { setBookmarkOffered } from '../actions/bookmarks';
import { routeChapter } from '../actions/routes';

export const calculateDisplayState = (state) => {
  let bm = state.bookmarks;
  let loc = state.location.payload.chapter_id;
  if(bm.prompt_shown || (loc === bm.last_read.chapter && loc === bm.furthest_read.chapter)){
    return false;
  } else {
    return true;
  }
};

const bookmarksProvider = (WrappedComponent = BookmarkModal) => {
  let mapStateToProps = (state) => ({
    displayState: calculateDisplayState(state),
    last_read: state.bookmarks.last_read,
    furthest_read: state.bookmarks.furthest_read
  });
  
  let mapDispatchToProps = (dispatch) => ({
    dispatchSetBookmarkOffered: (bool) => dispatch(setBookmarkOffered(bool)),
    dispatchRoutechapter: (chapter_id) => dispatch(routeChapter(chapter_id))
  });
  
  return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
};

export const ConnectedBookmarkModal = bookmarksProvider();
export default bookmarksProvider;
```

### Client-Side Error Page

The file changes below create a client-side error page where we can redirect users to after catching critical errors.  Create or update the following files.

``` javascript(/client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
export const AUTH_ROUTE = "AUTH_ROUTE";
export const ERROR_ROUTE = "ERROR_ROUTE";
```

``` javascript(/client/src/actions/routes.js)
import * as routes from '../constants/settings';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);

export const routeError = () => ({type: routes.ERROR_ROUTE});
```

``` javascript(/client/src/reducers/store.js)
- import { createStore, combineReducers, applyMiddleware } from "redux";
- import { composeWithDevTools } from 'redux-devtools-extension';
- import createSagaMiddleware from 'redux-saga'
- import { connectRoutes } from 'redux-first-router';
- import restoreScroll from 'redux-first-router-restore-scroll'
- import createHistory from 'history/createBrowserHistory';
- 
- import * as ROUTES from '../constants/settings';
- import chapters from './chapters';
- import nodes from './nodes';
- import settings from './settings';
- import alerts from './alerts';
- import user from './user';
- import bookmarks from './bookmarks';
- import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
  [ROUTES.AUTH_ROUTE]: "/auth/:token",
+   [ROUTES.ERROR_ROUTE]: "/error"
};

const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = - - connectRoutes(
-   history,
-   routeMap,
-   { restoreScroll: restoreScroll(), initialDispatch: false }
- );

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

- const store = createStore(
-   reducers, composeWithDevTools(routerEnhancer, middlewares)
- );

sagaMiddleware.run(rootSaga);
initialDispatch();

export default store;
```

``` javascript(/client/src/components/error_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import Link from 'redux-first-router-link';
import { routeHome } from '../actions/routes'; 

class ErrorPane extends Component {
  render() {
    return (
      <div id="error-pane">
        <Container text>
          <h1>Well Shucks...</h1>
          <p>This page is where we, unfortunately, have to make up some cutesy reason to apologize for our site not working at the moment. Perhaps the legion of radioactive cyborg battle-hamsters we were breeding have escaped confinement?</p>
          
          <p>In any case, we do not seem able to do the things at the moment.</p>
          
          <p>How about you <Link to={ routeHome() }>head to the homepage</Link> and give it another go? Try not to break anything this time.</p>
        </Container>
      </div>
    );
  }
}

export default ErrorPane;
```

``` javascript(/client/src/containers/route_provider.js)
import { connect } from 'react-redux';
import RouterSwitch from '../components/router_switch';

const routerProvider = (WrappedComponent = RouterSwitch) => {
  let mapStateToProps = (state) => ({
    location: state.location
  });
  
  return connect(mapStateToProps,null)(WrappedComponent);
};

export default routerProvider;
```

``` javascript(/client/src/components/router_switch.js)
import React, { Component } from 'react';
import ReaderPane from './reader_pane';
import ErrorPane from './error_pane';
import * as routes from '../constants/settings';

class RouterSwitch extends Component {
  render() {
    switch(this.props.location.type){
      case(routes.ERROR_ROUTE):
        return(<ErrorPane />);
      case(routes.CHAPTER_ROUTE):
        return(<ReaderPane />);
      case(routes.HOME_ROUTE):
        return(<ReaderPane />);
      default:
        return(<ErrorPane />);
    }
  }
}

export default RouterSwitch;
```

The last piece of UI prep we need to take care of is updating our `ReaderPane` and `App` components to use the newly created `ErrorPane` and `RouterSwitch` components.  We are also making a small adjustment to our stylesheet.

``` javascript(/client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
        <MenuBar />
+         <Container text id="main-section">
+           <ApplicationAlerts />
+           <ConnectedRouterSwitch />
+         </Container>
      </div>
    );
  }
}

export default App;
```

``` javascript(/client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import FilteredNodesList from '../containers/filtered_nodes_list';
import { ConnectedChapterFooterLink } from '../containers/chapter_provider';
import { ConnectedBookmarkModal } from '../containers/bookmarks_provider';

const reader_pane_styles= {
  paddingBottom: "15px"
};

class ReaderPane extends Component {
  render() {
    return (
      <div id="reader-pane" style={ reader_pane_styles }>
        <ConnectedBookmarkModal />
+         <Container text>
+           <FilteredNodesList />
+         <ConnectedChapterFooterLink />
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

``` css(/client/src/App.css)
img {max-width: 100%;}

.ui.menu .item {padding: 0 1em;}

+ #main-section {margin-top: 85px;}
#reader-pane img {border: 1px solid #021a40;}

code {
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
  padding: 0.2em .5em;
  margin: 0;
  font-size: 85%;
}

.codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
.codeGutter .fa { font-size: 12px; opacity: 0; }
.lowPrioritySection .fa { opacity: 100; }
.lowPrioritySection { cursor: pointer; } 
.highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }
pre {white-space: pre-wrap; margin: 0;}
#root .hljs {padding: 0;}

@media only screen and (max-width: 990px) {
  #app .banner {
    margin-left: -10px;
  }
}

@media only screen and (max-width: 767px) {
 #app #reader-pane {
   margin-top: 125px;
 }
}
```

If you want to test that you have everything wired correctly before moving on,  you can change your default state in the `bookmarks` reducer to set `bookmarks.prompt_shown` to a default value of false.  You should see a prompt as soon as you visit a chapter route.

![Prompt Offering Option to Jump Immediately to a Bookmark](/images/12/BookmarkModalPrompt.png)

## Sending Authentication Headers

With a token in our store for authenticated users, we need a mechanism for users to make authenticated requests.  To do this, we can send the JWT token in an authorization header.  Methods in our `ApplicationController` can then validate these tokens, and limit access to protected API endpoints.

Begin by preparing for the client-side request. So far we have used Axios in one-off fashion when sending requests.  Now that we need more complexity in our requests, we should formalize our Axios client setup.

Set up a new folder `src/sagas/utils`.  This folder can store generator functions used by our sagas that are not themselves directly connected to a watcher saga.

``` javascript(/client/src/sagas/utils/axios_client.js)
import axios from 'axios';
import {  select } from 'redux-saga/effects';

export default function* axiosCreateClient(req_auth = true){
  let token = yield select((s) => s.user.token);
  let client = axios.create();
  
  if(token){
    client.defaults.headers.common['Authorization'] = token;
    return client;
  } else {
    return req_auth ? null : client;
  }
}
```

`axiosCreateClient` is a generator function which creates an Axios client.  By default, this function tries to create a client with authorization headers, returning `null` if a token is unavailable.  We can also override the function's defaults to produce a public client without an authorization header.

Next, create a barebones `setBookmarks` saga using our new Axios configuration.

``` javascript(/client/src/sagas/set_bookmarks.js)
import { takeEvery, call } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';

export function* setBookmarks(){
+  const auth_client = yield axiosCreateClient();

+  if(auth_client){
    try{
      let response = yield call(auth_client.post,'/api/bookmarks');
      console.log(response);
    } catch(e){
      console.log(e);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

Notice our saga yields to call `axiosCreateClient`.  Generator functions can invoke additional generators, allowing us to precisely order operations.  By yielding into another generator, we suspend `setBookmakrs` until `axiosCreateClient` completes, allow the nested generator time to query our store and create the appropriate client.

`axiosCreateClient` either returns `null` or an authorized client for authenticated users.  For a `null` client, our saga ends immediately.  When returned an authorized client, we make a POST request to an `api/bookmarks` route.  For now, we are sending all responses and errors from this request to our console.

Now we can create the API support for this route.  Run the command below to create a new resource `bookmarks`, and be sure to run your database migrations before continuing.

``` bash
docker-compose exec api bin/rails generate resource Bookmark user_id:integer last_read:integer furthest_read:integer
```

We should also create associations between our `User` and `Bookmark` models.

``` ruby(/api/app/models/user.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

class User < ApplicationRecord
+   has_one :bookmark
  
-   def fsa(token)
-     {
-       id: id,
-       github_email: github_email,
-       username: username,
-       avatar: avatar,
-       token: token
-     }
-   end
  
-   def self.create_or_fetch(user)
-     find_by(github_id: user.id) || create(
-       github_id: user.id,
-       github_email: user.email,
-       username: user.login,
-       avatar: user.avatar_url
-     )
-   end
end
```

``` ruby(/api/app/models/bookmark.rb)
# == Schema Information
#
# Table name: bookmarks
#
#  id            :integer          not null, primary key
#  last_read     :integer
#  furthest_read :integer
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  user_id       :integer
#

class Bookmark < ApplicationRecord
+   belongs_to :user

+   def fsa
+     {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
+   end
end
```

Modify the generated routes so to align with our existing `/api` nesting.  We are limiting this resource to support only `create` and `index` actions.

``` ruby(/api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
    get 'github/', to: "authentication#github", format: false
    get 'hydrate_user/', to: "authentication#show"
    get 'nodes/', to: "nodes#index"
    get 'chapters/', to: "chapters#index"
+     resources :bookmarks, only: [:index, :create]
  end
end
```

Finally, modify the generated controller.  Be sure to nest this controller inside your `Api` module as shown below, and relocate the file itself to the `/api` directory.

``` ruby(/api/app/controllers/api/bookmarks_controller.rb)
+ class Api::BookmarksController < ApplicationController
  def index
    render json: {payload: "success"}, status: 200
  end
  
  def create
    render json: {payload: "success"}, status: 200
  end
end
```

Log in and then revisit a chapter route (not the homepage) to check your work.  You should see the console logged response from your controller.

![Console Response from Bookmark Controller Stub](/images/12/ConsoleBookmarkResponse.png)

## Checking Authorization Headers

With a very basic controller and saga, we can turn our attention to protecting our authenticated actions.  Since we need to control access across many controllers/actions, it makes sense to configure this logic in our `ApplicationController`.

``` ruby(/api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
  def authenticate_request!
      fail StandardError unless user_id_in_token?
      @current_user = User.find(@decoded_token["id"])
  end
  
  private
    # Decode the authorization header token and return the payload
    def user_id_in_token?
      auth_token && decoded_token && @decoded_token["id"]
    end
    
    def decoded_token
      @decoded_token ||= TokenOps.decode(auth_token)[0]
    end
  
    def auth_token
      @http_auth_token ||= request.headers['Authorization']
    end
end
```

The root of our authentication logic lives in the newly created `authenticate_request!` method.  This method raises an error unless all the conditions inside `user_id_in_token?` pass.  An authorization header must contain a valid JWT, and that the token, when decoded, must contain a user id.

If the request meets these conditions, an instance variable `@current_user` is created containing our record of the user.

Upgrade `BookmarkController` to leverage this authentication method.

``` ruby(/api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
+   before_action :authenticate_request!, only: [:index, :create]
  
  def index
  end
  
  def create
+     ch_id = params[:chapter_id]
+     
+     bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
+     bookmark.update(last_read: ch_id, furthest_read: ch_id)
+     render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
  end
end
```

A `before_action` hook now calls `ApplicationController#authenticate_request!` as a prerequisite for both controller actions.  This filter ensures requests that proceed into our controller's `create` and `show` actions have a valid user available in `@current_user`.  

From there, our `create` action expects a single parameter, the chapter ID used for updating or creating our bookmarks.  We are using ActiveRecord's `find_or_initialize_by` to either retrieve an existing record or instantiate a new bookmark for us.  Then we update the record's chapter id values for both bookmark types.  

Finally, we render some JSON containing a simple confirmation message of the update.

Before returning to the client, we should revisit our model.  The `furthest_read` bookmark should never reduce it's current value to an earlier chapter.  Let's update our `Bookmark` model to enforce this rule.

``` ruby(/api/app/models/bookmark.rb)
- # == Schema Information
- #
- # Table name: bookmarks
- #
- #  id            :integer          not null, primary key
- #  last_read     :integer
- #  furthest_read :integer
- #  created_at    :datetime         not null
- #  updated_at    :datetime         not null
- #  user_id       :integer
- #

class Bookmark < ApplicationRecord
  belongs_to :user
+   before_save :ensure_furthest_location
  
  def fsa
    {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
  end
  
+   def ensure_furthest_location
+     if(bm = Bookmark.where(user_id: self.user_id).first)
+       self.furthest_read = bm.furthest_read unless self.furthest_read > bm.furthest_read
+     end
+   end
end
```

Using an ActiveRecord `before_save` callback, we can run a new method `ensure_furthest_location` before updating our database.  The method locates our existing record and checks whether the stored `furthest_read` value is greater than the new value.  If the database value is higher, we override the save to persist the existing bookmark for furthest read location.

Finish the bookmark creation client-side by returning to our saga.

``` javascript(/client/src/sagas/set_bookmarks.js)
import { takeEvery, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setBookmarkLocations } from '../actions/bookmarks';

export function* setBookmarks(action){
+   let ch_id = action.payload.chapter_id;
+   const auth_client = yield axiosCreateClient();
+   //Set bookmarks locally
+   yield put(setBookmarkLocations(ch_id));
  
  if(auth_client){
    try{
+       let response = yield call(auth_client.post,'/api/bookmarks',{chapter_id: ch_id});
+       console.log(response.data.message);
    } catch(e){
      console.log(e);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

Our bookmarks should update client-side each time a chapter route loads.  Authenticated users also execute the try block, sending a post request to `/api/bookmarks` to save the bookmarks server-side as well.

Log into your application, and make a chapter request.  You should see the response logged to your console.

![Console Confirmation of BookmarksController#create](/images/12/BookmarkCreateLog.png)

## Preserving Reader Position Through Log In

Before we move onto restoring bookmark locations, we need to remove another wort from our initial authentication design.  Currently, when a user signs in, we route everyone to the homepage after returning from GitHub.  Ideally, we would direct them back where they were before leaving the site.

To do this, we can pass a redirect URL through our initial GitHub request, which overrides the default value we set when configuring our OAuth application.

Create some new constants for our client, storing the top-level domain information needed for our redirects.

``` javascript(/client/src/constants/settings.js)
+ export const BASE_AUTH_PATH = "http://localhost/api/github/"

export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
export const AUTH_ROUTE = "AUTH_ROUTE";
export const ERROR_ROUTE = "ERROR_ROUTE";
```

Let's update our Github/Profile badge component.  We need our `location` state available in this component, so let's begin by breaking that out as a standalone component.

``` javascript(/client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';
+ import routeProvider from '../containers/route_provider';

class GithubIcon extends Component {
+   buildRedirect = (loc = this.props.location) => {
+     let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
+     return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
+   }
  
  render() {
    let rd = this.buildRedirect();
    return (
+       <Menu.Item href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd} name='Sign in with GitHub'>
        <Icon name='github' style={{marginRight: 0}} size="big" />
      </Menu.Item>
    );
  }
}

+ const ConnectedGitHubIcon = routeProvider(GithubIcon);
+ export default ConnectedGitHubIcon;
```

We can reuse the `routeProvider` function we built for our navigation dropdowns to power this badge.  We create the module to export our component after passing through this provider function.

Our redirect uses a feature in the GitHub OAuth setup we ignored previously.  GitHub allows us to make our initial request with a `redirect_uri` parameter to override the global settings we configured with GitHub.  `redirect_uri` contains a URL to our application, and that redirect URI will itself contain **another** redirect URI named `bounce_path`.  Our API catches this `bounce_path` parameter and passes it to our client authorization route after creating the user's JWT token.  We are using `encodeURIComponent` to make all our values URL safe for this process.

Update `UserBadge` to use this new component.

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

+ import ConnectedGitHubIcon from './github_icon';

class UserBadge extends Component {
  render() {
    if(!this.props.username){
      return (
+         <ConnectedGitHubIcon />
      );
    } else {
      let badge = <Image src={this.props.avatar} avatar />;
      return (
        <Menu.Item name={this.props.username}>
          <Dropdown icon={badge} compact pointing="top right">
            <Dropdown.Menu>
              <Dropdown.Item onClick={this.props.dispatchClearUser}>Sign Out</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </Menu.Item>
      );
    }
  }
}

export default UserBadge;
```

Users returning to our API after authorizing Github, now have an extra URL parameter `bounce_path` available.  Let's update our controller action to handle this value.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    code = params[:code]
+     bounce_path = ERB::Util.url_encode(params[:bounce_path])
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
    user = User.create_or_fetch(github_users.get)
    jwt = TokenOps.encode_short(user)
    
+     redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
  end
  
-   def show
-     token = params[:token]
-     user_id = TokenOps.decode(token)[0]["id"]
-     user = User.find(user_id)
-     long_token = TokenOps.encode_long(user)
-     
-     render json: user.fsa(long_token), status: 200
-   end
end
```

Fetching `bounce_path` from the URL, we immediately reencode the value (since Rails helpfully decoded the parameter for us).  When redirecting back to our client, we add the bounce path to the end of our client-side route.

We need to update our routes map client-side to prepare for this new parameter.

``` javascript(/client/src/reducers/store.js)
- import { createStore, combineReducers, applyMiddleware } from "redux";
- import { composeWithDevTools } from 'redux-devtools-extension';
- import createSagaMiddleware from 'redux-saga'
- import { connectRoutes } from 'redux-first-router';
- import restoreScroll from 'redux-first-router-restore-scroll'
- import createHistory from 'history/createBrowserHistory';

- import * as ROUTES from '../constants/settings';
- import chapters from './chapters';
- import nodes from './nodes';
- import settings from './settings';
- import alerts from './alerts';
- import user from './user';
- import bookmarks from './bookmarks';
- import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
+   [ROUTES.AUTH_ROUTE]: "/auth/:token/:bounce_path",
  [ROUTES.ERROR_ROUTE]: "/error"
};

- const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = - connectRoutes(
-   history,
-   routeMap,
-   { restoreScroll: restoreScroll(), initialDispatch: false }
- );

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

- const store = createStore(
-   reducers, composeWithDevTools(routerEnhancer, middlewares)
- );

sagaMiddleware.run(rootSaga);
initialDispatch();

export default store;
```

Finally, update the `hydrateUser` saga to utilize this redirect value.  I am externalizing this part of our saga as a function as we did with `axiosCreateClient`.  This approach makes `hydrateUser` more readable and simplifies testing by allowing us to test this redirect functionality in isolation.

``` javascript(/client/src/sagas/utils/redirect_path.js)
import { put } from 'redux-saga/effects';

export default function redirectToPathIf(path){
  if(path){
    let rd = decodeURIComponent(path);
    rd = JSON.parse(rd);
    return put(rd);
  }
}
```

This utility is simple; if passed a location object it redirects the user to that location. Otherwise, control just passes over the function silently.

Now update `hydrateUser` to use this utility function instead of our generic redirect to the homepage.

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call, all } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
-   try{
-     let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
-     yield all([
-       put(setUser(user.data)),
-       put(addAlert("Sign in successful, welcome " + user.data.username + ".","success"))
-     ]);
    
-     yield call(delay,3000);
-     yield put(clearAlerts());
-   } catch(e){
-     // We need some error handling
-   }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

## Persisting State Through Sessions

There's another issue I want to revisit before closing out our bookmarking functionality.  We have no persistence lasting beyond our browser window's closing.  Every time a user returns we must completely rebuild our store, and that minimizes the value of our login system.

We are going to add a library `redux-persist` to restore sections of our store state from local storage on user's return visits.  Start by installing the npm package.

```
docker-compose exec client yarn add redux-persist
```

Then update our store to persist areas of our state we want to preserve.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import createSagaMiddleware from 'redux-saga';
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll';
import createHistory from 'history/createBrowserHistory';
+ import { persistStore, persistReducer } from 'redux-persist';
+ import storage from 'redux-persist/lib/storage';


import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';
import alerts from './alerts';
import user from './user';
import bookmarks from './bookmarks';
import rootSaga from '../sagas/root';

const history = createHistory();

const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
  [ROUTES.AUTH_ROUTE]: "/auth/:token/:bounce_path",
  [ROUTES.ERROR_ROUTE]: "/error"
};

const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = connectRoutes(
  history,
  routeMap,
  { restoreScroll: restoreScroll(), initialDispatch: false }
);

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

+ //Persist setup
+ const persistConfig = {
+   key: 'root',
+   storage: storage,
+   whitelist: ['user'] // only this store attribute is persisted
+ };
+ const persistedReducer = persistReducer(persistConfig, reducers);

const base_store = createStore(
  persistedReducer, composeWithDevTools(routerEnhancer, middlewares)
);

sagaMiddleware.run(rootSaga);
initialDispatch();


+ export default () => {
+   let store = base_store;
+   let persistor = persistStore(store);
+   return { store, persistor };
+ };
```

Redux persist automatically dehydrates and rehydrates our store between a user's visits. Our config block tells `redux-persist` to manage only the user key of our store.  We also define our storage method as `storage` to use local storage for our data.  Other options available for storage include session and cookie-based storage.

Lastly, we modified our default export for this module to return both our store and a persistor.  The persistor alerts our React application when rehydration of our state is complete during our application's boot process.

To make use of these changes, let's turn to our index.js file.

``` javascript(/client/src/index.js)
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
+ import { PersistGate } from 'redux-persist/lib/integration/react';

+ import buildStore from './reducers/store';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

+ let { store, persistor } = buildStore();
window.store = store;

ReactDOM.render(
  <Provider store={store}>
    <PersistGate loading={null} persistor={persistor}>
      <App />
    </PersistGate>
  </Provider>
  ,document.getElementById('root')
);
    
registerServiceWorker();
```

We have updated our store import to capture both the `store` and `persistor` values from our store config.  

The `persistor` is used inside a component provided by `redux-persist` known as `PersistGate`.  `PersistGate` delays the initial rendering of our application until rehydration of our store completes.  Return to your application and log in.  Now trigger a refresh of the page, or close your browser and reopen the site.  You should see the user session preserved on your return visit.

## Session Rehydration Revisited.

Now that we have persistence between browser sessions, we are ready to finish our bookmarking implementation.

We can begin by defining another controller action for the process.

``` javascript(/api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
  before_action :authenticate_request!, only: [:index, :create]
  
+   def index
+     if(bm = @current_user.bookmark)
+       render json: bm.fsa, status: 200
+     else
+       raise ActiveRecord::RecordNotFound
+     end
+   end
  
  def create
    ch_id = params[:chapter_id]
    
    bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
    bookmark.update(last_read: ch_id, furthest_read: ch_id)
    render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
  end
end
```

Since this action sits behind our `before_action` filter which authenticates our user, we can safely assume that the `@current_user` available in our action.  All we need to do is retrieve the user's bookmark and send it as a JSON response.  If the user does not have a bookmark available, we raise an `ActiveRecord::RecordNotFound` error instead.

Next, update our `hydrateUser` saga.

``` javascript(/client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
+     yield call(retrieveUserBookmark);
  } catch(e){
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

We are saying goodbye to our old alerting process that lived inside this saga.  With the new bookmark modal appearing after sign-in, an additional popup message seems superfluous.  Instead, we can yield to another generator utility function to handle our bookmark restoration.  Let's go ahead and create that generator function now.

``` javascript(/client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    let response = yield call(auth_client.get, "/api/bookmarks");
    let lr = response.data.last_read || 0;
    let fr = response.data.furthest_read || 0;
    
    yield put(setBookmarkLocations(fr));
    yield put(setBookmarkLocations(lr));
    
    yield put(setBookmarkOffered(false));
    
    return true;
  } else { return false; }
}
```

Our new generator first creates an authorized Axios client for our request.  The generator stops executing for unauthenticated users.  For authenticated users, we request their latest bookmarks from the API, and with the response, call our `setBookmarkLocations` action twice.  First, to set the furthest read location.  Then again, to set the last read location.  Finally, we set `prompt_shown` to `false` allowing our modal to appear onscreen. 

Revisit your application and try it out.  You may need to sign in and out after doing a bit of "reading" if your user account doesn't have bookmarks set.  Once you revisit and sign in, you should see a prompt like the one below.

![Final presentation of bookmark modal](/images/12/bookmarkModalPrompt2.png)

## Rounding Out Our Tests

We have some tests that need updating before we close out this chapter.  There's no new ground covered here, so we are not reviewing these changes in detail.  However, if you would like to include the updates in your local project, the examples are included below.

Notice we test our saga utilities the same way we test our sagas themselves.  Externalizing units on work like this makes it far easier to handle our tests.

``` javascript(/client/src/App.test.js)
import React from 'react';
import {Provider} from 'react-redux';
import ReactDOM from 'react-dom';
+ import buildStore from './reducers/store';
import App from './App';

+ let { store } = buildStore();

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<Provider store={store}><App /></Provider>, div);
});
```

``` javascript(/client/src/sagas/utils/redirect_path.spec.js)
/* global expect */
import redirectToPathIf from './redirect_path';
import { put } from 'redux-saga/effects';

describe("redirectToPathIf", () => {
  test("returns path action", ()=> {
    let sample = {type: "ROUTE_ACTION", payload: {test: "value"}};
    let encoded_sample = encodeURIComponent(JSON.stringify(sample));
    expect(redirectToPathIf(encoded_sample)).toEqual(put(sample));
  });
});
```

``` javascript(/client/src/sagas/utils/axios_client.spec.js)
/* global expect */
import axiosCreateClient from './axios_client';

describe("axiosCreateClient, authrequired == true", () => {
  var saga;
  beforeEach(()=>{
    saga = axiosCreateClient();
    saga.next();
  });
  
  test("provides client if token is available", ()=> {
    let results = saga.next("token");
    expect(typeof results.value).toEqual("function");
  });
  
  test("returns null if no token and auth required", ()=> {
    let results = saga.next(undefined);
    expect(results.value).toEqual(null);
  });
});

describe("axiosCreateClient, authrequired == false", () => {
  test("return unauthenticated client", ()=> {
    let saga = axiosCreateClient(false);
    saga.next();
    let results = saga.next(undefined);
    expect(typeof results.value).toEqual("function");
  });
});
```

``` javascript(/client/src/sagas/utils/retrieve_bookmark.spec.js)
/* global expect */
import retrieveUserBookmark from './retrieve_bookmark';
import axios from 'axios';
import { put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';

describe("retrieveUserBookmark", () => {
  var saga;
  beforeEach(()=>{
    saga = retrieveUserBookmark();
    saga.next();
  });
  
  test("terminates if unatuhenticated", ()=> {
    let result = saga.next(null);
    expect(result.done).toEqual(true);
    expect(result.value).toEqual(false);
  });
  
  test("updates bookmarks if client secure client available and offers prompt", ()=> {
    expect(saga.next(axios.create())["value"]["CALL"]["args"]).toEqual(["/api/bookmarks"]);
    
    // expects client to return bookmark data and put setBookmarkLocations(furthest_read)
    let results = saga.next({data: {last_read: 1, furthest_read: 2}});
    expect(results.value).toEqual(put(setBookmarkLocations(2)));
    
    //put setBookmarkLocations(last_read)
    results = saga.next();
    expect(results.value).toEqual(put(setBookmarkLocations(1)));
    
    // put setBookmarkOffered(false)
    results = saga.next();
    expect(results.value).toEqual(put(setBookmarkOffered(false)));
    
    expect(saga.next().done).toEqual(true);
  });
});
```

``` javascript(/client/src/sagas/hydrate_user.spec.js)
/* global expect */
import { call, put } from 'redux-saga/effects';
import axios from 'axios';

import { hydrateUser } from './hydrate_user';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import retrieveUserBookmark from './utils/retrieve_bookmark';

describe("hydrateUser", () => {
  let path = encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
  test("saga then trades temp token for long-term",() => {
    expect(saga.next().value).toEqual(call(axios.get, "/api/hydrate_user?token=" + action.payload.token));
  });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});
```

We should also test `BookmarkController` and its `#create` and `#index` actions.  This spec introduces a new requirement to our test suite; a need to make authenticated requests.  We can set this up in a reusable module, that way it is readily available for future tests.

First, create a helper.

``` ruby(/api/spec/helpers.rb)
module Helpers
  def request_as(user)
    return {"Authorization" => TokenOps.encode_long(user) }
  end
end
```

Then alter `spec_helper.rb` to include these helper methods automatically in our tests. 

``` ruby(/api/spec/spec_helper.rb)
+ require 'helpers.rb'
RSpec.configure do |config|
+   config.include Helpers
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
end
```

Now when making an authenticated request, we create the user we want to use for our test.  Then we merge the header information generated by our `request_as` helper method with the generic headers RSpec provides.  From there testing can proceed normally.

``` ruby(/api/spec/controllers/api/bookmarks_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::BookmarksController, type: :controller do
+   before(:each) do
+     @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
+     @user.bookmark = Bookmark.create(last_read: 1, furthest_read: 1)
+     request.headers.merge! request_as(@user)
+   end
  
  describe "post #create" do
    it "returns http success and sets new bookmarks" do
      post :create, params: {chapter_id: 2}
      expect(response).to have_http_status(:success)
      @user.reload
      expect(@user.bookmark.last_read).to eq 2
      expect(@user.bookmark.furthest_read).to eq 2
    end
  end
  
  describe "GET #idex" do
    it "returns a user's bookmarks" do
      get :index
      expect(response).to have_http_status(:success)
      expect(response.body).to eq "{\"user_id\":1,\"last_read\":1,\"furthest_read\":1}"
    end
  end
end 
```

## Wrapping Up

We have created our first authenticated actions.  It took two chapters to build an authentication system and make our first requests for protected resources.  

In doing so, we have significantly increased the complexity of our actions and introduced several new ways our application could fall off the Rails (nudge nudge).  In our next chapter, we introduce a more comprehensive system for handling minor and disastrous errors, creating systems to help our application recover when something goes wrong.
