# Chapter 12: Managing Authenticated Requests

In chapter 10 we laid the groundwork for our authentication system, setting up an OAuth pattern with GitHub, and using an internal token to track user identity.  Now that we have this foundation in place we can begin making authenticated requests for our users.  In this chapter, we build our first authenticated action; implementing some progress tracking that offers to restore the user to their last-read and furthest read locations on return visits.  

We will also flesh out our authentication setup by adding some pages to our application for recovery from catastrophic errors.  Also, we will introduce some persistent state client-side to retain our user tokens across multiple visits.

## Setting up Our State and UI

To tackle this iteration, we are going to need some modifications to our state tree and components.  To focus on the authentication modifications we are making in this chapter, I have chosen to include the majority of our UI/client setup at the start of the chapter.

I am going to set up a new reducer `bookmarks` to store three kays; a last-read position in our book, the furthest-read position, and a boolean flag to track whether we have already shown a prompt offering to return to one of these bookmarks.

We are also introducing and modifying some components to create an error page.  Since previous chapters covered these topics in detail, I am not going to dwell on them much here.  However, if you are following along, you can copy the following files into your local project.

**Note:** Given a large number of changes required to prepare for this chapter I have included the following changes in the  [Chapter11Starter](https://github.com/swachtma/reactivating-rails-app/tree/Chapter11Starter) for you already.  Alternatively, you can copy and paste from the examples below.

``` javascript(/reactive-client/src/constants/bookmarks.js)
export const SET_BOOKMARK_LOCATIONS = "SET_BOOKMARK_LOCATIONS";
export const SET_BOOKMARK_OFFERED = "SET_BOOKMARK_OFFERED";
```

``` javascript(/reactive-client/src/actions/bookmarks.js)
import * as constants from "../constants/bookmarks";

export const setBookmarkLocations = (chapter_id) => ({
  type: constants.SET_BOOKMARK_LOCATIONS, payload: {chapter: chapter_id}
});

export const setBookmarkOffered = (bool) => ({
  type: constants.SET_BOOKMARK_OFFERED, payload: {prompt_shown: bool}
});
```

``` javascript(/reactive-client/src/actions/bookmarks.spec.js)
/* global expect */
import * as actions from './bookmarks';

describe("Bookmarks actionCreators", ()=>{
  describe("setBookmarkLocations(chapter_id)", ()=>{
    test("matches snapshot", () =>{
      expect(actions.setBookmarkLocations(1)).toMatchSnapshot();
    });
  });
  
  describe("setBookmarkOffered(true)",()=>{
    test("matches snapshot", () =>{
      expect(actions.setBookmarkOffered(true)).toMatchSnapshot();
    });
  });
});
```

``` javascript(/reactive-client/src/reducers/bookmarks.js)
import * as constants from '../constants/bookmarks';

const default_state = {
  prompt_shown: false,
  last_read: {chapter: 1},
  furthest_read: {chapter: 1}
};

export const buildLocations = (state, new_loc) => {
  let position = state.furthest_read.chapter < new_loc.chapter ? new_loc : state.furthest_read;
  return Object.assign({}, state, {last_read: new_loc, furthest_read: position});
};

const bookmarksReducer = function(state = default_state, action){
  switch (action.type) {
    case(constants.SET_BOOKMARK_LOCATIONS):
      return buildLocations(state,action.payload);
    case(constants.SET_BOOKMARK_OFFERED):
      return Object.assign({}, state, {prompt_shown: action.payload.prompt_shown});
    default:
      return state;
  }
};

export default bookmarksReducer;
```

``` javascript(/reactive-client/src/reducers/bookmarks.spec.js)
/* global expect */
import  bookmarksReducer, { buildLocations } from './bookmarks';
import * as actions from '../actions/bookmarks';

let defaultState = { prompt_shown: false, last_read: {chapter: 1}, furthest_read: {chapter: 1} };

describe("bookmarks Reducer", ()=>{
  describe("buildLocations",()=>{
    test("updates furthest_read only on progress",()=>{
      let bookmarks = buildLocations(defaultState,{chapter: 2});
      expect(bookmarks.furthest_read.chapter).toEqual(2);
      
      bookmarks = buildLocations(bookmarks,{chapter: 1});
      expect(bookmarks.furthest_read.chapter).toEqual(2);
    });
    
    test("always updates last_read",()=>{
      let bookmarks = buildLocations(defaultState,{chapter: 2});
      expect(bookmarks.last_read.chapter).toEqual(2);
      
      bookmarks = buildLocations(bookmarks,{chapter: 1});
      expect(bookmarks.last_read.chapter).toEqual(1);
    });
  });
  
  describe("bookmarksReducer",()=>{
    test("sets prompt_shown true on setBookmarkOffered(true) action",()=>{
      let state = bookmarksReducer(defaultState,actions.setBookmarkOffered(true));
      expect(state.prompt_shown).toEqual(true);
    });
    
    test("sets both bookmarks on setBookmarkLocations",()=>{
      let state = bookmarksReducer(defaultState,actions.setBookmarkLocations(2));
      expect(state.last_read.chapter).toEqual(2);
      expect(state.furthest_read.chapter).toEqual(2);
    });
  });
});
```

The primary function of this reducer is simple.  We are tracking two locations; a `last_read` position that updates every time a user views a new chapter, as well as a `furthest_read` position that updates only when the dispatched location is a deeper progression in the book.  Both of these bookmarks listen for opportunities to show a prompt based on the boolean flag stored in `bookmarks.prompt_shown` and offer a modal dialogue allowing our user to jump to either bookmark location when they resume reading.  Both bookmark locations update by dispatching a single `SET_BOOKMARK_LOCATIONS` action.

**Reminder: be sure to also add this new reducer to your root reducer (not shown in examples above).**

Before we move into actually dispatching actions, or working with our server, let us build the UI control that handles this process.  I am going to build a modal dialogue that appears center-screen when the user enters a chapter view/route with their `bookmarks.prompt_shown` state set to `false`.  Create the following new components and containers to support this.

``` javascript(/reactive-client/src/components/bookmark_modal.js)
import React, { Component } from 'react';
import { Button, Header, Icon, Modal } from 'semantic-ui-react';

class BookmarkModal extends Component {
  handleClose = () => this.props.dispatchSetBookmarkOffered(true);
  
  handleLastReadClick = () => {
    this.handleClose();
    this.props.dispatchRoutechapter(this.props.last_read.chapter);
  }
  
  handleFurthestReadClick = () => {
    this.handleClose();
    this.props.dispatchRoutechapter(this.props.furthest_read.chapter);
  }
  
  printLastReadButtonIf = (truthy) => {
    if(truthy){
      return (
        <Button color='yellow' onClick={this.handleLastReadClick} inverted>
          <Icon name='checkmark' /> Last read (Ch:{this.props.last_read.chapter})
        </Button>
      );
    }
  }
  
  render(){
    let last_read = this.props.last_read.chapter;
    let furthest_read = this.props.furthest_read.chapter;
    
    return(
      <Modal open={this.props.displayState} onClose={this.handleClose} basic size='small'>
        <Header icon='archive' content='Pick up where you left off' />
        <Modal.Content>
          <p>We've saved some bookmarks on your behalf.  Would you like to resume reading at one of these locations?</p>
        </Modal.Content>
        <Modal.Actions style={{textAlign: "center"}}>
          <Button basic color='red' onClick={this.handleClose} inverted>
            <Icon name='remove' /> No, stay here
          </Button>
          { this.printLastReadButtonIf(last_read !== furthest_read) }
          <Button color='green' onClick={this.handleFurthestReadClick} inverted>
            <Icon name='checkmark' /> Furthest read (Ch:{furthest_read})
          </Button>
        </Modal.Actions>
      </Modal>
    );
  }
}

export default BookmarkModal;
```

``` javascript(/reactive-client/src/containers/bookmarks_provider.js)
import { connect } from 'react-redux';

import BookmarkModal from '../components/bookmark_modal'
import { setBookmarkOffered } from '../actions/bookmarks';
import { routeChapter } from '../actions/routes';

export const calculateDisplayState = (state) => {
  let bm = state.bookmarks;
  let loc = state.location.payload.chapter_id;
  if(bm.prompt_shown || (loc === bm.last_read.chapter && loc === bm.furthest_read.chapter)){
    return false;
  } else {
    return true;
  }
};

const bookmarksProvider = (WrappedComponent = BookmarkModal) => {
  let mapStateToProps = (state) => ({
    displayState: calculateDisplayState(state),
    last_read: state.bookmarks.last_read,
    furthest_read: state.bookmarks.furthest_read
  });
  
  let mapDispatchToProps = (dispatch) => ({
    dispatchSetBookmarkOffered: (bool) => dispatch(setBookmarkOffered(bool)),
    dispatchRoutechapter: (chapter_id) => dispatch(routeChapter(chapter_id))
  });
  
  return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
};

export const ConnectedBookmarkModal = bookmarksProvider();
export default bookmarksProvider;
```

Now I want to prepare a client-side error page to serve as a redirect route when our server encounters a critical error.  Create or update the following files to prepare for this as well.

``` javascript(/reactive-client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
export const AUTH_ROUTE = "AUTH_ROUTE";
export const ERROR_ROUTE = "ERROR_ROUTE";
```

``` javascript(/reactive-client/src/actions/routes.js)
import * as routes from '../constants/settings';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);

export const routeError = () => ({type: routes.ERROR_ROUTE});
```

``` javascript(/reactive-client/src/reducers/store.js)
- import { createStore, combineReducers, applyMiddleware } from "redux";
- import { composeWithDevTools } from 'redux-devtools-extension';
- import createSagaMiddleware from 'redux-saga'
- import { connectRoutes } from 'redux-first-router';
- import restoreScroll from 'redux-first-router-restore-scroll'
- import createHistory from 'history/createBrowserHistory';
- 
- import * as ROUTES from '../constants/settings';
- import chapters from './chapters';
- import nodes from './nodes';
- import settings from './settings';
- import alerts from './alerts';
- import user from './user';
- import bookmarks from './bookmarks';
- import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
  [ROUTES.AUTH_ROUTE]: "/auth/:token",
+   [ROUTES.ERROR_ROUTE]: "/error"
};

const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = - - connectRoutes(
-   history,
-   routeMap,
-   { restoreScroll: restoreScroll(), initialDispatch: false }
- );

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

- const store = createStore(
-   reducers, composeWithDevTools(routerEnhancer, middlewares)
- );

sagaMiddleware.run(rootSaga);
initialDispatch();

export default store;
```

``` javascript(/reactive-client/src/components/error_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import Link from 'redux-first-router-link';
import { routeHome } from '../actions/routes'; 

class ErrorPane extends Component {
  render() {
    return (
      <div id="error-pane">
        <Container text>
          <h1>Well Shucks...</h1>
          <p>This page is where we, unfortunately, have to make up some cutesy reason to apologize for our site not working at the moment. Perhaps the legion of radioactive cyborg battle-hamsters we were breeding have escaped confinement?</p>
          
          <p>In any case, we do not seem able to do the things at the moment.</p>
          
          <p>How about you <Link to={ routeHome() }>head to the homepage</Link> and give it another go? Try not to break anything this time.</p>
        </Container>
      </div>
    );
  }
}

export default ErrorPane;
```

``` javascript(/reactive-client/src/containers/route_provider.js)
import { connect } from 'react-redux';
import RouterSwitch from '../components/router_switch';

const routerProvider = (WrappedComponent = RouterSwitch) => {
  let mapStateToProps = (state) => ({
    location: state.location
  });
  
  return connect(mapStateToProps,null)(WrappedComponent);
};

export default routerProvider;
```

``` javascript(/reactive-client/src/components/router_switch.js)
import React, { Component } from 'react';
import ReaderPane from './reader_pane';
import ErrorPane from './error_pane';
import * as routes from '../constants/settings';

class RouterSwitch extends Component {
  render() {
    switch(this.props.location.type){
      case(routes.ERROR_ROUTE):
        return(<ErrorPane />);
      case(routes.CHAPTER_ROUTE):
        return(<ReaderPane />);
      case(routes.HOME_ROUTE):
        return(<ReaderPane />);
      default:
        return(<ErrorPane />);
    }
  }
}

export default RouterSwitch;
```

The last piece of UI prep we need to take care of is updating our `ReaderPane` and `App` components to use the newly created `ErrorPane` and `RouterSwitch` components.  We are also making a small adjustment to our stylesheet.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import './App.css'

import routerProvider from './containers/route_provider';
import connectToAlerts from './containers/alert_provider';
import MenuBar from './components/menu_bar';
const ConnectedRouterSwitch = routerProvider();
const ApplicationAlerts = connectToAlerts();


class App extends Component {
  render() {
    return (
      <div id="app">
        <MenuBar />
+         <Container text id="main-section">
+           <ApplicationAlerts />
+           <ConnectedRouterSwitch />
+         </Container>
      </div>
    );
  }
}

export default App;
```

``` javascript(/reactive-client/src/components/reader_pane.js)
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';
import FilteredNodesList from '../containers/filtered_nodes_list';
import { ConnectedChapterFooterLink } from '../containers/chapter_provider';
import { ConnectedBookmarkModal } from '../containers/bookmarks_provider';

const reader_pane_styles= {
  paddingBottom: "15px"
};

class ReaderPane extends Component {
  render() {
    return (
      <div id="reader-pane" style={ reader_pane_styles }>
        <ConnectedBookmarkModal />
+         <Container text>
+           <FilteredNodesList />
+         <ConnectedChapterFooterLink />
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

``` css(/reactive-client/src/App.css)
img {max-width: 100%;}

.ui.menu .item {padding: 0 1em;}

+ #main-section {margin-top: 85px;}
#reader-pane img {border: 1px solid #021a40;}

code {
  background-color: rgba(27,31,35,0.05);
  border-radius: 3px;
  padding: 0.2em .5em;
  margin: 0;
  font-size: 85%;
}

.codeBody .fa { border-bottom: 1px dotted; margin: 0 .5em; }
.codeGutter .fa { font-size: 12px; opacity: 0; }
.lowPrioritySection .fa { opacity: 100; }
.lowPrioritySection { cursor: pointer; } 
.highPrioritySection, .highPrioritySection code { background-color: rgba(255,255,217,0.75) }
pre {white-space: pre-wrap; margin: 0;}
#root .hljs {padding: 0;}

@media only screen and (max-width: 990px) {
  #app .banner {
    margin-left: -10px;
  }
}

@media only screen and (max-width: 767px) {
 #app #reader-pane {
   margin-top: 125px;
 }
}
```

If you want to test that you have everything wired correctly before moving on,  you can change your default state in the `bookmarks` reducer to set `bookmarks.prompt_shown` to a default value of false.  You should see a prompt as soon as you visit a chapter route.

![Prompt Offering Option to Jump Immediately to a Bookmark](/images/12/BookmarkModalPrompt.png)

## Sending Authentication Headers

Now that we have a token in our store for our authenticated users, we need to set up a process for users to make authenticated requests.  To do this, we can send our JWT token as an authorization header.  We setup methods in our `ApplicationController` to validate these tokens, and limit access to API endpoints that require authentication.

Let's begin by setting up the client side of our request. So far we have been using Axios in a one-off manner when we need to send requests to our API.  However, now that we need a more complex configuration, I think now is the time we formalized this.

Set up a new folder inside of `src/sagas` named `utils`.  We are going to use this folder to store generators used by our sagas that are not themselves directly connected to a watcher.

``` javascript(/reactive-client/src/sagas/utils/axios_client.js)
import axios from 'axios';
import {  select } from 'redux-saga/effects';

export default function* axiosCreateClient(req_auth = true){
  let token = yield select((s) => s.user.token);
  let client = axios.create();
  
  if(token){
    client.defaults.headers.common['Authorization'] = token;
    return client;
  } else {
    return req_auth ? null : client;
  }
}
```

Our `axiosCreateClient` generator function sets up an Axios client which submits all its request with an authorization header containing our JWT token for the user.  We are configuring this function so that it defaults to requiring authorization for the user.  This approach allows us to use the returned Axios client to short-circuit requests that require user authentication if the user has not yet signed-in.  Our generator function returns `null` if a JWT token is unavailable for the user.  If we want a client that does allow non-authenticated requests we can override the function's default parameters.

Now let's set up a stub of a saga that leverages this new Axios configuration.

``` javascript(/reactive-client/src/sagas/set_bookmarks.js)
import { takeEvery, call } from 'redux-saga/effects';
+ import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';

export function* setBookmarks(){
+  const auth_client = yield axiosCreateClient();

+  if(auth_client){
    try{
      let response = yield call(auth_client.post,'/api/bookmarks');
      console.log(response);
    } catch(e){
      console.log(e);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

Notice how we yield to the `axiosCreateClient` function.  This pattern is one of the more useful provided by Redux Saga.  Our generator functions can themselves invoke further generators, allowing us to get quite detailed in the order of operations our sagas use to manage the various application processes.  

When `axiosCreateClient` returns, it will either provide `null` or if the user is signed in, a configured client.  If we receive a `null` client, our saga terminates there.  However, if we get a client back, we use it to make a POST request to an `api/bookmarks` route.  For now, we are just going to send any responses or errors from this API call to our console log.

Now we can go ahead and set up the API side of this route.  Run the following generator function to create a new resource `bookmarks`, and be sure to run your database migrations before continuing.

``` bash
bin/rails generate resource Bookmark user_id:integer last_read:integer furthest_read:integer
```

We also need to create our Active Records associations for the `User` and `Bookmark` models.

``` ruby(/reactive-api/app/models/user.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

class User < ApplicationRecord
+   has_one :bookmark
  
-   def fsa(token)
-     {
-       id: id,
-       github_email: github_email,
-       username: username,
-       avatar: avatar,
-       token: token
-     }
-   end
  
-   def self.create_or_fetch(user)
-     find_by(github_id: user.id) || create(
-       github_id: user.id,
-       github_email: user.email,
-       username: user.login,
-       avatar: user.avatar_url
-     )
-   end
end
```

``` ruby(/reactive-api/app/models/bookmark.rb)
# == Schema Information
#
# Table name: bookmarks
#
#  id            :integer          not null, primary key
#  last_read     :integer
#  furthest_read :integer
#  created_at    :datetime         not null
#  updated_at    :datetime         not null
#  user_id       :integer
#

class Bookmark < ApplicationRecord
+   belongs_to :user

  def fsa
    {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
  end
end
```

We should also modify the generated routes so that they align with our existing `/api` nesting pattern.

``` ruby(/reactive-api/config/routes.rb)
Rails.application.routes.draw do
  namespace :api do
    get 'github/', to: "authentication#github", format: false
    get 'hydrate_user/', to: "authentication#show"
    get 'nodes/', to: "nodes#index"
    get 'chapters/', to: "chapters#index"
+     resources :bookmarks, only: [:index, :create]
  end
end
```

We are moving the new resource routes into the `:api` namespace, and limiting the routes created to only `create` and `index`.  We are using `index` instead of `show` since we are not leveraging a passed bookmark ID to fetch the resource we want.  Instead, we return all records for a given user.

Finally, let's make a few modification to our generated controller.  Be sure to nest this controller inside your `Api` module as shown below, and relocate the file itself to the `/api` directory.

``` ruby(/reactive-api/app/controllers/api/bookmarks_controller.rb)
+ class Api::BookmarksController < ApplicationController
  def index
    render json: {payload: "success"}, status: 200
  end
  
  def create
    render json: {payload: "success"}, status: 200
  end
end
```

Take a moment to check your work by opening your browser to a chapter route.  When you are not signed in, you should see no activity with our bookmarks controller.  However, log in and then revisit a chapter route (not the homepage), and you should see the console logged response from your controller.

![Console Response from Bookmark Controller Stub](/images/12/ConsoleBookmarkResponse.png)

## Checking Authorization Headers

With a very basic bookmark controller and saga in place, we can now turn our attention to building some protection around our authenticated actions.  Since we need the ability to limit controller access across many controllers/actions, it makes sense to configure this logic in our `ApplicationController`.

``` ruby(/reactive-api/app/controllers/application_controller.rb)
class ApplicationController < ActionController::API
  def authenticate_request!
      fail StandardError unless user_id_in_token?
      @current_user = User.find(@decoded_token["id"])
  end
  
  private
    # Decode the authorization header token and return the payload
    def user_id_in_token?
      auth_token && decoded_token && @decoded_token["id"]
    end
    
    def decoded_token
      @decoded_token ||= TokenOps.decode(auth_token)[0]
    end
  
    def auth_token
      @http_auth_token ||= request.headers['Authorization']
    end
end
```

The root of our authentication logic lives in the newly created `authenticate_request` method.  We have this method raising an error unless all the conditions inside `user_id_in_token` pass.  This function requires an incoming request provides a valid JWT token in its authorization header, and that the token when decoded contains a user id value.

If the request meets these conditions, our authentication logic creates an instance variable `@current_user` containing a record of the user.

Now we can upgrade our `BookmarkController` to leverage this authentication method.

``` ruby(/reactive-api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
+   before_action :authenticate_request!, only: [:index, :create]
  
  def index
  end
  
  def create
    ch_id = params[:chapter_id]
    
    bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
    bookmark.update(last_read: ch_id, furthest_read: ch_id)
    render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
  end
end
```

We have set up a `before_action` hook to call the `ApplicationController` authentication method as a prerequisite for both actions on this controller.  This filter ensures requests that make it this deep into our controller logic have a valid user available in `@current_user`.  

From there, our `create` action expects to receive a single parameter, the chapter id to be used for updating or creating our bookmarks.  We are using ActiveRecord's `find_or_initialize_by` to either retrieve an existing record or instantiate a new bookmark for us.  Then we can update the record with new chapter id values for both bookmark types.  Finally, we render some JSON containing a simple confirmation message of the update.

Before moving back to the client, we should brush up our model a bit.  The convention of the `furthest_read` bookmark not regressing to an earlier chapter is enforced in our client, but if we want to trust data retrieved from the API as ready to use, we should enforce the same convention.  Let's update our `Bookmark` model to reflect this.

``` ruby(/reactive-api/app/models/bookmark.rb)
- # == Schema Information
- #
- # Table name: bookmarks
- #
- #  id            :integer          not null, primary key
- #  last_read     :integer
- #  furthest_read :integer
- #  created_at    :datetime         not null
- #  updated_at    :datetime         not null
- #  user_id       :integer
- #

class Bookmark < ApplicationRecord
  belongs_to :user
+   before_save :ensure_furthest_location
  
  def fsa
    {user_id: user_id, last_read: last_read, furthest_read: furthest_read}
  end
  
+   def ensure_furthest_location
+     if(bm = Bookmark.where(user_id: self.user_id).first)
+       self.furthest_read = bm.furthest_read unless self.furthest_read > bm.furthest_read
+     end
+   end
end
```

Using an ActiveRecord `before_save` callback, we can run a new method `ensure_furthest_location` before a record is committed to our database.  The method locates the existing record in our database and checks whether the stored `furthest_read` value is greater than the new value.  If the database has a higher value, we override the save to persist the existing bookmark for furthest read location.

Now let's finish our our bookmark creation on the client side by returning to our saga.

``` javascript(/reactive-client/src/sagas/set_bookmarks.js)
import { takeEvery, call, put } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setBookmarkLocations } from '../actions/bookmarks';

export function* setBookmarks(action){
+   let ch_id = action.payload.chapter_id;
+   const auth_client = yield axiosCreateClient();
+   //Set bookmarks locally
+   yield put(setBookmarkLocations(ch_id));
  
  if(auth_client){
    try{
+       let response = yield call(auth_client.post,'/api/bookmarks',{chapter_id: ch_id});
+       console.log(response.data.message);
    } catch(e){
      console.log(e);
    }
  }
} 

export function* watchBookmarkChanges(){
  yield takeEvery(routes.CHAPTER_ROUTE, setBookmarks);
}
```

We begin by ensuring that our bookmarks are updated client-side in our store for all users each time a chapter route is triggered.  Then, users who have an authenticated session also execute the additional try block, sending a post request to `/api/bookmarks` to save the bookmarks to our database as well.

We do not want to print a UI alert to the user everytime this action happens in the background.  However, we can continue logging the response to the console for now.  Test this out before moving on.  Log into your application, and make a chapter request and you should see the response logged to your console.

![Console Confirmation of BookmarksController#create](/images/12/BookmarkCreateLog.png)

## Preserving Reader Position Through Log In

Before we move onto restoring bookmark locations we need to remove another wort from our initial authentication design.  Currently, when a user signs in, we are routing everyone to the homepage after returning from GitHub.  Ideally, we would drop them back where they were before leaving the site.  To do this, we can pass an alternative redirect URL through our initial GitHub request, which overrides the master value we set when configuring our OAuth application.

We can begin by setting up some new constants for our client to store the top-level domain information we need for our redirects.

``` javascript(/reactive-client/src/constants/settings.js)
+ export const BASE_AUTH_PATH = "http://138.197.14.5:3000/api/github/"

export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
export const AUTH_ROUTE = "AUTH_ROUTE";
export const ERROR_ROUTE = "ERROR_ROUTE";
```

Let's update our Github/Profile badge component.  We are going to need our `location` state available in the GitHub badge, so let's begin by breaking that out as a standalone component.  This change minimize the amount of our component tree that needs to render again on state changes to our routes.

``` javascript(/reactive-client/src/components/github_icon.js)
import React, { Component } from 'react';
import { Menu, Icon } from 'semantic-ui-react';
import { BASE_AUTH_PATH } from '../constants/settings';
+ import routeProvider from '../containers/route_provider';

class GithubIcon extends Component {
+   buildRedirect = (loc = this.props.location) => {
+     let bounce_path = JSON.stringify({type: loc.type, payload: loc.payload});
+     return encodeURIComponent(BASE_AUTH_PATH + "?bounce_path=" + bounce_path);
+   }
  
  render() {
    let rd = this.buildRedirect();
    return (
+       <Menu.Item href={"https://github.com/login/oauth/authorize?client_id=a86bc65853ae65d3be52&redirect_uri=" + rd} name='Sign in with GitHub'>
        <Icon name='github' style={{marginRight: 0}} size="big" />
      </Menu.Item>
    );
  }
}

+ const ConnectedGitHubIcon = routeProvider(GithubIcon);
+ export default ConnectedGitHubIcon;
```

We can reuse the `routeProvider` function we set up to drive our navigation dropdowns to power this badge link as well.  We can set up the module to export a version of our component that passed through this provider function.  To start our redirect, we are making use of a feature in the GitHub OAuth setup we ignored previously.  GitHub allows us to make our initial request with a specific `redirect_uri` parameter that overrides the global settings we configured with GitHub; so long as the URI in the passed parameter has the same domain and port as the value stored in our GitHub global settings.

We are going to use this `redirect_uri` value to contain a URL back to our application, and that redirect URI will itself contain **another** redirect URI named `bounce_path`.  Our API can then catch this parameter, and pass it onto our client authorization route once we have set up the user's JWT token.  We are using `encodeURIComponent` to make all our values URL safe for this process.

Now update your `UserBadge` component to make use of this new component.

``` javascript(/reactive-client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

+ import ConnectedGitHubIcon from './github_icon';

class UserBadge extends Component {
  render() {
    if(!this.props.username){
      return (
+         <ConnectedGitHubIcon />
      );
    } else {
      let badge = <Image src={this.props.avatar} avatar />;
      return (
        <Menu.Item name={this.props.username}>
          <Dropdown icon={badge} compact pointing="top right">
            <Dropdown.Menu>
              <Dropdown.Item onClick={this.props.dispatchClearUser}>Sign Out</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </Menu.Item>
      );
    }
  }
}

export default UserBadge;
```

When users return to our API after authorizing Github, they now have an extra GET parameter available `bounce_path`.  Let's update our controller action to handle this value.

``` ruby(/reactive-api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    code = params[:code]
+     bounce_path = ERB::Util.url_encode(params[:bounce_path])
    github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
    token = github.get_token(code).token
    
    github_users = Github::Client::Users.new oauth_token: token
    user = User.create_or_fetch(github_users.get)
    jwt = TokenOps.encode_short(user)
    
+     redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
  end
  
-   def show
-     token = params[:token]
-     user_id = TokenOps.decode(token)[0]["id"]
-     user = User.find(user_id)
-     long_token = TokenOps.encode_long(user)
-     
-     render json: user.fsa(long_token), status: 200
-   end
end
```

We can now fetch the new value from the URL, where we will then immediately reencode the value (since Rails helpfully decoded the parameter for us).  Now when we redirect back to the client, we can add the bounce path to the end of our client route.

We need to update our routes map client-side to prepare for this new parameter as well. Otherwise, we would display our error page if the route was undefined.

``` javascript(/reactive-client/src/reducers/store.js)
- import { createStore, combineReducers, applyMiddleware } from "redux";
- import { composeWithDevTools } from 'redux-devtools-extension';
- import createSagaMiddleware from 'redux-saga'
- import { connectRoutes } from 'redux-first-router';
- import restoreScroll from 'redux-first-router-restore-scroll'
- import createHistory from 'history/createBrowserHistory';

- import * as ROUTES from '../constants/settings';
- import chapters from './chapters';
- import nodes from './nodes';
- import settings from './settings';
- import alerts from './alerts';
- import user from './user';
- import bookmarks from './bookmarks';
- import rootSaga from '../sagas/root';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
+   [ROUTES.AUTH_ROUTE]: "/auth/:token/:bounce_path",
  [ROUTES.ERROR_ROUTE]: "/error"
};

- const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = - connectRoutes(
-   history,
-   routeMap,
-   { restoreScroll: restoreScroll(), initialDispatch: false }
- );

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

- const store = createStore(
-   reducers, composeWithDevTools(routerEnhancer, middlewares)
- );

sagaMiddleware.run(rootSaga);
initialDispatch();

export default store;
```

Finally, we can update our `hydrateUser` saga to make use of this redirect value.  I am going to externalize this part of our saga as its own function, just like we did with `axiosCreateClient`.  This approach makes our main `hydrateUser` saga more readable and also simplifies our testing by allowing us to test just this redirect functionality in isolation.

``` javascript(/reactive-client/src/sagas/utils/redirect_path.js)
import { put } from 'redux-saga/effects';

export default function redirectToPathIf(path){
  if(path){
    let rd = decodeURIComponent(path);
    rd = JSON.parse(rd);
    return put(rd);
  }
}
```

This utility is simple; if passed a path object it redirects the user to the appropriate location. Otherwise, control just passes over the function silently.

Now we can update `hydrateUser` to leverage this utility function instead of our generic redirect to the homepage.

``` javascript(/reactive-client/src/sagas/hydrate_user.js)
import { takeLatest, put, call, all } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
-   try{
-     let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
-     yield all([
-       put(setUser(user.data)),
-       put(addAlert("Sign in successful, welcome " + user.data.username + ".","success"))
-     ]);
    
-     yield call(delay,3000);
-     yield put(clearAlerts());
-   } catch(e){
-     // We need some error handling
-   }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

## Persisting State Through Sessions

There's yet another issue I would like to clean up before we close out our bookmarking functionality.  As of now, we do not have any persistence that lasts beyond our browser window closing.  That means everytime a user returns we are going through the steps of completely rebuilding our store.  That severely minimizes the value of our login system.

We are going to add a library `redux-persist` to help us restore areas of our store from a local storage method when a user makes repeat visits.  For the moment, I will only be saving the `user`, but in the long term, we can leverage this functionality to store other content as well.

Start by installing the npm package.

```
npm install --save redux-persist
```

Then we need to set up our store to persist the areas of our state we want to preserve.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import createSagaMiddleware from 'redux-saga';
import { connectRoutes } from 'redux-first-router';
import restoreScroll from 'redux-first-router-restore-scroll';
import createHistory from 'history/createBrowserHistory';
+ import { persistStore, persistReducer } from 'redux-persist';
+ import storage from 'redux-persist/lib/storage';


import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';
import alerts from './alerts';
import user from './user';
import bookmarks from './bookmarks';
import rootSaga from '../sagas/root';

const history = createHistory();

const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  [ROUTES.HOME_ROUTE]: "/",
  [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id",
  [ROUTES.AUTH_ROUTE]: "/auth/:token/:bounce_path",
  [ROUTES.ERROR_ROUTE]: "/error"
};

const { reducer: routeReducer, middleware: routerMiddleware, enhancer: routerEnhancer, initialDispatch } = connectRoutes(
  history,
  routeMap,
  { restoreScroll: restoreScroll(), initialDispatch: false }
);

const reducers = combineReducers({location: routeReducer, user, settings, bookmarks, alerts, nodes, chapters});

const sagaMiddleware = createSagaMiddleware();

const middlewares = applyMiddleware(sagaMiddleware, routerMiddleware);

+ //Persist setup
+ const persistConfig = {
+   key: 'root',
+   storage: storage,
+   whitelist: ['user'] // only navigation will be persisted
+ };
+ const persistedReducer = persistReducer(persistConfig, reducers);

const base_store = createStore(
  persistedReducer, composeWithDevTools(routerEnhancer, middlewares)
);

sagaMiddleware.run(rootSaga);
initialDispatch();


+ export default () => {
+   let store = base_store;
+   let persistor = persistStore(store);
+   return { store, persistor };
+ };
```

Redux persist allows us to automatically dehydrate and rehydrate our store to a form of client-side storage between a user's visits to our site.  The options to configure redux-persist are very flexible, and in more advanced settings one of its strengths comes from its ability to reconcile the rehydrated state of previous sessions with the default settings for our store, defined in our reducers.  This flexibility allows you to be very detailed in how different scenarios proceed during rehydration.

Since the `user` branch of our store does not supply default values, we are setting up `redux-persist` to completely overwrite our store with the rehydrated state, if one is available.

After importing the library, we set up a config block that tells `redux-persist` to whitelist only the user key for rehydration.  We also define our storage method as `storage` to use local storage for our data.  Other options available for storage include session and cookie-based storage.

Lastly, we have made some modification to our default export for this module so that we return both our store, and a persistor, which is used to alert our React application when our rehydration of state is complete during our application's boot process.

To make use of these changes, let's turn to our index.js file.

``` javascript(/reactive-client/src/index.js)
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
+ import { PersistGate } from 'redux-persist/lib/integration/react';

+ import buildStore from './reducers/store';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

+ let { store, persistor } = buildStore();
window.store = store;

ReactDOM.render(
  <Provider store={store}>
    <PersistGate loading={null} persistor={persistor}>
      <App />
    </PersistGate>
  </Provider>
  ,document.getElementById('root')
);
    
registerServiceWorker();
```

We have updated our store import to capture both the `store` and `persistor` values from our store config.  The `persistor` is used inside a component provided by `redux-persist` known as `PersistGate`.  The persist gate delays the initial rendering of our application until the rehydration of our store is complete.

With these changes in place, return to your application and log in.  Now trigger a refresh of the page, or close your browser and then reopen the site.  You should see the user session preserved on your return to the site.

## Session Rehydration Revisited.

Now that we have some persistence between browser sessions we are at last ready to close the loop on our bookmarking implementation.  We need to update our user hydration to fetch the latest bookmarks from our API, and flag the user's state to show they are eligible to receive this prompt.

We can begin by defining our controller action for the process.

``` javascript(/reactive-api/app/controllers/api/bookmarks_controller.rb)
class Api::BookmarksController < ApplicationController
  before_action :authenticate_request!, only: [:index, :create]
  
+   def index
+     if(bm = @current_user.bookmark)
+       render json: bm.fsa, status: 200
+     else
+       raise ActiveRecord::RecordNotFound
+     end
+   end
  
  def create
    ch_id = params[:chapter_id]
    
    bookmark = Bookmark.find_or_initialize_by(user_id: @current_user.id)
    bookmark.update(last_read: ch_id, furthest_read: ch_id)
    render json: {message: "Bookmarks added, using chapter key #{ch_id}"}, status: 200
  end
end
```

Since this action already sits behind our `before_action` filter which authenticated our user, we can safely assume if a user has made it this deep into our controller action that the `@current_user` is available.  Therefore, all we need to do is retrieve the user's bookmark and send it as a JSON response.  If the user does not have a bookmark available, we raise an `ActiveRecord::RecordNotFound` error instead.

Now that our controller action is in place, we can begin updating the client-side of our `hydrateUser` saga.

``` javascript(/reactive-client/src/sagas/hydrate_user.js)
import { takeLatest, put, call } from 'redux-saga/effects';
import axios from 'axios';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* hydrateUser(action){
  yield redirectToPathIf(action.payload.bounce_path);
  
  try{
    let user = yield call(axios.get, "/api/hydrate_user?token=" + action.payload.token);
    yield put(setUser(user.data));
    
+     yield call(retrieveUserBookmark);
  } catch(e){
    // We need some error handling
  }
} 

export function* watchAuthRoutes(){
  yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
};
```

We are saying goodbye to our old alerting process that lived inside this saga.  With the new bookmark modal appearing onscreen after sign-in, having an additional popup message informing the user they have successfully logged in is superfluous.  Instead, we can yield to another generator utility function to handle our bookmark restoration.  Let's go ahead and set up that generator function now.

``` javascript(/reactive-client/src/sagas/utils/retrieve_bookmark.js)
import axiosCreateClient from './axios_client';
import {  call, put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';


export default function* retrieveUserBookmark(){
  let auth_client =  yield axiosCreateClient();
  
  if(auth_client){
    let response = yield call(auth_client.get, "/api/bookmarks");
    let lr = response.data.last_read || 0;
    let fr = response.data.furthest_read || 0;
    
    yield put(setBookmarkLocations(fr));
    yield put(setBookmarkLocations(lr));
    
    yield put(setBookmarkOffered(false));
    
    return true;
  } else { return false; }
}
```

Our new generator first sets up an authorized Axios client to manage our request.  This client allows us to set up an if statement that stops the generator from executing further if the user is not signed-in.  For an authenticated user, we can request their latest bookmarks from the API, and with the response, call our `setBookmarkLocations` action twice.  First, to set the furthest read location.  Then again, to set the last read location.

Finally, we set `prompt_shown` to `false` which allows our modal to appear onscreen.  Revisit your application and try it out.  You may need to sign in and sign out after doing a bit of "reading" if your user account does not have bookmarks set in your database.  Once you revisit and sign in though, you should see a prompt like the one below.

![Final presentation of bookmark modal](/images/12/bookmarkModalPrompt2.png)

## Rounding Out Our Tests

We have some tests that need to be updated or added before we close out this chapter.  There's no new ground being covered here so we will not be reviewing these in detail.  However, if you would like to include these updates in your own project, the examples are included below.

Notice we test our saga utilities in the same way we test our sagas themselves.  Even better, externalizing units on work like this make it far easier to handle our tests.  The `hydrateUser` saga for example only needs to check that a call in made to the `retrieveUserBookmark` generator function, which is itself tested thoroughly.  This pattern of externalize units of work keeps a single test suite from running into an unwieldy level of complexity.

``` javascript(/reactive-client/src/App.test.js)
import React from 'react';
import {Provider} from 'react-redux';
import ReactDOM from 'react-dom';
+ import buildStore from './reducers/store';
import App from './App';

+ let { store } = buildStore();

it('renders without crashing', () => {
  const div = document.createElement('div');
  ReactDOM.render(<Provider store={store}><App /></Provider>, div);
});
```

``` javascript(/reactive-client/src/sagas/utils/redirect_path.spec.js)
/* global expect */
import redirectToPathIf from './redirect_path';
import { put } from 'redux-saga/effects';

describe("redirectToPathIf", () => {
  test("returns path action", ()=> {
    let sample = {type: "ROUTE_ACTION", payload: {test: "value"}};
    let encoded_sample = encodeURIComponent(JSON.stringify(sample));
    expect(redirectToPathIf(encoded_sample)).toEqual(put(sample));
  });
});
```

``` javascript(/reactive-client/src/sagas/utils/axios_client.spec.js)
/* global expect */
import axiosCreateClient from './axios_client';

describe("axiosCreateClient, authrequired == true", () => {
  var saga;
  beforeEach(()=>{
    saga = axiosCreateClient();
    saga.next();
  });
  
  test("provides client if token is available", ()=> {
    let results = saga.next("token");
    expect(typeof results.value).toEqual("function");
  });
  
  test("returns null if no token and auth required", ()=> {
    let results = saga.next(undefined);
    expect(results.value).toEqual(null);
  });
});

describe("axiosCreateClient, authrequired == false", () => {
  test("return unauthenticated client", ()=> {
    let saga = axiosCreateClient(false);
    saga.next();
    let results = saga.next(undefined);
    expect(typeof results.value).toEqual("function");
  });
});
```

``` javascript(/reactive-client/src/sagas/utils/retrieve_bookmark.spec.js)
/* global expect */
import retrieveUserBookmark from './retrieve_bookmark';
import axios from 'axios';
import { put } from 'redux-saga/effects';

import { setBookmarkLocations, setBookmarkOffered } from '../../actions/bookmarks';

describe("retrieveUserBookmark", () => {
  var saga;
  beforeEach(()=>{
    saga = retrieveUserBookmark();
    saga.next();
  });
  
  test("terminates if unatuhenticated", ()=> {
    let result = saga.next(null);
    expect(result.done).toEqual(true);
    expect(result.value).toEqual(false);
  });
  
  test("updates bookmarks if client secure client available and offers prompt", ()=> {
    expect(saga.next(axios.create())["value"]["CALL"]["args"]).toEqual(["/api/bookmarks"]);
    
    // expects client to return bookmark data and put setBookmarkLocations(furthest_read)
    let results = saga.next({data: {last_read: 1, furthest_read: 2}});
    expect(results.value).toEqual(put(setBookmarkLocations(2)));
    
    //put setBookmarkLocations(last_read)
    results = saga.next();
    expect(results.value).toEqual(put(setBookmarkLocations(1)));
    
    // put setBookmarkOffered(false)
    results = saga.next();
    expect(results.value).toEqual(put(setBookmarkOffered(false)));
    
    expect(saga.next().done).toEqual(true);
  });
});
```

``` javascript(/reactive-client/src/sagas/hydrate_user.spec.js)
/* global expect */
import { call, put } from 'redux-saga/effects';
import axios from 'axios';

import { hydrateUser } from './hydrate_user';
import { routeHome } from '../actions/routes';
import { setUser } from '../actions/user';
import retrieveUserBookmark from './utils/retrieve_bookmark';

describe("hydrateUser", () => {
  let path = encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
  test("saga then trades temp token for long-term",() => {
    expect(saga.next().value).toEqual(call(axios.get, "/api/hydrate_user?token=" + action.payload.token));
  });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});
```

We should also update our controller tests to cover the `BookmarkController` for our `#create` and `#index` actions.  This task also introduces a new requirement to our test suite; a need to make authenticated requests.  We can set this up in a reusable module, that way it is readily available for future tests.

First, we can create the helper.

``` ruby(/reactive-api/spec/helpers.rb)
module Helpers
  def request_as(user)
    return {"Authorization" => TokenOps.encode_long(user) }
  end
end
```

Then we need to alter our `spec_help.rb` file to include these helper methods automatically in our tests. 

``` ruby(/reactive-api/spec/spec_helper.rb)
+ require 'helpers.rb'
RSpec.configure do |config|
+   config.include Helpers
  config.expect_with :rspec do |expectations|
    expectations.include_chain_clauses_in_custom_matcher_descriptions = true
  end

  config.mock_with :rspec do |mocks|
    mocks.verify_partial_doubles = true
  end

  config.shared_context_metadata_behavior = :apply_to_host_groups
end
```

Now when we want to make an authenticated request, we can create the user we want to use for our test.  Then we merge the header information generated by our `request_as` helper method with the generic headers RSpec provides.  From there testing can proceed normally.

``` ruby(/reactive-api/spec/controllers/api/bookmarks_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::BookmarksController, type: :controller do
+   before(:each) do
+     @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
+     @user.bookmark = Bookmark.create(last_read: 1, furthest_read: 1)
+     request.headers.merge! request_as(@user)
+   end
  
  describe "post #create" do
    it "returns http success and sets new bookmarks" do
      post :create, params: {chapter_id: 2}
      expect(response).to have_http_status(:success)
      @user.reload
      expect(@user.bookmark.last_read).to eq 2
      expect(@user.bookmark.furthest_read).to eq 2
    end
  end
  
  describe "GET #idex" do
    it "returns a user's bookmarks" do
      get :index
      expect(response).to have_http_status(:success)
      expect(response.body).to eq "{\"user_id\":1,\"last_read\":1,\"furthest_read\":1}"
    end
  end
end 
```

## Wrapping Up

We have finished the addition of our first authenticated actions.  It has taken us two chapter to get through setting up an authentication system and making our first protected resource requests.  

In the process of doing so, we have significantly increased the complexity of our actions, and as a result, introduced several new ways for our application to fall of the rails (nudge nudge).  With that in mind, in our next chapter, we will introduce a more comprehensive system for handling minor and major errors, and standardize some systems to help our application get back on track when something goes wrong.
