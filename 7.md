# Chapter 7: Client-Side Routing

We have got a basic UI in place now for displaying our book contents and the beginnings of a navigation system. Finishing these features will allow us to cease printing out 100% of the book's contents with every page load, and instead, select single chapters to view.  Before we move on further in our application though, we need to think about a new part of our state we have so far ignored, the URL bar.

## Jumping in here

If you have not been following along with the code examples and wish to jump in here, you can catch up with the work through Chapter 5 using the branch: https://github.com/swachtma/reactivating-rails-app/tree/Chapter6Starter


## Client Side Routing Solutions

React and by extension Redux, have many different approaches to routing; all of them seeking to solve the problem of how to handle URL state.  

The problem, if I can simplify it, is that React and more so Redux, are built upon a principle of having a centralized system of record for your application state (your store).  However, the purity of this concept is broken somewhat by the intrusion of the browser’s URL bar.  (A somewhat inescapable piece of state for our web applications)

The trick is, on the client side, thanks to search engines, and direct links to our sites, we do not know what point a user might enter our application, and moreover, the user's expectations about how our application should behave might differ based on the URL they use to enter the site.

Our application **should** respond accordingly to each appropriate URL.  Setting aside the SEO implications of not supporting URL routing in our applications, it's a bad user experience to ignore this piece of the state.  Have you ever sent someone a link to a piece of content you want to share, only to realize the contents of your URL bar does not preserve the content/state you are trying to share?  Very annoying.

So, we need to answer this user expectation.  That decision though means we have suddenly gone from a single record of the state to a shared 2-part system.

Let's look quickly at a few approaches to solving this problem.

### React Router

[React Router](https://github.com/ReactTraining/react-router) is probably the best-known solution for Routing in the React Ecosystem.  Their approach says that we should treat routing as another layer of components in our application.  With React-Router, we use specialized components to conditionally render areas of our application based on the state of our URL bar.

``` javascript
const App = () => (
  <BrowserRouter>
    {/* here's a div */}
    <div>
      {/* here's a Route */}
+       <Route path="/tacos" component={Tacos}/>
    </div>
  </BrowserRouter>
)
```

In the example code above, the `Tacos` component only renders if the route paths `/tacos` is matched.  

Using React Router, we now have an additional layer of components in our application's rendering tree.  Using `Route` components, React Router lets us choose which components render in our application based on the state of the URL bar.  Then we can treat state within our application nearly the same as we would in a route-free application.  The tradeoff is we need to now have these extra layers of component abstraction in our application.  

We also now have two disconnected state systems in our application (though there are connectors for Redux that minimize, but do not eliminate this drawback).

Testing, in my opinion also becomes more complicated.  Our components now have two systems they rely on for state.  That means if we want to test a component, we need to mock 2 systems of state to get a test-case built for a specific expectation.

React Router is a common solution, but I would also argue its coupling with Redux is also the most limited.

### Redux Little Router

With the rising popularity of Redux, there have been several other routers written to make Redux more of a first-class citizen in the application’s Router.  However, most of them have taken an approach that adapts concepts React-Router familiarized while trying to make the overall solution more closely tethered to Redux.

It's hard to say that there's one clear leader in this realm of blended Redux/React Routing, but I have some experience using [redux-little-router](https://github.com/FormidableLabs/redux-little-router), so let's talk through that quickly.

Redux Little Router brings your URL state into the redux store.  When you install the router, you configure a store enhancer and reducer that adds a "router" attribute to your state tree.  When the URL state changes in your browser, the application state changes in the store as well.

Similarly, when you push route changes within your application (for events such as link clicks, or form submissions), these changes are dispatched as redux actions.  This action-dispatching pattern gives you a very familiar interface to manage your route changes; a page change is just a reducer action that happens to update the Brower's URL bar and history as a side-effect of the larger state change.

Here is an example `LOCATION_CHANGED` action payload, dispatched when redux-little-router issues a page change:

``` javascript
// For a URL matching /messages/:user
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: { // if your `history` instance uses `useQueries`
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!'
    parent: { // for nested routes only
      // contains the result of the parent route,
      // which contains each other parent route's
      // result recursively
    }
  }
}
```

Now below, see the resulting change to the `router` attribute created in our store.

``` javascript
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: {
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!',
    parent: { /* the parent route's result */ },
  },
  previous: {
    pathname: '/messages',
    route: '/messages',
    params: {},
    query: {},
    result: {
      more: 'arbitrary data that you defined in your routes object!'
      parent: { /* the parent route's result */ }
    }
  }
}
```

This reliance on action dispatches for route changes alleviates some of the problems I highlighted above with React Router.  URL state and our store’s location representation mirrored by redux-little-route. 

Testing is also much improved in my opinion.  When I am writing tests, my "location" is just another piece of the store’s state.  So rather than providing a separate mechanism to mock a URL state, I can mock the location attribute of my store.  Testing the outcome of a location state is no more complicated than any other test where I might provide an artificial store setup to test expectations.

When the user makes a direct page request from the browser's URL bar, the config you have setup for Redux Little Router translates that request into a "LOCATION_CHANGED" FSA.  Your application processes that action in your reducers as it would any of your custom actions.

#### Here's Where It Goes a Little Sideways

For all that Redux Little Router does to Reduxify the management of your routing, it also seems like a continuation or reworking of React Router.

The use of components to conditionally manage which what renders according to URL route matches is still a central part of Redux-Little-Router's landscape.  This design decision means we do not get to say goodbye to aspects of React Router that clutter our application's component tree.

Redux Little Router gives us access to a `Fragment` component that manages our application as we saw our Router components behave using React-Router.

``` javascript
<Fragment forRoute='/about'>
  <div>
    <h1>About</h1>
    <Fragment forRoute='/bio'>
      <div>
        <h2>Bios</h2>
        <Fragment forRoute='/dat-boi'>
          <div>
            <h3>Dat Boi</h3>
            <p>Something something whaddup</p>
          </div>
        </Fragment>
      </div>
    </Fragment>
  </div>
</Fragment>
```

Now we can argue about how much of a problem this is.  However, I would say that problem or not, it is probably not a necessary function of a routing library that's genuinely a Redux-first approach.

It is also a shame that all our location change actions with redux-little-router use the same `type` attribute, `LOCATION_CHANGED`.  This use of a single action type minimizes the usefulness of one compelling design pattern in Redux.  

When an action dispatches to our store, it passes through **all** of our reducers.  Any reducer setup to respond to that action’s `type` attribute can execute instructions on how to treat its state in response to the dispatch.  Wouldn’t it be nice then if every route we triggered in Redux came with a unique type value?  That way each section of our store state could be set up to respond as needed during route changes.

### Our Routing Solution: Redux-First-Router

All that brings us to the package we are going to be using for our routing; [Redux First Router](https://github.com/faceyspacey/redux-first-router).

Redux-First-First router gives us the most tight-knit integration I have seen available between URL state, and application/store state.  Like Redux-Little-Router, Redux-First-Router gives us a branch in our store that represents the application’s location.  It also uses FSA to push route changes in the application, so we get to use the same interface we use for all of our other state changes to handle routing.

Redux-First-Router though, says goodbye to the management of application routing components such as `Fragment` and `Router`.  

Think it through; if your application state has a representation of our router location, why can we not use the same tools we use to manage the rest of our application state to render the appropriate components/state?

Redux First Router accomplishes this by migrating away from a single `LOCATION_CHANGED` action we saw in Redux Little Router, and instead gives us a mechanism to map specific route patterns to specific dispatched action types using a route map:

``` javascript
const routesMap = { 
  HOME: '/home',      // action <-> url path
  USER: '/user/:id',  // :id is a dynamic segment
}
```

Referring to the previous example, requests for `/home` dispatch an action with the type `HOME`, and routes matching `/user/:id` alternatively dispatch an action with type `USER`.

The result gives us the flexibility to take appropriate instantiation actions when a user comes into our application on one route vs. another.  For example; a user coming into a `HOME` route probably gets a simple rendering of our application.  A request for a specific `USER` route though might kickoff a complicated series of actions.  In such a case we might need to check a user-authentication token, providing authenticated content, or redirecting to an authentication route if a valid token is detected.

None of this is to say we can't do these same things with other routing tools.  But the removal of Router state from our component tree allows us to manage these concerns where we manage all our other state concerns.  We also get to keep our application components as simple renderings of state, precisely as they should be.  And our state remains a single point system of record.

### Author's Aside

My introduction of Redux-First-Router is a high-level attempt to explain my choice of routers and give a bit of context surrounding other tools.  For those interested in learning more about Redux-First-Router, and the problems it seeks to solve, I highly recommend a bit of side reading: [Redux-First Router - A Step Beyond Redux-Little-Router](https://medium.com/faceyspacey/pre-release-redux-first-router-a-step-beyond-redux-little-router-cd2716576aea)
    
## Chrome's Redux Extension

We are about to install our first package that dispatches actions of its own to our Redux store.  Up until now, all the actions we dispatched have been custom actions we have written.  Now that we are going to be leveraging tools that do independent dispatching, I think it is worth taking time to install some developer tools to help us track and observe these actions as they hit our store.

[Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en) allows us to spy on actions dispatched to our store and provides us with diffs for each change made to our application state as a result of incoming actions.  It also offers a somewhat fantastic ability to time travel through these dispatches to see how our state mutated along the way.  I find it to be a beneficial tool, especially when I am trying to spy on a 3rd party package's dispatched actions.  Its use is optional, but I do heartily recommend it.

Begin by installing the chrome extension with the link above.  We are also going to use an NPM package to simplify our in-app setup.  `npm install --save-dev redux-devtools-extension`.  Finally, we need to do some setup in our store config to allow this to work.  Open `src/reducers/store.js` and make the following changes.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers } from "redux";
+ import { composeWithDevTools } from 'redux-devtools-extension';
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
+   combineReducers({nodes, chapters}), composeWithDevTools()
);

export default store;
```

The `redux-devtools-extension` offers us a helper `composeWithDevTools` that includes store enhancers for the dev tools if the user has them available, and falls back to a standard `compose` method provided by `redux` if this extension-specific version is not available.

We have not talked about these topics yet; middleware, enhancers, or the compose method.  We are visiting them in a future iteration when we write some custom middleware.  For now, let's put a pin in it with this 10,000-foot summary.  Middleware exists in our Redux stack and has visibility on every action dispatched through the store, as well as the store state itself.  

This middleware pattern is very similar to the way reducers handle actions.  A dispatched action can pass through our entire stack of middleware, triggering several operations along the way.  One fundamental difference though is that a middleware might be set up to block specific actions on certain conditions, or they might modify the FSA and pass an updated copy through the remainder of the middleware stack, or even dispatch entirely new actions as an outcome of another action.

Middleware is used to debounce actions, manage API communications, validate permissions, and any number of other everyday tasks.  If you want to position code somewhere it can conditionally be executed against any number of dispatched actions; chances are you are entering the territory of Middleware.

Enhancers are a more complicated implementation of middleware, and unless you set out to write significant application extensions to Redux itself (such as Redux-DevTools), chances are you will not need to write them.

However, if you understand the positioning of middleware, even in this simplified summary, you can begin to see how Redux Devtools is ideally positioned to "spy" on your store actions.

Now, reload your application in Chrome, and activate the extension.

![Redux DevTools With Setup Actions](/images/7/ReduxDevTools.png)

You should see our two setup actions requesting chapters and nodes when the page loads.  You can also spy the state tree before and after each dispatch.  There's a lot here, take some time to poke around before moving on!

## Setting Up Redux-First-Router

Now let's get our router installed in our application.  `npm install --save history redux-first-router`.  We again need to modify our store configuration to finish the install.

Our store setup is going to get a bit more complicated, so let's look at this in a few steps.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

+ const history = createHistory();
+ const reducers = combineReducers({nodes, chapters})

const store = createStore(
+   reducers, composeWithDevTools()
);

export default store;
```

First, I am pulling our `combineReducers` function out of our `createStore` call and assigning the returned super-reducer to a constant.  We are going to be mixing in a new reducer provided by our router, so to simplify this, we are breaking reducer creation off into a section of code; then we provide the final value to our store.

We have also included `createHistory` from the npm `history` package, which is a dependency for Redux-First-Router.  History provides several methods to store history, but since our application is browser-only, we are only leveraging the browser-history aspect of the package.  Browser history leverages the HTML5 history API used among modern browsers.  The history package also offers native app solutions (createMemoryHistory).  As well as legacy browser support (`createHashHistory`).

The browser history option has support as early as IE 11, so that meets our needs.

Let's jump ahead again.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

const history = createHistory();
+ const routeMap = {
+   // Routes here "ACTION_NAME":"/some/route"
+ };

+ const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers({location: reducer, nodes, chapters});
+ const middlewares = applyMiddleware(middleware);

const store = createStore(
+   reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

We are now making use of `connectRoutes` and an assignment syntax we have not seen before.  `connectRoutes()` is going to take our history API, and well as a route map object, which we have yet to define fully.  The function then returns an object from which we wish to capture several keys: `reducer`, `middleware`, and `enhancer`.  We are using all three of these return values to configure Redux-First-Router into our store.

Our combine reducer function is getting a new key `location`, to which we are assigning the reducer function provided by Redux-First-Router.  I am opting to use the namespace `location`, as that is the default suggested by Redux-First-Router, and I see no need to change that key.  Other than verbosely assigning a name for this section of our store, the `combineReducers` function behaves as it always has with our custom reducers.

Next we are seeing our first use of `applyMiddleware()`.  Much like `combineReducers` helps us compile our various reducers into a single unit, `applyMiddleMiddle` allows us to define a hierarchy of middleware used in our application.  This setup defines an order of operations about which piece of middleware sees each dispatched action first.  We can revisit this in detail in the future when we define custom middleware, but for now, it is being set up more as a point to allow future extension of our store.

Finally, we see our call to `createStore()` now invoked with `composeWithDevTools(enhancer, middlewares)` to ensure all our middleware and store enhancers are included in our application store aside our reducers.  `composeWithDevTools` was introduced when we installed Redux Devtools, as an alternative to `compose` which is the vanilla implementation that ships with `redux`.  This use of `composeWithDevTools`is simply part of how we have chosen to install the Dev Tools, if you are choosing not to run them, you can instead invoke `compose` instead.

## Defining our first Routes

Now that the basic setup is complete, we can turn to defining our first routes inside the route map.

Right now, I only see a need for two routes.  One for a request of the homepage, which I think for the time being should result in Chapter 0 displayed as a default.  In the future, we might decide to add a static homepage to our application, but for now, beginning with the book's introduction seems appropriate.

Then we also need a route to request a specific chapter.  This route also needs to accept a dynamic parameter to request a specific chapter of the book.

Let's define the following in our `routesMap` object.

``` javascript
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  "HOME_ROUTE": "/",
  "CHAPTER_ROUTE": "/chapter/:chapter_id"
};
```

At their most basic, our routes are defined in the form `"ACTION_NAME":"/some/route"`.  They also give us a mechanism for defining dynamic parameters in our routes, such as the use of `:chapter_id` above.

Go ahead and visit your application homepage, and look at the actions fired in your Redux Developer tools.  If everything has been setup correctly, you should see an action in your dev tools history with the type, `HOME_ROUTE`.  Looking at the dispatched action in its raw form shows us the entire FSA.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
  meta: {
    location: {
      current: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

We are receiving quite a lot of information here.  At its simplest, our dispatched actions look similar to the custom FSA we have created, with a `type`, and `payload` attribute.  We have not really worked with a `meta` attribute yet, but the `meta` keyword is often used by Redux middlewares to determine which middleware should operate on each action, and how.  

Here, our meta information contains additional information about our routings, such as the previous route we are leaving, the kind of route action (`load` in this case), and details about the currently matched route.

It is worth noting that when Redux-First-Router builds its actions it also carefully preserves other information you might have stored in the `meta` attribute of actions.  Since as we've mentioned, `meta` is commonly used among middleware this helps ensure our routing plays nicely with other middleware we might build or install.

Let's look at a `CHAPTER_ROUTE` as well.  Visit `[your host]/chapter/1` in your browser, and have a look at the dispatched action again.

``` javascript  
{
  type: 'CHAPTER_ROUTE',
  payload: {
    chapter_id: 1
  },
  meta: {
    location: {
      current: {
        pathname: '/chapter/1',
        type: 'CHAPTER_ROUTE',
        payload: {
          chapter_id: 1
        }
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

Anytime we write a dynamic parameter into a route, Redux-First-Router adds that value to the payload of our dispatched route action.  In this case, we defined the name `chapter_id` in our route, so our payload includes `chapter_id: 1` when you trigger the route `chapter/1`.

That is amazing when you consider the fact that all this integration is provided to use with almost no setup cost from our router.

## Catching Dispatched Routes

Technically, we might be able to stop there and meet the objectives of our iteration.  We have seen in our dispatched actions that we have a marker for the requested chapter in each dispatched route action.  What we have not looked at, is how these actions influence our state.

``` javascript
{
  location: {
    pathname: '/chapter/1',
    type: 'CHAPTER_ROUTE',
    payload: {
      chapter_id: 1
    },
    prev: {
      pathname: '',
      type: '',
      payload: {}
    },
    kind: 'load',
    routesMap: {
      HOME_ROUTE: '/',
      CHAPTER_ROUTE: '/chapter/:chapter_id'
    }
  },
  nodes: [...],
  chapters: [...]
}
```

The information our routes dispatch in actions is also preserved in our store.  We could fairly easily update our Components to connect to this location value and determine which chapter to display.  We'd simply connect to the `location.payload.chapter_id` value and display the appropriate chapter for each route.  We could then use a default chapter value in our component to display chapter 1 on our homepage if a specific value was not available off our router state.

I am going to forego that approach though, and instead set up a different area of our state to store this information.  As our application continues to grow, we are likely to encounter more aspects of our state we need to preserve that fall into this settings/config spectrum.  Odds are, packing all those setting into my routes would become problematic.  While it is tempting to plug into the value we already have, I think it is worth setting up a more centralized branch of our state to manage these application-level settings.

We should also remember that we do not own the object structure for Redux First Router's state or its dispatched actions.  If we build our application directly on top of its state, we might have a headache down the line if that storage mechanism changes in a later version of the router.  Upgrading might then require us to weed through many of our component/containers to align with this change.  Setting up a state of our own might still require some changes, but they will at least be centralized in one location and easy to access.

If all of that does not convince you, what happens when we need to define another route down the line that also uses a chapter_id value in the payload?  Now we need to suddenly determine whether the presence of a chapter-id in our payload means we should display a new chapter, or do something else.  

We are much better off defining a storage structure of our own to house the state we need.

Luckily, we can do this is a very Redux first way.

### A Reminder About Reducers

When we introduced reducers, we said that when an action dispatches, it passes through all of our reducers.  We have not really made use of this design feature yet, but we are about to.

Redux First Router supplies a reducer of its own, and with it, builds its own `location` state tree for us.

However, the actions the router dispatches still flow through all our other reducers with each dispatch.  So, we can set up an area of the store to respond to these dispatches, and create any state we need.  We can do all of that without interfering with the internal operations of Redux-First-Router.

Let's set up a new file `src/reducers/settings.js`, and build out a reducer to own our high-level settings for application state.

``` javascript(/reactive-client/src/reducers/settings.js)
import * as constants from '../constants/settings';

let default_state = {};
let default_chapter = 1;

const settingsReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.HOME_ROUTE):
      return Object.assign({},state,{active_chapter_id: default_chapter});
    case(constants.CHAPTER_ROUTE):
      return Object.assign({},state,{active_chapter_id: action.payload.chapter_id});
    default:
      return state;
  }
};

export default settingsReducer;
```

We know that Redux First Router dispatches an action where our route name occupies the TYPE attribute of the dispatched FSA.  So, setting up a reducer to catch these actions is no more complicated than any other reducer we have produced.

We can define a variable to store our  default chapter, and assign it to the `settings.active_chapter_id` store value we have created when the `HOME_ROUTE` is triggered.  Otherwise, we pull the active chapter value from the payload included with our `CHAPTER_ROUTE` action.

Note that I have set up a constants files for our route names like the pattern we have used in other reducers.

``` javascript(/reactive-client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
```

Finally, we need to include our new reducer into our store setup.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import * as routes from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
+ import settings from './settings';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
+   [routes.HOME_ROUTE]: "/",
+   [routes.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers({location: reducer, settings, nodes, chapters});
const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

I have also transitioned my `routesMap` object to use the constants I have defined.  The bracket syntax in our object literal’s attribute names is a new ES2015 syntax you may not have seen yet.  It allows us to use variable name assignment inside the literal syntax, and avoid the bracket syntax assignment we have historically been forced to use (`routeMap[routes.HOME_ROUTE] = "/"`).

Now let's let our application reload, and look at our state after a route change dispatch for `/chapter/5`.

``` javascript
{
  location: { ... }
  },
  settings: {
    active_chapter_id: 5
  },
  nodes: [...],
  chapters: [ ... ]
}
```

A similar request for our `HOME_ROUTE` will yield `settings.active_chapter_id == 1`.  I would say we are now ready to plug this into our UI

## Filtering FilteredNodeList

Updating our UI to limit the nodes printed to a single chapter should now be almost trivial, so let's start there.  Open your container for `FilteredNodesList`.

``` javascript(/reactive-client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ const filtered_nodes = (nodes, chapter) => {
+   return nodes.filter((node) => { return node.chapter_id === chapter });
+ };

const mapStateToProps = (state) => ({
+   nodes: filtered_nodes(state.nodes, state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

We are adding a `filtered_nodes` function to our container, and passing it the unadulterated list of nodes from our store state, as well as the active chapter.  The function will return a new Array of only the nodes where `node.chapter_id === store.settings.active_chapter_id`.  

Just like that you can revisit your application and see that requests to the homepage now show only our first chapter.  We can also use the `chapter/:chapter_id` routes to display other chapters.

## Configuring Form Controls

Now we need to wire in our form control for chapter selection.

First, we should make preparations for our action dispatching.  Let's set up some action creator functions for our route changes in a file `src/actions/routes.js`.

``` javascript(/reactive-client/src/actions/routes.js)
import * as routes from '../constants/setting';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);
```

Nothing much new here, but there is one more bit of Redux First Router magic I want to point out.  Open your app's browser console and dispatch one of these new actions to the store.  If you inspect the action afterward in your dev tools, you can see someone has done some extra heavy lifting for you.  Here is an example of a dispatched `HOME_ROUTE` created using our action creator function.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
+   meta: {
+     location: {
+       current: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       prev: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       kind: 'push'
+     }
+   }
}
```

Despite only populating our action's type in our action creator function, Redux-First-Router's middleware appended all the additional context information available about the route change, including our previous page, matched routes, and payload.  You can test out the `routeChapter` function in your store's dispatch and see it gets similar treatment.

Now that we have action creators let's update our `ChapterMenuItems` component and its container to leverage these functions.  Let's start with the container.

``` javascript(/reactive-client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
+ import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
+   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

We need some new props available in our connected component.  The first and most obvious is a prop for our dispatch of `routeChapter`, which we have created using the name `dispatchRouteChapter`.  This function's signature clones the signature used by our Semantic UI component's `onChange` events.  This event is going to expect a handler function that accepts two parameters when invoked, a copy of the event itself, as well as an object detailing the target where the action originated.

We can use that target object passed to our handler function to carry the value of each menu item into our dispatched store action (in this case, the ID of the specific chapter selected from the menu).

Now let's retool the `ChapterMenuItems` component to leverage this.  As I do, I am also going to rework the component a bit to use a simplified implementation of Semantic UI's `Dropdown` component.  Our original implementation used the sub-components `Dropdown.Menu` and `Dropdown.Item`.  However, given the level of control that we need on the component, this now seems like overkill.  Instead, we can get by using only the top-level component and passing it an options array that which populates our menu items.

``` javascript(/reactive-client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
+ import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
+   renderChapterOptions = () => {
+     let chapters_list = [];
+     this.props.chapters.forEach((chapter) => {
+       chapters_list.push(
+         { 
+           key: "chapter_" + chapter.id,
+           id:  "chapter_menu_item_" + chapter.id,
+           value: chapter.id,
+           text: chapter.title,
+         }
+       );
+     });
+     return chapters_list;
+   }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Our updated `Dropdown` component now calls `dispatchRouteChapter` when the `onChange` handler fires on the menu.  Our `renderChapterOptions` function is an update to the function that was producing our `Dropdown.Item` components, now producing a simplified options array instead.

If you look at what we have got so far, we have now got a functioning control in our dropdown to change to a specific chapter.  Give it a test drive before you move on.  See if you can spot some of the areas we need to brush up yet.

## Polishing Our Navigation UI

We have got a basic control functioning, but the user experience is a little lacking.  For one, when we are already reading, we do not show the current chapter as active in the dropdown's pane.   That robs our users of some information scent that could help them know where they are in our overall navigation schema.  

To implement this, we need to have access to our current active chapter inside our component.  Then we can populate our `Dropdown` component with some additional placeholder values.

There's also a moment in time after page-load when our control is written to the screen but is nonfunctional.

Without meaning to, I have led you into a beautiful example of why managing API calls out of your component's lifecycle methods is less than ideal.  (To be fair, I have been mentioning we need to clean up this code ever since we wrote it.)  However, this is an excellent opportunity to demonstrate the problem.

Let's make another round of changes to our container.

``` javascript(/reactive-client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
+   active_chapter: state.chapters.find(
   (chapter) => chapter.id === state.settings.active_chapter_id
  ),
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Look at our new `active_chapter` prop.  It is good to keep in mind that your containers can do a lot more than simply map store values verbatim into your components.  In this case, it would be helpful for us to have access to both our active chapter's title and ID value.  So rather than simply pass through the ID of the active chapter from `settings.active_chapter_id` we can use the ID to select the full chapter object from our `chapters` store attribute.  Then we have access to the active chapter as a full object inside our connected component, rather than just the simple ID value.

Let's now update our `ChapterMenuItems` component to leverage this.

``` javascripte(/reactive-client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
+           active: chapter.id === this.props.active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
    }
}
```

I now invite you to render this code, **so that you can watch it choke**.  Can you spot what happened?

We never fire an API call to fetch the list of chapters until the first time the component renders.  We also do not dispatch an action to load those chapters until the API call returns.  

That means, the first time the component renders, our `store.chapters` value is guaranteed to be our default `[]` value.  We are then attempting to filter that empty array for a specific `chapter.id` id value to populate our `active_chapter` prop.  Searching an empty array for a specific value of course helpfully returns `undefined`.  So when our component goes digging in that `undefined` value for `title` and `id` attributes... **BOOM!**

Here's the monkey patch solution.  Update the render function of `ChapterMenuItems` as follows.

``` javascript(/reactive-client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderChapterOptions = () => {
-     let chapters_list = [];
-     this.props.chapters.forEach((chapter) => {
-       chapters_list.push(
-         { 
-           key: "chapter_" + chapter.id,
-           id:  "chapter_menu_item_" + chapter.id,
-           value: chapter.id,
-           text: chapter.title,
-          active: chapter.id === this.props.active_chapter.id
-         }
-       );
-     });
-     return chapters_list;
-   }
  
  render() {
+     if(this.props.chapters !== [] && this.props.active_chapter){
+       return( 
+         <Dropdown 
+           tabIndex="1"
+           placeholder="Jump to Chapter..."
+           className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
+           onChange={this.props.dispatchRouteChapter}
+          options={this.renderChapterOptions()} 
+         />
+       );
+     } else {
+       return null;
+     }
  }
}
```

Your components do not have to render anything; they can instead just return null.  So, we can short-circuit rendering the dropdown menu if we have not yet populated our chapters into the store with an if statement to check our status.

What this does not do, is stop an unfortunate situation where we are guaranteed to go through at least one wasted render cycle on this component just to dispatch our API calls.  Luckily, we look at dealing with this long-standing issue in our next chapter.

## Scroll Restoration with Navigation

One more creature comfort I think we need to address before moving forward is scroll restoration.

You might have noticed if you have been testing out our chapter navigation that if you scroll into a chapter before making a new chapter selection from our dropdown that you load the updated content requested, but your scroll remains mid-way down the page.

That is likely not what our users anticipate happening, and it might lead them to believe our navigation to be broken if they do not notice the content of the page change.  We should add something to ensure users return to the top of the page with each route change.

Luckily, Redux First Router provides an associated package that handles this for us quickly.  It is worth mentioning that Redux-First-Router provides many such modules for the base router.  They are split into separate packages to minimize installing features not all user's might need/want.  However, the GitHub repo for the project is worth exploring when you have time, as there's much we just won't cover in our work together.

Go ahead and install the scroll restoration module; `npm install --save redux-first-router-restore-scroll`.  Then open your store config at `src/reducers/store.js` and make the following changes.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
+ import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
- const routeMap = {
-   // Routes here "ACTION_NAME":"/some/route"
-   [ROUTES.HOME_ROUTE]: "/",
-   [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
- };

const { reducer, middleware, enhancer } = connectRoutes(
  history,
  routeMap,
+   { restoreScroll: restoreScroll() }
);

const reducers = combineReducers({location: reducer, settings, nodes, chapters});
const middlewares = applyMiddleware(middleware);

- const store = createStore(
-   reducers, composeWithDevTools(enhancer, middlewares)
- );

export default store;
```

We are now passing an optional parameter of options to `connectRoutes` to enable automatic scroll restoration.  Other options would allow us to manually trigger scroll restoration, or trigger it only in response to certain routes.  However, for now, the automatic pattern fits our needs just fine.

## Wrapping Up

We have accomplished a lot in this iteration and introduced our first navigation functionality into what has previously been a single unbroken stream of content.  We talked through some routing options available and settled on the use of Redux First Router.  We upgraded some of our container components to support this new functionality, and made it painfully clear we need to address some long-standing issues in our components.  

We do just that in our next chapter, as we introduce Sagas to manage our API interactions.

## What About Tests

I skipped a few test files this chapter for the sake of presenting all our router content in one cohesive stream.  Nothing we introduced this chapter requires a new testing strategy so feel free to try going through and adding them in yourself if you would like.

I have also included the new tests I created here for those that need help, or somewhere to copy/paste form.

``` javascript(/reactive-client/src/reducers/settings.spec.js)
/* global expect */
import  settingsReducer from './settings';
import * as actions from '../actions/routes';

let defaultState = {};

describe("Chapter & Home Routes", ()=>{
  test("Assign default chapter of one on HOME_ROUTE", ()=>{
    expect(settingsReducer(defaultState,actions.routeHome())).toMatchSnapshot();
  });
  
  test("assign payload chapter on CHAPTER_ROUTE",()=>{
    expect(settingsReducer(defaultState,actions.routeChapter(5))).toMatchSnapshot();
  });
});
```

``` javascript(/reactive-client/src/actions/routes.spec.js)
/* global expect */
import * as actions from './routes';

describe("Routes actionCreators", ()=>{
  test("routeHome()", ()=>{
    expect(actions.routeHome()).toMatchSnapshot();
  });
  
  test("routeChapter(chapter_id)", ()=>{
    expect(actions.routeChapter(5)).toMatchSnapshot();
  });
});
```