# Chapter 7: Client-Side Routing

We now have a basic UI displaying our book's content and the beginnings of a navigation system. By completing these features, we can cease printing 100% of our book's content on a single page, and instead, select chapters individually for display.  Before proceeding though, we need to think about an area of our state we have so far ignored: the URL bar.

## Getting Started 

If you're starting here or jumping between chapters, I recommended executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch7-starter
```

## Client Side Routing Solutions

React and Redux libraries offer many varied approaches to client-side routing; all designed to manage URL state.  

Redux stands on an idea of having a central system of record for your application state.  However, disrupting the purity of this concept is the intrusion of the browser’s URL bar (a somewhat inescapable piece of state for our web applications).  Thanks to search engines and direct links to our sites, we can't predict where a user might enter our application.  Our application **should** respond predictably if multiple users land upon a single URL.

Setting aside the SEO implications of not supporting URL routing in our applications, it's lousy user experience.  Have you ever linked a piece of content only to realize the URL doesn't represent the content/state you wanted to share when others visit that same address?  Very annoying.

We need to meet this user expectation, which means moving from a single-source application state (store) to a divided two-part system (store + URL).

Let's look quickly at a few approaches to solving this problem.

### React Router

[React Router](https://github.com/ReactTraining/react-router) is probably the best-known React routing solution.  Their approach treats routing as another layer of components in our application.  With React Router, we use specialized components to conditionally render areas of our application based on the URL.

``` javascript
const App = () => (
  <BrowserRouter>
    <div>
+       <Route path="/tacos" component={Tacos}/>
    </div>
  </BrowserRouter>
)
```

In the example above, the `Tacos` component only renders if the route `/tacos` is matched.  

React Router decides which components render in our application based on the state of the URL bar.  Then, managing state within those components can proceed as it would be in a route-free application.  The tradeoff is we need to manage this additional layer of components in our application.

React Router is a common solution, but I would also argue its coupling with Redux is also the most limited.

### Redux Little Router

Several other routers make Redux more of a first-class citizen in the application’s routing.  Most adapt concepts React Router popularized while trying to tether the overall solution more closely with Redux.

It's hard to pinpoint one clear leader in this realm of blended Redux/React Routing, but I have some experience using [redux-little-router](https://github.com/FormidableLabs/redux-little-router), so let's talk through that quickly.

Redux Little Router brings your URL state into the redux store.  When you install the router, it adds a "router" attribute to your state tree, and a reducer to manage it.  When the URL changes in your browser, the router state is automatically updated in the store as well.

Route changes within your application dispatch redux actions.  This action-dispatching pattern gives you a familiar interface for managing route changes.  A page change is just an action that happens to update the URL bar and history as a side-effect of a larger state change.

Here is an example `LOCATION_CHANGED` action dispatched by redux-little-router:

``` javascript
// For a URL matching /messages/:user
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: { // if your `history` instance uses `useQueries`
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!'
    parent: { // for nested routes only
      // contains the result of the parent route,
      // which contains each other parent route's
      // result recursively
    }
  }
}
```

Now below, see the resulting change to the `router` attribute in our store that occurs when this action is dispatched.

``` javascript
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: {
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!',
    parent: { /* the parent route's result */ },
  },
  previous: {
    pathname: '/messages',
    route: '/messages',
    params: {},
    query: {},
    result: {
      more: 'arbitrary data that you defined in your routes object!'
      parent: { /* the parent route's result */ }
    }
  }
}
```

Actions triggering route changes keep our URL and store as mirrored representations of a user's location.  When the user requests a route with their browser, Redux Little Router translates that request into a "LOCATION_CHANGED" action and processes it just like any of your custom actions.

I like this approach for testing because my location is just another branch of our store.  We can mock our location as quickly as any other element in our application's state.  

#### Where It Goes a Little Sideways

For all Redux Little Router does to Reduxify your routing, it feels like a continuation or reimplementation of React Router.

The use of conditional routing components is a central part of Redux Little Router.  This design decision means we're stuck with aspects of React Router that clutter our application's component tree. Redux Little Router gives us a `Fragment` component imitating React Router's `Route`.

``` javascript
<Fragment forRoute='/about'>
  <div>
    <h1>About</h1>
    <Fragment forRoute='/bio'>
      <div>
        <h2>Bios</h2>
        <Fragment forRoute='/dat-boi'>
          <div>
            <h3>Dat Boi</h3>
            <p>Something something whaddup</p>
          </div>
        </Fragment>
      </div>
    </Fragment>
  </div>
</Fragment>
```

We could argue over how much of a problem this is.  However, problem or not, it is probably not a necessary function of a routing library that's genuinely Redux-first.

It is also a shame that all our location change actions with Redux Little Router use the same `type` attribute, `LOCATION_CHANGED`.  When an action dispatches to our store, it passes through **all** of our reducers.  Any reducer configured for that action’s `type` attribute can update our state in response to the dispatch.  Wouldn’t it be nice then if every route bore a unique type value?  That would allow us to assert fine-tuned control over our state in response to particular routing events.

### Our Routing Solution: Redux First Router

That brings us to the library we are going to use for routing; [Redux First Router](https://github.com/faceyspacey/redux-first-router).

Redux First Router gives the most tight-knit integration I have seen between URL and Redux state.  Like Redux Little Router, Redux First Router gives us a branch in our store representing the application’s location.  It also uses actions to push route changes in the application.

Redux First Router though, says goodbye to routing components like `Fragment` and `Router`.  Think it through; if our store contains our router location, why use specialized tools to manage this one area of our state when working with components?

Redux First Router also migrates away from the single `LOCATION_CHANGED` action we saw in Redux Little Router, and instead gives us a mechanism to map specific route patterns to specific dispatched action types using a route map:

``` javascript
const routesMap = { 
  HOME: '/home',      // action <-> url path
  USER: '/user/:id',  // :id is a dynamic segment
}
```

Referring to the example above, requests for `/home` dispatch an action with the type `HOME`, and routes matching `/user/:id` alternatively dispatch an action with type `USER`.

The grants us the flexibility to take appropriate instantiation steps when a user enters our application through one route or another.  For example; a user coming into a `HOME` route probably gets a simple rendering of our application.  A request for a `USER` route might kickoff a complicated series of events; checking access tokens, requesting authenticated content, or redirecting unauthorized users.

None of this is to say we can't do these same things with other routing tools.  However, removing the router state from our component tree allows us to manage these concerns where we manage all our other state concerns; in Redux.  Our components remain simple reflections of state, precisely as they should be.  Moreover, our state remains a single point system of record.

> **Author's Aside:** My introduction of Redux-First-Router is a high-level attempt to explain my choice of router and give contrast to other tools.  For those interested in learning more about Redux-First-Router, I highly recommend a bit of side reading: [Redux-First Router - A Step Beyond Redux-Little-Router](https://medium.com/faceyspacey/pre-release-redux-first-router-a-step-beyond-redux-little-router-cd2716576aea)
    
## Chrome's Redux Extension

We are about to install our first package which dispatches actions of its own to our Redux store.  Until now, we have written all our actions as custom code.  Before leveraging libraries that dispatch their own actions, I think it is worth installing some developer tools to help us monitor our store.

[Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en) allows us to spy on actions dispatched to our store.  The extension provides diffs on each change to our application state and a fantastic ability to time travel through these mutations when debugging.  I find it especially beneficial for spying on a 3rd party actions dispatched by libraries like Redux First Router.  Its use is optional, but I do heartily recommend it.

[Begin by installing the chrome extension](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en).  Then use yarn to complete our in-app setup.  `docker-compose exec client yarn add redux-devtools-extension@2.13.5`.  Finally, we need some changes in our store configuration.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers } from "redux";
+ import { composeWithDevTools } from 'redux-devtools-extension';
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
+   combineReducers({nodes, chapters}), composeWithDevTools()
);

export default store;
```

`redux-devtools-extension` provides us a helper `composeWithDevTools`.  This helper includes store enhancers for the dev tools if the user has the extension installed in their browser.  For users without the extension, `composeWithDevTools` falls back to a standard `compose` method provided by `redux` to ensure our store setup proceeds without issue.

We haven't yet needed to use or discuss middleware, enhancers, or the compose method.  For now, Here's a 10,000-foot summary.  Middleware exists as part of our Redux stack which has visibility over every action dispatched to the store, as well as the store state itself.  

Middlewares handle actions much as reducers do.  A dispatched action can pass through our entire stack of middleware, triggering several operations along the way.  One fundamental difference though is that middleware might be set up to block specific actions on certain conditions.  Alternatively, they might modify an action and pass an updated copy through the remainder of the middleware stack. Middleware can even dispatch entirely new actions as an outcome of other dispatches.  

There is a defined order of operations for middleware; actions process according to the order middlewares were assigned to the store.  
This order of operations allows middleware to perform tasks like debounce actions, manage API communications, validate permissions, and any number of other tasks.  If you want to position code somewhere it can have oversight on any number of dispatched actions; chances are you are entering the territory of middleware.

Enhancers are a more complicated implementation of middleware, and unless you set out to write significant application extensions to Redux itself (such as Redux-DevTools), chances are you will not need to write them.

However, if you understand the positioning of middleware, even in this simplified summary, you can begin to see how Redux Devtools is ideally positioned to "spy" on your store actions.

Now, reload your application in Chrome, and open the extension.

![Redux DevTools With Setup Actions](/images/7/ReduxDevTools.png)

You should see our two setup actions requesting chapters and nodes when the page loads.  You can also inspect the state tree before and after each dispatch.  There's a lot here, take some time to poke around before moving on.

## Configuring Redux-First-Router

Let's get our router installed in our application.  Run in your terminal; `docker-compose exec client yarn add history@4.7.2 redux-first-router@0.0.16-next`.  We again need to modify our store configuration to finish the install.

Our store setup is increasing in complexity, so let's look at this in a few steps.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

+ const history = createHistory();
+ const reducers = combineReducers({nodes, chapters})

const store = createStore(
+   reducers, composeWithDevTools()
);

export default store;
```

First, I am pulling our `combineReducers` function out of our `createStore` call so we can more easily mix in reducers provided by our router.

We have also imported from the `history` package; a dependency of Redux-First-Router.  `history` provides several storage mechanisms to track our router history. We're using `createBrowserHistory`, which leverages the HTML5 history API, and is supported on browsers as old as IE11.   `history` also offers native app solutions (`createMemoryHistory`), as well as legacy browser support (`createHashHistory`) if you ever need them.

Let's jump ahead again.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

const history = createHistory();
+ const routeMap = {
+   // Routes here "ACTION_NAME":"/some/route"
+ };

+ const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers({location: reducer, nodes, chapters});
+ const middlewares = applyMiddleware(middleware);

const store = createStore(
+   reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

We are now making use of `connectRoutes` and an assignment syntax we haven't seen before.  `connectRoutes()` must be passed our history API, and a route map object (which we haven't yet fully defined).  `connectRoutes` returns an object, from which we need to capture several keys: `reducer`, `middleware`, and `enhancer`.  We need all three values to add Redux-First-Router to our store.

Our combine reducer function is getting a new key `location`, to which we are assigning the reducer provided by `connetRoutes`.  I am opting to use the namespace `location` for this area of our state, this is the default suggested by Redux First Router's documentation.

Next, we see our first use of `applyMiddleware()`.  Much like `combineReducers` helps us compile sub-reducers into a single unit, `applyMiddleMiddle` allows us to compile a hierarchy for our middleware.  This function defines the order of operations under which middleware see actions dispatched.  Since we only have one middleware, the point is moot for the moment.

Finally, we see our call to `createStore()` now invoked with `composeWithDevTools(enhancer, middlewares)`.  This function includes all our middleware and store enhancers in our store.  If you are choosing not to run Redux Devtools, you can use `compose()` here instead.

## Defining our first Routes

We can now define our first routes inside the route map.

Right now, I only see a need for two routes:
1. A homepage or index route, which for the time being should display chapter 1 of the book.
2. A route to request specific chapters using a dynamic parameter.

Let's define those in our `routesMap` object.

``` javascript
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  "HOME_ROUTE": "/",
  "CHAPTER_ROUTE": "/chapter/:chapter_id"
};
```

At their most basic, our routes are defined in the form `"ACTION_NAME":"/some/route"`.  They also give us a mechanism for defining dynamic parameters in our routes, such as the use of `:chapter_id` above.

Go ahead and visit your application homepage, and look at the actions fired in the Redux Developer tools.  If we configured everything correctly, you should see an action in your dev tool's history with the type, `HOME_ROUTE`.  Here's what that raw action looks like:

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
  meta: {
    location: {
      current: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

At their simplest, route actions look similar to our custom actions, with a `type`, and `payload` attribute.  We haven't used a `meta` attribute yet; this keyword is often used by Redux middlewares to determine which should operate on each action, and how.  

Here, our meta information contains additional information about our routing: the previous route, the kind of route action, and details about the currently matched route.  It is worth noting that when Redux First Router builds its actions, it carefully preserves other information you might have placed in the `meta` attribute.  Since, as we've mentioned, `meta` is commonly used among middleware, this helps ensure our routing plays nicely with other middleware.

Let's look at a `CHAPTER_ROUTE` as well.  Visit `localhost/chapter/1` in your browser, and review the dispatched actions again.

``` javascript  
{
  type: 'CHAPTER_ROUTE',
  payload: {
    chapter_id: 1
  },
  meta: {
    location: {
      current: {
        pathname: '/chapter/1',
        type: 'CHAPTER_ROUTE',
        payload: {
          chapter_id: 1
        }
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

Anytime we write a dynamic parameter into a route, Redux First Router adds that value to its action payload.  In this case, we defined the name `chapter_id` in our route, so our payload includes `chapter_id: 1` when you trigger the route `/chapter/1`.

## Catching Dispatched Routes

Technically, we could stop there and meet the objectives of our iteration.  We have a marker for the requested chapter in each dispatched route.  Let's look at how these actions influence our state.

``` javascript
{
  location: {
    pathname: '/chapter/1',
    type: 'CHAPTER_ROUTE',
    payload: {
      chapter_id: 1
    },
    prev: {
      pathname: '',
      type: '',
      payload: {}
    },
    kind: 'load',
    routesMap: {
      HOME_ROUTE: '/',
      CHAPTER_ROUTE: '/chapter/:chapter_id'
    }
  },
  nodes: [...],
  chapters: [...]
}
```

Our store preserves all the information included in a dispatched route.  Using `location.payload.chapter_id` we could display the appropriate chapter for each route.  A default chapter value in our component could display chapter 1 as our homepage if a specific value were unavailable in our state.

I am going to forego that approach, and instead set up a different area of our state to store this information. We don't own the object structure for Redux First Router's state, or its dispatched actions.  If we build our application directly on Redux First Router's state, we might have headaches down the line if its storage structure changes in future versions.  Upgrading might require us to weed through many component/containers to align with an unexpected change.  Setting up a state of our own might still require some changes, but they will at least be centralized in one location and easy to access.

Luckily, we can do this is a very Redux first way.

### A Reminder About Reducers

When we introduced reducers, we said dispatched actions pass through all of our reducers.  We haven't made use of this design feature yet, but we are about to.  

Redux First Router supplies its own reducer, and with it, builds its `location` state attribute.  However, router actions still flow through all our other reducers when dispatched.  As a result, we can configure our custom reducers to respond and create any state we need in response to dispatched routes. 

To start us off, let's move our route names to a constants file so that we can import them into other modules of our application.

``` javascript(/client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
```

Next, create a new file `src/reducers/settings.js`, and build out a reducer to own high-level settings of our application state.

``` javascript(/client/src/reducers/settings.js)
import * as constants from '../constants/settings';

let default_state = {};
let default_chapter = 1;

const settingsReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.HOME_ROUTE):
      return Object.assign({},state,{active_chapter_id: default_chapter});
    case(constants.CHAPTER_ROUTE):
      return Object.assign(
        {},state,{active_chapter_id: action.payload.chapter_id}
      );
    default:
      return state;
  }
};

export default settingsReducer;
```

We know Redux First Router dispatches actions with our route names populating the action's TYPE attributes.  So, creating a reducer to catch these actions is no more difficult than any other reducer we have produced.

Above, we defined a variable to store our default chapter.  We then assign that variable to `settings.active_chapter_id` when the `HOME_ROUTE` is triggered.  Otherwise, we pull the active chapter from the payload in our `CHAPTER_ROUTE` actions.

We also need to include our new reducer in our store setup.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import * as routes from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
+ import settings from './settings';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
+   [routes.HOME_ROUTE]: "/",
+   [routes.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers(
+   {location: reducer, settings, nodes, chapters}
+ );

const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

Above, I have transitioned my `routesMap` object to use the constants I defined.  The bracket syntax in our object literal’s attribute names is a new ES2015 syntax.  It allows us to use variable name assignment inside the object literal, and avoid the verbose bracket assignment we have historically been forced to use (`routeMap[routes.HOME_ROUTE] = "/"`).

Reload your application, and use your developer tools to look at your state on the route `/chapter/5`.

``` javascript
{
  location: { ... }
  },
  settings: {
    active_chapter_id: 5
  },
  nodes: [...],
  chapters: [ ... ]
}
```

A similar request for our `HOME_ROUTE` will yield `settings.active_chapter_id == 1`.  I would say we are now ready to plug this into our UI

## Filtering FilteredNodeList

Updating our UI to limit the nodes printed to a single chapter should now be almost trivial.  Open your container for `FilteredNodesList`.

``` javascript(/client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ const filtered_nodes = (nodes, chapter) => {
+   return nodes.filter((node) => { return node.chapter_id === chapter });
+ };

const mapStateToProps = (state) => ({
+   nodes: filtered_nodes(state.nodes, state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

We are adding a `filtered_nodes` function to our container, passing it nodes from our store, as well as the active chapter ID.  This function returns a new Array containing only nodes where `node.chapter_id === store.settings.active_chapter_id`.  

Just like that, revisit your application, and the homepage now shows only our first chapter.  We can also use the `chapter/:chapter_id` routes to display other chapters.

> **Here there be dragons:** Using functions in `mapStateToProps` that produce new instances of our state, such as `Array.filter` is a poor design choice.  This approach causes downstream components to rerender needlessly on **every** dispatched action.  We look at why, and how to fix this is Chapter 16 when optimizing component performance.  However, the flaw is subtle, and I feel obliged to warn you should not emulate the design above in your other projects without incorporating the changes detailed in Chapter 16.

## Configuring Form Controls

Now that we have a filtering mechanism for our nodes, we need to wire in our form controls for chapter selection.

First, we should make preparations for dispatching router actions.  Set up some action creator functions in a file `src/actions/routes.js`.

``` javascript(/client/src/actions/routes.js)
import * as routes from '../constants/settings';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);
```

Here is one more bit of Redux First Router magic.  Open your app's browser console and dispatch one of these new actions to the store.  Inspecting the action in your dev tools, you can see someone performed some heavy lifting for you.  Here is an example of a dispatched `HOME_ROUTE` created using our action creator.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
+   meta: {
+     location: {
+       current: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       prev: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       kind: 'push'
+     }
+   }
}
```

Despite us only populating our action's type, Redux First Router's middleware appended all the additional context information for the route change: the previous page, matched route, and payload.  Dispatch `routeChapter` to your store, and you should see it gets similar treatment.

With action creators prepared, let's update our `ChapterMenuItems` component and its container to leverage these functions.

``` javascript(/client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
+ import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
+   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

We need new props in our connected component.  The first, and most obvious, is our dispatch of `routeChapter`, which I have named `dispatchRouteChapter` above.  This function's signature mirrors the shape of Semantic UI's `onChange` events, sending two parameters when invoked:  an event, and a target object detailing where the action originated.

We can use the target object to carry the value of each menu item (`target.value`) into our dispatched action (in this case, the ID of the specific chapter selected from the menu).

Now let's retool the `ChapterMenuItems` component.  As I do, I am reworking the component to use a simplified implementation of Semantic UI's `Dropdown` component.  Our original implementation used the sub-components `Dropdown.Menu` and `Dropdown.Item`.  However, given the minimal control needed on the component, this now seems like overkill.  Instead, we can use only the top-level `Dropdown` component and pass an options array to populate its menu items.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
+ import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
+   renderChapterOptions = () => {
+     let chapters_list = [];
+     this.props.chapters.forEach((chapter) => {
+       chapters_list.push(
+         { 
+           key: "chapter_" + chapter.id,
+           id:  "chapter_menu_item_" + chapter.id,
+           value: chapter.id,
+           text: chapter.title,
+         }
+       );
+     });
+     return chapters_list;
+   }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
+           onChange={this.props.dispatchRouteChapter}
+           options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Above, `renderChapterOptions` function produces an array of options to populate the menu.  We also updated our `Dropdown` to fire `dispatchRouteChapter` when its `onChange` event is triggered.  With these changes, we have a functioning dropdown that navigates us to selected chapters.  Give the menu a test drive before you move on.  See if you can spot some opportunities for improvement.

## Polishing Our Navigation UI

We have a basic control, but the user experience is lacking.  For one, we don't show the current chapter as active in the dropdown's viewport.   That robs our users of informational cues that could orient them to their location within our application.  To implement this, we need access to our current active chapter inside the component.

There's also a moment after page-load writes this control to the screen where it is nonfunctional.

Without meaning to, I have led you to a beautiful example of why managing API calls from your component's lifecycle methods is problematic.  To be fair, I've mentioned the need to refactor this code ever since we first wrote it.  However, this is an excellent opportunity to demonstrate our problem.

Let's make another round of changes to our container.

``` javascript(/client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
+   active_chapter: state.chapters.find(
+    (chapter) => chapter.id === state.settings.active_chapter_id
+   ),
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Look at our new `active_chapter` prop.  Your containers can do more than map values verbatim into your components.  It would be helpful for our `Dropdown` to have access to both our active chapter's title and ID value.  So rather than simply passing the ID of the active chapter from `settings.active_chapter_id` we are now using that ID to select the full chapter object from our store.

Now update `ChapterMenuItems` to utilize this change.

``` javascripte(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
+           active: chapter.id === this.props.active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
    }
}
```

I now invite you to render this code, **so that you can watch it choke**.  Can you spot what happened?

We never fire an API call to fetch the list of chapters until the first time our component renders.  We also don't dispatch an action to load those chapters into the store until the API call returns.  

That means the first time this component renders, `store.chapters` is guaranteed to be our default `[]` value.  We then attempt to filter that empty array for a specific `chapter.id` id value to populate our `active_chapter` prop.  Searching an empty array of course returns `undefined`, and when our component goes digging in that `undefined` value for `title` and `id` attributes... **BOOM!**

Here's the monkey patch solution.  Update the render function of `ChapterMenuItems` as follows.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderChapterOptions = () => {
-     let chapters_list = [];
-     this.props.chapters.forEach((chapter) => {
-       chapters_list.push(
-         { 
-           key: "chapter_" + chapter.id,
-           id:  "chapter_menu_item_" + chapter.id,
-           value: chapter.id,
-           text: chapter.title,
-          active: chapter.id === this.props.active_chapter.id
-         }
-       );
-     });
-     return chapters_list;
-   }
  
  render() {
+     if(this.props.chapters !== [] && this.props.active_chapter){
+       return( 
+         <Dropdown 
+           tabIndex="1"
+           placeholder="Jump to Chapter..."
+           className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
+           onChange={this.props.dispatchRouteChapter}
+          options={this.renderChapterOptions()} 
+         />
+       );
+     } else {
+       return null;
+     }
  }
}
```

Your components don't need to render anything; they can instead return null.  We can, therefore, short-circuit rendering the dropdown menu if we haven't populated chapters into the store with an if statement.  It's an improvement, but we are still guaranteed a wasted render cycle on this component to dispatch our API calls.  Ideally, we'd begin populating our store earlier in our application's lifecycle, so that we weren't guaranteed this wasted render.  We deal with this long-standing issue in our next chapter.

## Scroll Restoration with Navigation

One more creature comfort I think we need to address is scroll restoration.

You might have noticed this problem while testing our chapter navigation. If you scroll down the page before making a new selection, you load the updated content, but your scrollbar maintains its position.  That is likely not what our users expect, and it might leave them believing our navigation broken.  We should instead ensure users return to the top of the page with each route change, that way they get a cue that their location changed from our chapter titles.

Redux-First-Router provides many modules for its base router.  Scroll restoration is one of them.  Extensions are split into separate packages to minimize installing features that not all user's might need/want.  Go ahead and install support for scroll restoration; `docker-compose exec client yarn add redux-first-router-restore-scroll@1.2.1`.  Then open your store config at `src/reducers/store.js` and make the following changes.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
+ import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
- const routeMap = {
-   // Routes here "ACTION_NAME":"/some/route"
-   [ROUTES.HOME_ROUTE]: "/",
-   [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
- };

const { reducer, middleware, enhancer } = connectRoutes(
  history,
  routeMap,
+   { restoreScroll: restoreScroll() }
);

const reducers = combineReducers(
  {location: reducer, settings, nodes, chapters}
);

const middlewares = applyMiddleware(middleware);

- const store = createStore(
-   reducers, composeWithDevTools(enhancer, middlewares)
- );

export default store;
```

We are now passing an optional parameter to `connectRoutes`, enabling automatic scroll restoration.  Other options would allow us to manually trigger scroll restoration, or trigger it only in response to specific routes.  However, for now, the automatic pattern fits our needs just fine.

## Wrapping Up

We accomplished a lot in this iteration and introduced our first navigation functionality.  We talked through some routing options and settled on the use of Redux First Router.  We also upgraded some of our container components to support this new functionality. 

Testing made it painfully clear we need to address some long-standing issues in our components and API calls.  We do just that in our next chapter, as we introduce Sagas to manage our API interactions.

## What About Tests

I skipped a few test files this chapter for the sake of presenting all our router content in one cohesive stream.  Nothing we introduced this chapter requires a new testing strategy, so feel free to try going through and adding tests yourself for your new reducer and action creators.

I have also included the new tests I created below for those that need help, or just want somewhere to copy/paste form.

``` javascript(/client/src/reducers/settings.spec.js)
/* global expect */
import  settingsReducer from './settings';
import * as actions from '../actions/routes';

let defaultState = {};

describe("Chapter & Home Routes", ()=>{
  test("Assign default chapter of one on HOME_ROUTE", ()=>{
    expect(
      settingsReducer(defaultState,actions.routeHome())
    ).toMatchSnapshot();
  });
  
  test("assign payload chapter on CHAPTER_ROUTE",()=>{
    expect(
      settingsReducer(defaultState,actions.routeChapter(5))
    ).toMatchSnapshot();
  });
});
```

``` javascript(/client/src/actions/routes.spec.js)
/* global expect */
import * as actions from './routes';

describe("Routes actionCreators", ()=>{
  test("routeHome()", ()=>{
    expect(actions.routeHome()).toMatchSnapshot();
  });
  
  test("routeChapter(chapter_id)", ()=>{
    expect(actions.routeChapter(5)).toMatchSnapshot();
  });
});
```