# Chapter 7: Client-Side Routing

We now have a basic UI displaying our book's content, and the beginnings of a navigation system. By completing these features we can cease printing 100% of our book's contents on a single page, and instead select chapters individually for display.  Before proceeding though, we need to think about an area of our state we have so far ignored; the URL bar.

## Getting Started 

If you're starting here or jumping between chapters, I recommended executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch7-starter
```

## Client Side Routing Solutions

React and Redux supprting libraries off many varied approaches to client-side routing; all designed to manage URL state.  

Redux is built on an idea of having a central system of record for your application state.  However, the purity of this concept is disrupted by the intrusion of the browser’s URL bar.  (A somewhat inescapable piece of state for our web applications).  Thanks to search engines and direct links to our sites, we can't predict where a user might enter our application.  Our application **should** respond predictably if multiple users land upon a single URL.

Setting aside the SEO implications of not supporting URL routing in our applications, it's lousy user experience.  Have you ever linked a piece of content only to realize the URL does't represent the content/state you wanted to share when others visit that address?  Very annoying.

We need to meet this user expectation, which means moving from a single-source application state (store) to a divided two-part system (store + URL).

Let's look quickly at a few approaches to solving this problem.

### React Router

[React Router](https://github.com/ReactTraining/react-router) is probably the best-known solution React Routing.  Their approach treats routing as another layer of components in our application.  With React-Router, we use specialized components to conditionally render areas of our application based on the state of our URL bar.

``` javascript
const App = () => (
  <BrowserRouter>
    <div>
+       <Route path="/tacos" component={Tacos}/>
    </div>
  </BrowserRouter>
)
```

In the example above, the `Tacos` component only renders if the route `/tacos` is matched.  

Using React Router, we have an additional layer of components in our rendering tree.  React Router decides which components render in our application based on the state of the URL bar.  Then state within our components can be managed as it would be in a route-free application.  The tradeoff is we need this additional layer of components in our application.

React Router is a common solution, but I would also argue its coupling with Redux is also the most limited.

### Redux Little Router

Several other routers make Redux more of a first-class citizen in the application’s routing.  Most adapt concepts React-Router popularized while trying to tether the overall solution more closely with Redux.

It's hard to pinpoint one clear leader in this realm of blended Redux/React Routing, but I have some experience using [redux-little-router](https://github.com/FormidableLabs/redux-little-router), so let's talk through that quickly.

Redux Little Router brings your URL state into the redux store.  When you install the router, it adds a "router" attribute to your state tree, and reducer to mange it.  When the URL changes in your browser, the application state automatically updates in the store as well.

Similarly, route changes within your application are dispatched as redux actions.  This action-dispatching pattern gives you a familiar interface for managing route changes.  A page change is just an action that happens to update the URL bar and history as a side-effect of a larger state change.

Here is an example `LOCATION_CHANGED` action dispatched by redux-little-router:

``` javascript
// For a URL matching /messages/:user
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: { // if your `history` instance uses `useQueries`
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!'
    parent: { // for nested routes only
      // contains the result of the parent route,
      // which contains each other parent route's
      // result recursively
    }
  }
}
```

Now below, see the resulting change to the `router` attribute in our store that occurs when this action is dispatched.

``` javascript
{
  pathname: '/messages/a-user-has-no-name',
  route: '/messages/:user',
  params: {
    user: 'a-user-has-no-name'
  },
  query: {
    some: 'thing'
  },
  search: '?some=thing',
  result: {
    arbitrary: 'data that you defined in your routes object!',
    parent: { /* the parent route's result */ },
  },
  previous: {
    pathname: '/messages',
    route: '/messages',
    params: {},
    query: {},
    result: {
      more: 'arbitrary data that you defined in your routes object!'
      parent: { /* the parent route's result */ }
    }
  }
}
```

Actions triggering route changes keeps our URL and store as mirrored representations representaitons of a user's location.  When the user requests a route with their browser, Redux Little Router translates that request into a "LOCATION_CHANGED" action and processes it just like any of your custom actions.

I like this approach for testing becasue my "location" is just another branch of our store.  We can mock our location as easily as any other element in our applications state.  

#### Where It Goes a Little Sideways

For all Redux Little Router does to Reduxify your routing, it's feels like a continuation or reimplementation of React Router.

The use of conditional routing components is a central part of Redux Little Router.  This design decision means we're stuck with aspects of React Router that clutter our application's component tree. Redux Little Router gives us a `Fragment` component mirroring React Router's `Route`.

``` javascript
<Fragment forRoute='/about'>
  <div>
    <h1>About</h1>
    <Fragment forRoute='/bio'>
      <div>
        <h2>Bios</h2>
        <Fragment forRoute='/dat-boi'>
          <div>
            <h3>Dat Boi</h3>
            <p>Something something whaddup</p>
          </div>
        </Fragment>
      </div>
    </Fragment>
  </div>
</Fragment>
```

We could argue over how much of a problem this is.  However, problem or not, it is probably not a necessary function of a routing library that's genuinely Redux-first.

It is also a shame that all our location change actions with Redux Little Router use the same `type` attribute, `LOCATION_CHANGED`.  When an action dispatches to our store, it passes through **all** of our reducers.  Any reducer configured for that action’s `type` attribute can update our state in response to the dispatch.  Wouldn’t it be nice then if every route bore a unique type value?  That would allow us to assert fine-tuned control over our state in response to very specific routing events.

### Our Routing Solution: Redux-First-Router

That brings us to the library we are going to use for routing; [Redux First Router](https://github.com/faceyspacey/redux-first-router).

Redux-First-First router gives the most tight-knit integration I have seen between URL and Redux state.  Like Redux Little Router, Redux-First-Router gives us a branch in our store that represents the application’s location.  It also uses actions to push route changes in the application.

Redux-First-Router though, says goodbye to routing components like `Fragment` and `Router`.  Think it through; if our store contains our router location, why use specialized tools to manage this one area of our state when working with components?

Redux First Router migrates away from the single `LOCATION_CHANGED` action we saw in Redux Little Router, and instead gives us a mechanism to map specific route patterns to specific dispatched action types using a route map:

``` javascript
const routesMap = { 
  HOME: '/home',      // action <-> url path
  USER: '/user/:id',  // :id is a dynamic segment
}
```

Referring to the example above, requests for `/home` dispatch an action with the type `HOME`, and routes matching `/user/:id` alternatively dispatch an action with type `USER`.

The grants us the flexibility to take appropriate instantiation steps when a user enters our application through one route or another.  For example; a user coming into a `HOME` route probably gets a simple rendering of our application.  A request for a `USER` route might kickoff a complicated series of events; checking access tokens, requesting authenticated content, or redirecting unauthorized users.

None of this is to say we can't do these same things with other routing tools.  But removing router state from our component tree allows us to manage these concerns where we manage all our other state concerns; in Redux.  Our components remain simple reflections of state, precisely as they should be.  And our state remains a single point system of record.

### Author's Aside

My introduction of Redux-First-Router is a high-level attempt to explain my choice of routers and give contrast to other tools.  For those interested in learning more about Redux-First-Router, I highly recommend a bit of side reading: [Redux-First Router - A Step Beyond Redux-Little-Router](https://medium.com/faceyspacey/pre-release-redux-first-router-a-step-beyond-redux-little-router-cd2716576aea)
    
## Chrome's Redux Extension

We are about to install our first package which dispatches actions of its own to our Redux store.  Until now, we have written all our actions as custom code.  Before leveraging libraries that dispatch their own actions, I think it is worth installing some developer tools to help us monitor our store.

[Redux DevTools](https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd?hl=en) allows us to spy on actions dispatched to our store.  The extension provides diffs on each change to our application state and a fantastic ability to time travel through these mutations when debugging.  I find it especially beneficial for spying on a 3rd party actions dispatched by libraries like Redux First Router.  Its use is optional, but I do heartily recommend it.

Begin by installing the chrome extension with the link above.  Then use NPM to complete our in-app setup.  `docker-compose exec client npm install --save-dev redux-devtools-extension`.  Finally, we need some change in our store configuration.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers } from "redux";
+ import { composeWithDevTools } from 'redux-devtools-extension';
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
+   combineReducers({nodes, chapters}), composeWithDevTools()
);

export default store;
```

`redux-devtools-extension` offers us a helper `composeWithDevTools`.  This helper includes store enhancers for the dev tools if the user has them available, or falls back to a standard `compose` method provided by `redux` if this extension-specific version is not available.

We haven't yet discussed middleware, enhancers, or the compose method.  We do in a future iteration, but for now, Here's a 10,000-foot summary.  Middleware exists in our Redux stack and has visibility on every action dispatched to the store, as well as the store state itself.  

Middlewares handle actions much as reducers do.  A dispatched action can pass through our entire stack of middleware, triggering several operations along the way.  One fundamental difference though is that a middleware might be set up to block specific actions on certain conditions, or they might modify the action and pass an updated copy through the remainder of the middleware stack, or even dispatch entirely new actions as an outcome of another action.

Middleware is used to debounce actions, manage API communications, validate permissions, and perform any number of other tasks.  If you want to position code somewhere it can have oversight on any number of dispatched actions; chances are you are entering the territory of middleware.

Enhancers are a more complicated implementation of middleware, and unless you set out to write significant application extensions to Redux itself (such as Redux-DevTools), chances are you will not need to write them.

However, if you understand the positioning of middleware, even in this simplified summary, you can begin to see how Redux Devtools is ideally positioned to "spy" on your store actions.

Now, reload your application in Chrome, and open the extension.

![Redux DevTools With Setup Actions](/images/7/ReduxDevTools.png)

You should see our two setup actions requesting chapters and nodes when the page loads.  You can also inspect the state tree before and after each dispatch.  There's a lot here, take some time to poke around before moving on.

## Configuring Redux-First-Router

Let's get our router installed in our application.  `docker-compose exec client npm install --save history redux-first-router`.  We again need to modify our store configuration to finish the install.

Our store setup is increasing in complexity, so let's look at this in a few steps.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

+ const history = createHistory();
+ const reducers = combineReducers({nodes, chapters})

const store = createStore(
+   reducers, composeWithDevTools()
);

export default store;
```

First, I am pulling our `combineReducers` function out of our `createStore` call so we can more easily mix in reducers proivded by our router.

We have also importing from the npm `history` package; a dependency of Redux-First-Router.  `history` provides several storage mechanisms to track our router history. We're using `createBrowserHistory` which leverages the HTML5 history API, and is supported on browsers as old as IE11.  But `history` also offers native app solutions (`createMemoryHistory`), as well as legacy browser support (`createHashHistory`) if you ever have need of them.

Let's jump ahead again.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
+ import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import nodes from './nodes';
import chapters from './chapters';

const history = createHistory();
+ const routeMap = {
+   // Routes here "ACTION_NAME":"/some/route"
+ };

+ const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers({location: reducer, nodes, chapters});
+ const middlewares = applyMiddleware(middleware);

const store = createStore(
+   reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

We are now making use of `connectRoutes` and an assignment syntax we have not seen before.  `connectRoutes()` needs our history API, and well as a route map object which we haven't fully defined.  The function returns an object, from which we need to capture several keys: `reducer`, `middleware`, and `enhancer`.  We need all three values to add Redux-First-Router to our store.

Our combine reducer function is getting a new key `location`, to which we are assigning the reducer provided by `connetRoutes`.  I am opting to use the namespace `location`, the default suggested by Redux-First-Router's documentation.

Next we are seeing our first use of `applyMiddleware()`.  Much like `combineReducers` helps us compile sub-reducers into a single unit, `applyMiddleMiddle` allows us to compile a hierarchy for our middleware.  This function defines an order of operations under which middleware see actions dispatched.  Since we only have one middleware, the point in moot for the moment.

Finally, we see our call to `createStore()` now invoked with `composeWithDevTools(enhancer, middlewares)` to ensure all our middleware and store enhancers are included in our store.  If you are choosing not to run Redux Devtools, you can use `compose` here instead.

## Defining our first Routes

We can now turn to defining our first routes inside the route map.

Right now, I only see a need for two routes:
1. A homepage or index route, which for the time being will display chater 1 of the book.
2. A route to request a specific chapters using a dynamic parameter.

Let's define those in our `routesMap` object.

``` javascript
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
  "HOME_ROUTE": "/",
  "CHAPTER_ROUTE": "/chapter/:chapter_id"
};
```

At their most basic, our routes are defined in the form `"ACTION_NAME":"/some/route"`.  They also give us a mechanism for defining dynamic parameters in our routes, such as the use of `:chapter_id` above.

Go ahead and visit your application homepage, and look at the actions fired in the Redux Developer tools.  If everything has been setup correctly, you should see an action in your dev tools history with the type, `HOME_ROUTE`.  Here's what that raw action looks like:

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
  meta: {
    location: {
      current: {
        pathname: '/',
        type: 'HOME_ROUTE',
        payload: {}
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

At their simplest, route actions look similar to our own custom actions, with a `type`, and `payload` attribute.  We haven't used a `meta` attribute yet; this keyword is often used by Redux middlewares to determine which should operate on each action, and how.  

Here, our meta information contains additional information about our routing. The previous route, the kind of route action (`load` in this case), and details about the currently matched route.

It is worth noting that when Redux-First-Router builds its actions, it carefully preserves other information you might have placed in the `meta` attribute  Since, as we've mentioned, `meta` is commonly used among middleware this helps ensure our routing plays nicely with other middleware.

Let's look at a `CHAPTER_ROUTE` as well.  Visit `localhost/chapter/1` in your browser, and review the dispatched actions again.

``` javascript  
{
  type: 'CHAPTER_ROUTE',
  payload: {
    chapter_id: 1
  },
  meta: {
    location: {
      current: {
        pathname: '/chapter/1',
        type: 'CHAPTER_ROUTE',
        payload: {
          chapter_id: 1
        }
      },
      prev: {
        pathname: '',
        type: '',
        payload: {}
      },
      kind: 'load'
    }
  }
}
```

Anytime we write a dynamic parameter into a route, Redux-First-Router adds that value to its action payload.  In this case, we defined the name `chapter_id` in our route, so our payload includes `chapter_id: 1` when you trigger the route `/chapter/1`.

## Catching Dispatched Routes

Technically, could stop there and meet the objectives of our iteration.  We have a marker for the requested chapter in each dispatched route.  We haven't looked at how these actions influence our state.

``` javascript
{
  location: {
    pathname: '/chapter/1',
    type: 'CHAPTER_ROUTE',
    payload: {
      chapter_id: 1
    },
    prev: {
      pathname: '',
      type: '',
      payload: {}
    },
    kind: 'load',
    routesMap: {
      HOME_ROUTE: '/',
      CHAPTER_ROUTE: '/chapter/:chapter_id'
    }
  },
  nodes: [...],
  chapters: [...]
}
```

The information our routes dispatch is also preserved in our store.  Using `location.payload.chapter_id` we could display the appropriate chapter for each route.  A default chapter value in our component could display chapter 1 as our homepage if a specific value was not available in our state.

I am going to forego that approach, and instead set up a different area of our state to store this information. We don't own the object structure for Redux First Router's state or its dispatched actions.  If we build our application directly on its state, we might have a headache down the line if that storage mechanism changes in a later version of the router.  Upgrading might require us to weed through many component/containers to align with an unexpected change.  Setting up a state of our own might still require some changes, but they will at least be centralized in one location and easy to access.

Luckily, we can do this is a very Redux first way.

### A Reminder About Reducers

When we introduced reducers, we said dispatched actions pass through all of our reducers.  We haven't made use of this design feature yet, but we are about to.

Redux First Router supplies its own reducer, and with it, builds its `location` state attribute.

However, router actions still flow through all our other reducers when dispatched.  We can configure custom reducers to respond and create any state we need.  All without interfering with the internal operations of Redux First Router.

Set up a new file `src/reducers/settings.js`, and build out a reducer to own our high-level settings for application state.

``` javascript(/client/src/reducers/settings.js)
import * as constants from '../constants/settings';

let default_state = {};
let default_chapter = 1;

const settingsReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.HOME_ROUTE):
      return Object.assign({},state,{active_chapter_id: default_chapter});
    case(constants.CHAPTER_ROUTE):
      return Object.assign(
        {},state,{active_chapter_id: action.payload.chapter_id}
      );
    default:
      return state;
  }
};

export default settingsReducer;
```

We know Redux First Router dispatches actions with our route name populating the action's TYPE attributes.  So, creating a reducer to catch these actions is no more difficult than any other reducer we have produced.

We can define a variable to store our  default chapter, and assign it to `settings.active_chapter_id` when the `HOME_ROUTE` is triggered.  Otherwise, we pull the active chapter from the payload in our `CHAPTER_ROUTE` actions.

I have set up a constants files for our route names like the pattern we have used in other reducers.

``` javascript(/client/src/constants/settings.js)
export const HOME_ROUTE = "HOME_ROUTE";
export const CHAPTER_ROUTE = "CHAPTER_ROUTE";
```

We also need to include our new reducer in our store setup.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
import createHistory from 'history/createBrowserHistory';

import * as routes from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
+ import settings from './settings';

const history = createHistory();
const routeMap = {
  // Routes here "ACTION_NAME":"/some/route"
+   [routes.HOME_ROUTE]: "/",
+   [routes.CHAPTER_ROUTE]: "/chapter/:chapter_id"
};

const { reducer, middleware, enhancer } = connectRoutes(history,routeMap);

+ const reducers = combineReducers(
+   {location: reducer, settings, nodes, chapters}
+ );

const middlewares = applyMiddleware(middleware);

const store = createStore(
  reducers, composeWithDevTools(enhancer, middlewares)
);

export default store;
```

I have also transitioned my `routesMap` object to use the constants I defined.  The bracket syntax in our object literal’s attribute names is a new ES2015 syntax you may not have seen yet.  It allows us to use variable name assignment inside the literal syntax, and avoid the bracket syntax assignment we have historically been forced to use (`routeMap[routes.HOME_ROUTE] = "/"`).

Reload your application, and look at our state on the route `/chapter/5`.

``` javascript
{
  location: { ... }
  },
  settings: {
    active_chapter_id: 5
  },
  nodes: [...],
  chapters: [ ... ]
}
```

A similar request for our `HOME_ROUTE` will yield `settings.active_chapter_id == 1`.  I would say we are now ready to plug this into our UI

## Filtering FilteredNodeList

Updating our UI to limit the nodes printed to a single chapter should now be almost trivial.  Open your container for `FilteredNodesList`.

``` javascript(/client/src/containers/filtered_nodes_list.js)
import { connect } from 'react-redux';
import NodesList from '../components/nodes_list';

+ const filtered_nodes = (nodes, chapter) => {
+   return nodes.filter((node) => { return node.chapter_id === chapter });
+ };

const mapStateToProps = (state) => ({
+   nodes: filtered_nodes(state.nodes, state.settings.active_chapter_id)
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

We are adding a `filtered_nodes` function to our container, passing nodes from our store state, as well as the active chapter.  The function returns a new Array containing only nodes where `node.chapter_id === store.settings.active_chapter_id`.  

Just like that, revisit your application and the homepage now shows only our first chapter.  We can also use the `chapter/:chapter_id` routes to display other chapters.

  **Here there be dragons:** Using functions in `mapStateToProps` that produce new instances of our state, such as `Array.filter` is poor design.  This method causes downstream components to rerender needlessly on **every** dispatched action.  We look at why, and how to fix this is Chapter 16 when optimizing component performance.  But the flaw is subtle, and I feel oblidged to warn you should not emulate the design above in your other projects without incorporating the changes detailed in Chapter 16.

## Configuring Form Controls

Now we need to wire our form control for chapter selection.

First, we should make preparations for dispatching action.  Set up some action creator functions for our route changes in a file `src/actions/routes.js`.

``` javascript(/client/src/actions/routes.js)
import * as routes from '../constants/setting';

export const routeHome = () => ({type: routes.HOME_ROUTE});

export const routeChapter = (chapter_id) => (
  {type: routes.CHAPTER_ROUTE, payload: { chapter_id }}
);
```

Here is one more bit of Redux First Router magic.  Open your app's browser console and dispatch one of these new actions to the store.  Inspecting the action in your dev tools, you can see someone performed some heavy lifting for you.  Here is an example of a dispatched `HOME_ROUTE` created using our action creator.

``` javascript
{
  type: 'HOME_ROUTE',
  payload: {},
+   meta: {
+     location: {
+       current: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       prev: {
+         pathname: '/',
+         type: 'HOME_ROUTE',
+         payload: {}
+       },
+       kind: 'push'
+     }
+   }
}
```

Despite us only populating our action's type, Redux First Router's middleware appended all the additional context information for the route change: the previous page, matched route, and payload.  Dispatch `routeChapter` to your store, and it gets similar treatment.

Action creators prepared, let's update our `ChapterMenuItems` component and its container to leverage these functions.

``` javascript(/client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
+ import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
+   dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

We need new props in our connected component.  The first, and most obvious, is our dispatch of `routeChapter`, which we have named `dispatchRouteChapter`.  This function's signature mirrors the shape of Semantic UI's `onChange` events which send two parameters when invoked.  A copy of the event itself, and an object detailing the target where the action originated.

We use the target object to carry the value of each menu item (`target.value`) into our dispatched action (in this case, the ID of the specific chapter selected from the menu).

Now let's retool the `ChapterMenuItems` component.  As I do, I am reworking the component to use a simplified implementation of Semantic UI's `Dropdown` component.  Our original implementation used the sub-components `Dropdown.Menu` and `Dropdown.Item`.  However, given the minimal control we need over the component, this now seems like overkill.  Instead, we can use only the top-level `Dropdown` component and pass an options array to populate our menu items.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
+ import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
+   renderChapterOptions = () => {
+     let chapters_list = [];
+     this.props.chapters.forEach((chapter) => {
+       chapters_list.push(
+         { 
+           key: "chapter_" + chapter.id,
+           id:  "chapter_menu_item_" + chapter.id,
+           value: chapter.id,
+           text: chapter.title,
+         }
+       );
+     });
+     return chapters_list;
+   }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
          selectOnNavigation={false}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
  }
}
```

Our `Dropdown` now calls `dispatchRouteChapter` when its `onChange` handler fires.  `renderChapterOptions` function produces an array of options to populate the menu.

We now have a functioning control in our dropdown to change to a specific chapter.  Give it a test drive before you move on.  See if you can spot some opportunities for improvement.

## Polishing Our Navigation UI

We have a basic control, but the user experience is a lacking.  For one, we don't show the current chapter as active in the dropdown's pane.   That robs our users of informational cues that could orient them in our overall navigation schema.  To implement this, we need access to our current active chapter inside our component.

There's also a moment after page-load when our control is written to the screen, but nonfunctional.

Without meaning to, I have led you to a beautiful example of why managing API calls from your component's lifecycle methods is problematic.  To be fair, I've mentioned we need to refactor this code since we first wrote it.  However, this is an excellent opportunity to demonstrate our problem.

Let's make another round of changes to our container.

``` javascript(/client/src/containers/controlled_chapter_menu_items.js)
import { connect } from 'react-redux';

import ChapterMenuItems from '../components/chapter_menu_items';
import { loadChapters } from '../actions/chapters';
import { routeChapter } from '../actions/routes';

const mapStateToProps = (state) => ({
+   active_chapter: state.chapters.find(
   (chapter) => chapter.id === state.settings.active_chapter_id
  ),
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload)),
  dispatchRouteChapter: (event,target) => dispatch(routeChapter(target.value))
});

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

Look at our new `active_chapter` prop.  Your containers can do more than map values verbatim into your components.  It would be helpful for us to have access to both our active chapter's title and ID value.  So rather than simply pass through the ID of the active chapter from `settings.active_chapter_id` we can use that ID to select the full chapter object from our store.

Now update `ChapterMenuItems` to leverage this change.

``` javascripte(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
  renderChapterOptions = () => {
    let chapters_list = [];
    this.props.chapters.forEach((chapter) => {
      chapters_list.push(
        { 
          key: "chapter_" + chapter.id,
          id:  "chapter_menu_item_" + chapter.id,
          value: chapter.id,
          text: chapter.title,
+           active: chapter.id === this.props.active_chapter.id
        }
      );
    });
    return chapters_list;
  }
  
  render() {
      return( 
        <Dropdown 
          tabIndex="1"
          placeholder="Jump to Chapter..."
          className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
          onChange={this.props.dispatchRouteChapter}
          options={this.renderChapterOptions()} 
        />
      );
    }
}
```

I now invite you to render this code, **so that you can watch it choke**.  Can you spot what happened?

We never fire an API call to fetch the list of chapters until the first time our component renders.  We also don't dispatch an action to load those chapters until the API call returns.  

That means, the first time the component renders, `store.chapters` is guaranteed to be our default `[]` value.  We then attempt to filter that empty array for a specific `chapter.id` id value to populate our `active_chapter` prop.  Searching an empty array of course helpfully returns `undefined`, and when our component goes digging in that `undefined` value for `title` and `id` attributes... **BOOM!**

Here's the monkey patch solution.  Update the render function of `ChapterMenuItems` as follows.

``` javascript(/client/src/components/chapter_menu_items.js)
import React, { Component } from 'react';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

export default class ChapterMenuItems extends Component {
-   componentWillMount(){
-     axios.get("/api/chapters")
-     .then(
-       (response) => {
-         this.props.dispatchLoadChapters(response.data);
-       }
-     )
-     .catch(
-       (error) => {
-         console.log(error);
-       }
-     );
-   }
  
-   renderChapterOptions = () => {
-     let chapters_list = [];
-     this.props.chapters.forEach((chapter) => {
-       chapters_list.push(
-         { 
-           key: "chapter_" + chapter.id,
-           id:  "chapter_menu_item_" + chapter.id,
-           value: chapter.id,
-           text: chapter.title,
-          active: chapter.id === this.props.active_chapter.id
-         }
-       );
-     });
-     return chapters_list;
-   }
  
  render() {
+     if(this.props.chapters !== [] && this.props.active_chapter){
+       return( 
+         <Dropdown 
+           tabIndex="1"
+           placeholder="Jump to Chapter..."
+           className="link item"
+           selectOnNavigation={false}
+           value={this.props.active_chapter.id}
+           text={this.props.active_chapter.title}
+           onChange={this.props.dispatchRouteChapter}
+          options={this.renderChapterOptions()} 
+         />
+       );
+     } else {
+       return null;
+     }
  }
}
```

Your components don't need to render anything; they can return null.  We can short-circuit rendering the dropdown menu if we haven't populated chapters into the store with an if statement.  It's an improvement, but we are still guaranteed a wasted render cycle on this component just to dispatch our API calls.  We look at dealing with this long-standing issue in our next chapter.

## Scroll Restoration with Navigation

One more creature comfort I think we need to address is scroll restoration.

You might have noticed this problem while testing our chapter navigation. If you scroll downpage before making a new selection, you load the updated content, but your scrollbar maintains its position.  That is likely not what our users expect, and it might lead them to believe our navigation is broken.  We should ensure users return to the top of the page with each route change.

Redux-First-Router provides many modules for its base router.  Scroll restoration is one of them.  Extensions are split into separate packages to minimize installing features not all user's might need/want.  Go ahead and install scroll restoration; `docker-compose exec npm install --save redux-first-router-restore-scroll`.  Then open your store config at `src/reducers/store.js` and make the following changes.

``` javascript(/client/src/reducers/store.js)
import { createStore, combineReducers, applyMiddleware } from "redux";
import { composeWithDevTools } from 'redux-devtools-extension';
import { connectRoutes } from 'redux-first-router';
+ import restoreScroll from 'redux-first-router-restore-scroll'
import createHistory from 'history/createBrowserHistory';

import * as ROUTES from '../constants/settings';
import chapters from './chapters';
import nodes from './nodes';
import settings from './settings';

const history = createHistory();
- const routeMap = {
-   // Routes here "ACTION_NAME":"/some/route"
-   [ROUTES.HOME_ROUTE]: "/",
-   [ROUTES.CHAPTER_ROUTE]: "/chapter/:chapter_id"
- };

const { reducer, middleware, enhancer } = connectRoutes(
  history,
  routeMap,
+   { restoreScroll: restoreScroll() }
);

const reducers = combineReducers(
  {location: reducer, settings, nodes, chapters}
);

const middlewares = applyMiddleware(middleware);

- const store = createStore(
-   reducers, composeWithDevTools(enhancer, middlewares)
- );

export default store;
```

We are now passing an optional parameter to `connectRoutes`, enabling automatic scroll restoration.  Other options would allow us to manually trigger scroll restoration, or trigger it only in response to certain routes.  However, for now, the automatic pattern fits our needs just fine.

## Wrapping Up

We accomplished a lot in this iteration and introduced our first navigation functionality.  We talked through some routing options available and settled on the use of Redux First Router.  We upgraded some of our container components to support this new functionality. 

We also made it painfully clear we need to address some long-standing issues in our components and API calls.  We do just that in our next chapter, as we introduce Sagas to manage our API interactions.

## What About Tests

I skipped a few test files this chapter for the sake of presenting all our router content in one cohesive stream.  Nothing we introduced this chapter requires a new testing strategy, so feel free to try going through and adding them in yourself if you would like.

I have also included the new tests I created below for those that need help, or somewhere to copy/paste form.

``` javascript(/client/src/reducers/settings.spec.js)
/* global expect */
import  settingsReducer from './settings';
import * as actions from '../actions/routes';

let defaultState = {};

describe("Chapter & Home Routes", ()=>{
  test("Assign default chapter of one on HOME_ROUTE", ()=>{
    expect(
      settingsReducer(defaultState,actions.routeHome())
    ).toMatchSnapshot();
  });
  
  test("assign payload chapter on CHAPTER_ROUTE",()=>{
    expect(
      settingsReducer(defaultState,actions.routeChapter(5))
    ).toMatchSnapshot();
  });
});
```

``` javascript(/client/src/actions/routes.spec.js)
/* global expect */
import * as actions from './routes';

describe("Routes actionCreators", ()=>{
  test("routeHome()", ()=>{
    expect(actions.routeHome()).toMatchSnapshot();
  });
  
  test("routeChapter(chapter_id)", ()=>{
    expect(actions.routeChapter(5)).toMatchSnapshot();
  });
});
```