# Chapter 5: The Client Store

Now that our API is piping back JSON, we can upgrade our client to digest this data.  In this chapter, we configure Redux as our client-side storage for our application's state.

## Installing Redux

We need to do a little setup before we can dive into our client work.

We are going to install Redux, as well as react-redux, which is the official toolkit for using Redux with React.  You can do this with docker-compose, similar working with bundler to install Ruby gems in previous chapters.

Run the following commands in your project root:
```
docker-compose exec client npm install --save redux
docker-compose exec client npm install --save react-redux
```

To start, we must set up our store, and connect it to our React components.  Create a new directory `src/reducers` inside your client folder.  Inside, create a file `store.js`.  This file is to be the root of our Redux installation.

For now, we are going to start small.

``` javascript(/client/src/reducers/store.js)
import { createStore } from "redux";

const store = createStore((state,action) => state);

export default store;
```

Using a method `createStore` provided by Redux, we instantiate a new store.  Inside, we're providing a function as a parameter for the store: `createStore((state,action) => state);`.  

That function is for the moment serving as our reducer.  A reducer, if you are not familiar, is a function that at its simplest takes two arguments; the current state of our store, and an action.  Reducers always return either a **new** state object or the current state object, without alterations.  

This simple function, therefore, meets the criteria of a Reducer, by always returning the unaltered application state.  When we write true reducers, they exist to build an updated application state in response to actions dispatched to our store. 

Let's revisit that concept in a moment, once our store is connected to our React components.

Open `src/index.js` and modify it as follows:

``` javascript(/client/src/index.js)
import React from 'react';
import ReactDOM from 'react-dom';
+ import { Provider } from 'react-redux';
+ import store from './reducers/store';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

+ window.store = store;

ReactDOM.render(
+   <Provider store={store}>
+       <App />
+   </Provider>
  ,document.getElementById('root')
);
    
registerServiceWorker();
```

We are wrapping the `App` component inside a component `Provider`, given to us by react-redux.  Provider makes our `store` available to each of our components.  Not just to the `<App />`, component it wraps directly, but any children it renders, or descendants further down our component tree.

Notice I have also assigned our store to the Browser's `window` object.  This makes our store available for queries in the Browser console, which I find very useful for debugging purposes.

## The Store and Reducers

Now let's revisit reducers.  We said above that a reducer is a function which takes a state and an action and returns a new or unaltered state.  

Let's review what an action is.  Remember from last chapter an action is simply an object with a defined shape; `{type: "SOME_KEY", payload: { some_data: "stuff"}}`.  The type parameter is a unique name for the action inside of our application.  An action's type tells a reducer whether or not it needs to recalculate our application state in response to a dispatched action.  The `payload` of the action should contain all the information needed to do so.

When sending an action to our store (called dispatching), such as: `store.dispatch({type: "SOME_KEY", payload: { some_data: "stuff"}}` the action is passed to our reducer functions. Each reducer checks the value of `type`, and will respond as needed.

While it is possible to house all of our reducer logic in a single function. It's more common though to nest reducers so that several functions each hold ownership over isolated areas of the state.  In our case, that could mean a dedicated reducer function managing the `nodes` key in our state, and another managing our `chapters` key.

When an action dispatches to our store, it is visible to ALL of our reducers, and the `type` attribute dictates which reducer(s) respond, and how.

The action should also contain everything else in the payload that the reducers need to accomplish their work. Our reducers read the current state from our store and then using the action's payload to returns a **new** state for our application.  If the action type is unknown to a particular reducer, then that reducer returns the current unaltered state.

Before we build our first reducer function, let's spend a moment thinking about how to structure our application state.

## Client-Side Data Structure 

In Redux, a client-side data store is really nothing more than a JavaScript object representing our state.

As with our database tables, we need to plan our client-side data structure to support our business rules.  The structure of our store can impact the way we populate, mutate, and access our application state.  There are two design approaches we commonly see; deep structures and broad structures.

Deep structures use nesting of elements to represent their relations.  An example for our purposes might look like the following:

``` javascript
{
  content: [ 
      { chapter_id, title, 
        nodes: [
          { node_id, content},{...}
        ]
      }
      { chapter_id, title,
        nodes: [{...},{...}]
      }
  ]
}
```

Above we have all our chapters grouped into an array of objects.  Nested within each chapter, is an array of its nodes.  The advantage of this approach is the speed of access; if we want to pull all the nodes for a single chapter, we can do so quickly by searching out the chapter, and traversing to its nodes.

But you also add complexity when loading or updating data.  If we wanted to load nodes to our store for several chapters at once we'd need to push updates down several branching paths on our state tree.   Further complicating things, Redux needs us to return a **new** instance of the state, not an update to the old object.  

For these reasons, I tend to favor the use of broad and flat Redux stores like the following:

``` javascript
{
  chapters: [{id, title}, {...}]  
  nodes: [{id, chapter_id, content},{...}]
}
```

With this structure, when loading nodes, we can ignore the `chapters` section of our store entirely.  

Inside each area of our store, our ActiveRecord ID's can be used to enforce the proper content order.   We are also going to ensure our store **enforces** this rule client-side.  When querying the store, we can ensure chapters and nodes are sorted as sequential arrays on these IDs.  Lower level elements like nodes can enforce a multi-level sort, first by their chapter_id, and then the node's own id.  

With those decisions made, let's move forward.

## Building Our First Reducer

Begin by modifying our travel reducer example into something more substantial.   Our first reducer will prepare our store to load book nodes returned from our API.  Our reducer to listen for an action with a type `LOAD_NODES` as the signal for this work.

``` javascript(/reactive-client/src/reducers/store.js)
import { createStore } from "redux";

+ let default_state = {nodes: []};

const store = createStore(
+   function(state = default_state,action){
+     switch (action.type) {
+       case("LOAD_NODES"):
+         return Object.assign({},state,
+         { nodes: action.payload}
+         );
+       default:
+         return state;
+     }
+   }
);

export default store;
```

Our reducer uses a switch statement to listen for actions with the type `LOAD_NODES`.  Using `Object.assign` it then builds a new state object.  The `Object.assign` method merges several object's keys into the object passed as the first argument.  We pass an object literal as the first parameter to ensure we end this process with a new object instance and not update to an existing object.

This pattern of returning of a **new** object is critical to Redux's ability to detect state mutations.  Redux listens for reference changes in our state object.  Rather than doing deep evaluations of equality, if our state's object reference remains unchanged, Redux assumes our state is likewise unchanged.  This is part of what makes Redux so fast, but it also leaves the burden on you to properly produce a new object and by extension, a new reference, when the state **does** change.

Our function definition also changed to assign a default value for the state parameter of our store.

Open your Browser, and load your application at `localhost`.  Let's run some commands in the console.

``` javascript
store.getState();
store.dispatch({type: "LOAD_NODES", payload: [{id: 1, chapter_id: 1, content: "# Some Heading"}]})
store.getState();
store.dispatch({type: "SOME_ACTION", payload: "Some stuff"})
store.getState();
```

This example is why I like to make the store available on the browser's window.  When we add new actions, we can quickly validate our reducer actions by doing some test dispatches to our store.

On the first call to `store.getState()` we see our default returned, including an empty array of nodes.  Then our first dispatched action loads an example node.  Then we dispatch a final action, but the state comes back unaltered since our reducer doesn't respond to the `SOME_ACTION` type.  

That is reducers in a nutshell; we operate on what we understand and own and ignore everything else.

## Combine Reducers 

Things would get unwieldy fast if we needed to manage our entire state from a single reducer in an application of any significant size.  For that reason, redux provides `combineReducers()` to divide our state among specialized sub-reducers.

Below we split off the `nodes` key of our state into an isolated reducer.  Create a new file `reducers/nodes`.

``` javascript(/client/src/reducers/nodes.js)
let default_state = [];

const nodesReducer = function(state = default_state,action){
  switch (action.type) {
    case("LOAD_NODES"):
      return [...action.payload];
    default:
      return state;
  }
};

export default nodesReducer;
```

This an almost straight migration of the reducer we wrote a moments ago.   Our updated default state variable is now an array literal, rather than our previous value `{nodes: []}`.  This change gives clue to what is happening.  Rather than managing the entire state tree, we configuring this reducer to own just one concern, the array of nodes in our book.

As a result, our action `LOAD_NODES` changed.  We no longer return an object, but rather an array of our nodes.  One thing has not changed, we still return new instances of our state rather than updating.  We can do this using the array literal syntax and spread operator to set up a new array with all the nodes from our action payload; `return [...action.payload]`.  

As before, if our reducer doesn't know to handle an action type, it returns an unaltered copy of the state; our existing array of nodes in this example.

Now let's update our `store.js` file to use this new reducer.

``` javascript(/client/src/reducers/store.js)
+ import { createStore, combineReducers } from "redux";
+ import nodes from './nodes';

const store = createStore(
+   combineReducers({nodes})
);

export default store;
```

First, we import our new `nodesReducer()` function as a module under the name `nodes`.  Then update `createStore` to use the `combineReducers` helper, we pass in an Object whose keys include our imported reducer.

Let's revisit the browser console and look at our default state.

``` javascript
JSON.stringify(store.getState())
"{"nodes":[]}"
```

Our default state is back where we started.  The difference now is that our nodes reducer can painlessly operate on the `nodes` array in our state, without needing to be aware of the rest of our state tree.  

But where did the `nodes` key name come from?  That's a small gift of ES2015's object destructing.  When we passed an object to `combineReducers` we didn't specify a key.  The parser then assumes that the name of our variable matches the name we want to assign as the attribute key.  We could have passed `combineReducers({nodes: nodes})` to the same result.

## Domain Specific Reducer Logic

At the start of this chapter, we decided to enforce content order in our reducers.  We can expand our `nodesReducer` to perform this sorting when nodes are added to our state.

``` javascript(/reactive-client/src/reducers/nodes.js)
let default_state = [];

+ export const sortNodes = (nodes) => {
+   return nodes.sort((a,b) =>{
+     if(a.chapter_id === b.chapter_id){
+       return a.id - b.id;
+     } else {
+       return a.chapter_id - b.chapter_id;
+     }
+   });
+ };

const nodesReducer = function(state = default_state,action){
  switch (action.type) {
    case("LOAD_NODES"):
+       return [...sortNodes(action.payload)];
    default:
      return state;
  }
};

export default nodesReducer;
```

We've defined a new function `sortNodes`, which first enforces a sort order on the nodes' chapter_id values, and then performs a secondary sort on the node ID.  As seen before, we use the spread operator to ensure the return value is producing a new array.

One of my favorite aspects of this sub-reducer pattern is defining clear operating areas to store code and manage business rules for specific areas of our state.

## Structuring our Client Project

Now that we have our store and reducer in place, we should set up some other convenience tools for our store.

### Constants Over Strings

Create a new folder `src/constants/` and file `src/constants/nodes.js`.  Inside it place the following:

``` javascript(/client/src/constants/nodes.js)
export const LOAD_NODES = "LOAD_NODES";
```

A constants file gives us a defined list of `type` values for our store.  An action can accept **any** value in its type attribute.  Our store happily returns the current state anytime it doesn't recognize a dispatched action's type.  Thus our store "fails" silently if we pass it "LOAD_NODE", when we actually meant "LOAD_NODES".  Setting up a defined list of constants gives us a limited list of keys to draw from.  If youâ€™re using an IDE that auto-complete variable names, all the better.

Let's update our reducer to use this constants file.

``` javascript(/client/src/constants/nodes.js)
+ import * as constants from '../constants/nodes';

let default_state = [];

- export const sortNodes = (nodes) => {
-   return nodes.sort((a,b) =>{
-     if(a.chapter_id === b.chapter_id){
-       return a.id - b.id;
-     } else {
-       return a.chapter_id - b.chapter_id;
-     }
-   });
- };

const nodesReducer = function(state = default_state,action){
  switch (action.type) {
+     case(constants.LOAD_NODES):
      return [...sortNodes(action.payload)];
    default:
      return state;
  }
};

export default nodesReducer;
```

You might not be familiar with this ES2015 module syntax yet, but it is going to be a big help to us.  The `import * as ...` pattern imports all the exportable items from the referenced file under a namespace.  In our case, all our constants come back under the namespace `constants` and are accessible as chained properties.  

This lets us write nice readable code in our case statements `case(constants.LOAD_NODES)`.

### Action Creators

Now let's turn to our action creators.  Since we use our actions a lot, it helps to have functions that construct these objects for us consistently.  Over time, we might also need to refactor our actions.  If we produce actions from centralized functions, we can update the action creator as needed, rather than chase down every use of that action scattered throughout our application.

Create a folder `src/actions/` and file  `src/actions/nodes.js`, with the following content.

``` javascript(/client/src/actions/nodes.js)
import * as constants from '../constants/nodes';

export const loadNodes = (payload) => ({type: constants.LOAD_NODES, payload});
```

Our new function `loadNodes` takes a payload of information and returns an action.  We are using an ES2015 shortcut in our function definition to return an object literal by wrapping the function body in parentheses `({})`. 

We are further simplifying the syntax by using the key naming shorthand we introduced earlier this chapter.  Without a key name for the `payload` variable we assign into the object, the attribute uses our variable name, in this case `payload`.

The more verbose version of this function would have been.

``` javascript
export const loadNodes = (payload) => {
  return {type: constants.LOAD_NODES, payload: payload}
}
```

Either way, the resulting action has the form needed by our reducer.

## Bringing it All Together

We can now update our `App` component to use our store rather than maintaining its own state.

We are going to do that with the help of the `react-redux` and the `connect` method.  `connect` subscribes our component's properties to our Redux state, and also allows us to dispatch actions to our store from a component.  The connect function itself though has a somewhat usual syntax:

``` javascript
connect(mapStateToProps, actionCreators)(Component)
```

Notice the double parentheses on this function invocation.  This double invocation is needed because the `connect` function will itself return a function, which is then immediately invoked with a component as its argument.  That returned function then constructs a new component whose properties are a merge of your store state, and that component's own properties.  

Let's take a look at by modifying our App Component.

``` javascript(/reactive-client/src/App.js)
import React, { Component } from 'react';
+ import { connect } from 'react-redux';
+ import {loadNodes } from './actions/nodes';
import axios from 'axios';
import logo from './logo.svg';
import './App.css';

+ const mapStateToProps = (state) => ({
+   book_body: state.nodes
+ });

+ const mapDispatchToProps = (dispatch) => ({
+   dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
+ });

class App extends Component {
  componentWillMount(){
    axios.get("/api/nodes")
    .then(
      (response) => {
+         this.props.dispatchLoadNodes(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Reactivating Rails: A work in progress</h2>
        </div>
        <div className="App-intro">
          { this.renderContentBlocks(this.props.book_body) }
        </div>
      </div>
    );
  }
}

+ export default connect(
+   mapStateToProps,
+   mapDispatchToProps
+ )(App);
```

We begin by defining two functions `mapStateToProps` and `mapDispatchToProps`.  As their names imply, these functions map elements of our store state to the wrapped component's properties.

`mapStateToProps` is passed a reference to our store, enabling us to select elements from our state (in this case `nodes`), and map them to the properties of our components.

Similarly, `mapDispatchToProps` is passed a reference to our `store.dispatch` method.  This connection gives our components an easy way to dispatch actions to modify our application state.

Our App component now uses our `loadNodes` action creator to populate our store when our API request completes.  This dispatch replaces the use of our component's `setState`  method we saw previously.

I tend to name my dispatch functions `dispatchActionCreator` to make it clear they trigger dispatches to the store.  So we've defined `dispatchLoadNodes` as a function, requiring a single argument (our nodes array).  When invoked, our action creator produces an action and dispatches it to our store.

Notice that references to `this.state` changed to `this.props` in our component.  This happens because `connect` passes our store state to our components as **props**.   Components can still maintain their own state separate from Redux using `this.state` and the `setState` functions.  This type of dual state is commonly used to divide component level states (is this button active), from the global state (is this user authenticated).  However, anything fed into our components from Redux arrives in our components as props.

Finally, we call connect and pass it our two mapping functions, and the App component itself.  This becomes the new default exportable for our file.

This first component is an admittedly shallow look at what connect does.  When you are comfortable with its basic uses, I strongly recommend a more in-depth investigation.  The creator of Redux, Dan Abramov appeared in a podcast with [Read The Source](https://www.youtube.com/watch?v=VJ38wSFbM3A), to review the internals of react-redux's `Provider` and `connect`.  I highly recommend giving it an hour of your time as his knowledge far exceeds my own.

## Wrapping Up with Some Tests

Before we close out this chapter, our action creators and reducers would benefit from some test coverage.

### Placing Test Files

I prefer to keep my client-side tests in the same directory as the code under test.  It rankles a bit not to consolidate client-side tests into a `spec/` folder like our API.  But Jest, unlike Rails, needs to explicitly import the modules of our application we want to test.  Having the spec files and code in the same directory makes module paths much shorter, and resistant to typos.

### Testing Action Creators

Let's test our action creators, and introduce a new concept; snapshot testing.  Create a file `src/actions/nodes.spec.js`.

``` javascript(/client/src/actions/nodes.spec.js)
/* global expect */
import * as actions from './nodes';

describe("Nodes actionCreators", ()=>{
  test("loadNodes(node)", ()=>{
    expect(actions.loadNodes([{contents: "Test node"}])).toMatchSnapshot();
  });
});
```

Since our action creators are trivial object factories, I prefer to test them with snapshots.  Jest provides us with a helpful method `toMatchSnapshot()` which creates a new directory next to our test file `__snapshots__`, and inside a file named `nodes.spec.js.snap`.  

That snapshot file contains an object map mirroring the output of our first test run.  On later test executions, our expectation checks that our spec result matches this snapshot, and fails if they are not a perfect match.

This feature is particularly helpful when testing objects since snapshots test for deep equality.  There's a balance here though; snapshot tests are dead simple to write.  However, the expectations tested are also fairly dumb.  Wither the test value exactly matches our snapshot or it doesn't.  

For example, look what happens if I add an exclamation point to our spec's content.

``` bash
expect(value).toMatchSnapshot()
    
    Received value does not match stored snapshot 1.
    
    - Snapshot
    + Received
    
     Object {
       "payload": Array [
         Object {
    -      "contents": "Test node",
    +      "contents": "Test node!",
         },
       ],
       "type": "LOAD_NODES",
     }
```

A one character change fails our test. It's up to you to review the diff produced by the failed test and determine if the was change a critical failure, or if the snapshot should be updated.  However, since I only need to be alerted if something changes my action creator's output, a snapshot test is ideal.

## Testing your Reducers

Let's test our reducer next.  Create a new file `src/reducers/nodes.spec.js`.  

``` javascript(/client/src/reducers/nodes.spec.js)
/* global expect */
import  nodesReducer, { sortNodes } from './nodes';
import * as actions from '../actions/nodes';

let defaultState = [];
let newState = [{contents: "Test node"}];

describe("nodes Reducer", ()=>{
  test("LOAD_NODES overwrites nodes array",()=>{
    expect(nodesReducer(defaultState,actions.loadNodes(newState))).toEqual(newState);
  });
});
```

Since reducers are simply functions testing is uncomplicated.  We can test their outcomes in isolation by passing in a starting state value and an action.

To test our "LOAD_NODES" action, we define a default state and expected state for our test.  Then using our action creator, we "dispatch" the action by passing it directly to the function, so we can test its outcome.

We should also test our sort function.  Let's set up some sample data for our test, and use a snapshot again to check our expectations.

``` javascript(/reactive-client/src/reducers/nodes.spec.js)
/* global expect */
import  nodesReducer, { sortNodes } from './nodes';
import * as actions from '../actions/nodes';

let defaultState = [];
let newState = [{contents: "Test node"}];
+ let sampleNodes = [
+   {id: 4, chapter_id: 2, node_type: "paragraph", content: "Fourth"},
+   {id: 3, chapter_id: 2, node_type: "paragraph", content: "Third"},
+   {id: 7, chapter_id: 1, node_type: "paragraph", content: "Second"},
+   {id: 6, chapter_id: 1, node_type: "paragraph", content: "First"}
+ ];

describe("nodes Reducer", ()=>{
+   test("nodesSort orders by chapter id and then node id", ()=>{
+     expect(sortNodes(sampleNodes)).toMatchSnapshot();
+   });
  
-   test("LOAD_NODES overwrites nodes array",()=>{
-     expect(nodesReducer(defaultState,actions.loadNodes(newState))).toEqual(newState);
-   });
});
```

This is where snapshot tests excel.  We have many expectations about sort order boiled into a single test.  We can review the snapshot once, then forget about it and move on, trusting our snapshot to alert us if something changes.

``` javascipt
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`nodes Reducer nodesSort orders by chapter id and then node id 1`] = `
Array [
  Object {
    "chapter_id": 1,
    "content": "First",
    "id": 6,
    "node_type": "paragraph",
  },
  Object {
    "chapter_id": 1,
    "content": "Second",
    "id": 7,
    "node_type": "paragraph",
  },
  Object {
    "chapter_id": 2,
    "content": "Third",
    "id": 3,
    "node_type": "paragraph",
  },
  Object {
    "chapter_id": 2,
    "content": "Fourth",
    "id": 4,
    "node_type": "paragraph",
  },
]
`;
```

Finally, let's look at `src/app.test.js` which is failing since we wrapped our App component in `connect()`.

```
Invariant Violation: Could not find "store" in either the context or props of "Connect(App)". Either wrap the root component in a <Provider>, or explicitly pass "store" as a prop to "Connect(App)".
```

Luckily, the error message makes the problem pretty explicit.  the `connect` method expects a `store` to be available, either from a wrapping `Provider` element or set as a property of the component.  Passing store directly as a prop requires us to also pass that property to any child components we later render from App.  So I opt to let Provider do our heavy lifting.

``` javascript(/reactive-client/src/App.test.js)
import React from 'react';
+ import {Provider} from 'react-reduax';
import ReactDOM from 'react-dom';
import store from './reducers/store';
import App from './App';

it('renders without crashing', () => {
  const div = document.createElement('div');
+   ReactDOM.render(<Provider store={store}><App /></Provider>, div);
});

```

There are still some console errors in my test suite where we haven't correctly mocked out our API calls.  However we'll be removing these API calls from our components soon, so I am unconcerned with these messages for the moment.

## Finishing Up

Redux is set up, and we are ready to handle more complex states in our client.  In chapters 4 and 5 we set a lot of foundation; it might occur to you we've now spent two chapters of our time to end where we started.  

The good news is, most of the prep work is behind us, and we are ready to make significant changes to our application.  However, it is worth noting the cost of configuring Redux.  In complex applications, the benefits of Redux come from having a centralized point to manage your application state.  Just be sure you have enough state to justify the cost of setup.

In chapter 6 we're going to introduce a layout for our application, and introduce our first custom React components.  See you there.