# Chapter 5: Layout with React & Redux

We've resisted the urge to focus on our UI for the first 4 chapters while we setup some internals for our application.  With most of the scaffolding in place, I think we deserve to spend an iteration making our application look more like a real piece of software and less like a raw code dump to the screen. 

In this chapter we'll be using Semantic UI for some rapid layout prototyping. Refactoring our now very bloated `App.js` component into more manageable units.  Cleaning up our book’s node content rendering.  And introducing a chapters data model to our client application.

## Semantic UI, Up and Running

There are no shortages of rapid prototyping libraries available to us in the React sphere.  Most notably we have component libraries for Material-UI, Semantic-UI, and Bootstrap, to say nothing of the I’m sure dozen or so more I’m not even aware of.  

All have their pros and cons, though my personal preference (and it is just that), leans towards Semantic and Material UI.  I've been a longtime user of bootstrap in my Rails applications.  However, the React component migrations of the Bootstrap library have always felt like a monkey patch to me.  Bootstrap has always been very reliant of CSS classes to carry a large share of the formatting.  And in the React world, where we tend to focus on self-contained and composable components, the migration of bootstrap has never lined up for me.

Semantic UI, and Material UI both feel like natural extensions to React.  I tend to favor Material UI for smaller scale UIs (such as mobile screens, or browser extensions).  But I favor Semantic when I intend to support larger desktop UIs.  So, we'll be using Semantic for this projects.

Installing is a snap...

```
npm install semantic-ui-react --save
```

We'll also need to include the CSS assets for Semantic into our project.  The docs for Semantic give us several approaches for this, but since I don't intend to do any custom theme work for the moment, I'm going to opt for the easiest install method.  That is, referencing the CSS files from a CDN.  To do so, add the following to `public/index.html`

```
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/semantic-ui/2.2.12/semantic.min.css"></link>
```

Now we're ready to get started.

## Scaffolding a Layout

When I'm laying out a new section of a React application I like to do all my work in one file before I start thinking about how I'm going to split out my components.  I find this lets me better decide where the logical cuts are between my components.  With that in mind, let's make some temporary changes in our App component to get us started.

We're going to lay the groundwork for our first bit of navigation.  We'll create a placeholder for a control that will allow our readers to flip between chapters.  We're going to be adapting a layout starter provided on the Semantic UI website.  I'm not qualified to make design decisions without adult supervision, so this will help us get a little guidance from professionals.

Open your `src/App.js` file and let's get to work.  This file is getting a little long in the tooth (though we'll be fixing that in just a few short sections), so I've removed some of our code from previous sections to better highlight the changes we are making now.

``` javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import axios from 'axios';
import {loadNodes } from './actions/nodes';
import reactLogo from './assets/images/react-logo.svg';
import railsLogo from './assets/images/rails-logo.svg';
import './App.css';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

// Redux map functions

class App extends Component {

  //API Call for LOAD_NODES
  
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
        <div id="reader-pane">
          <Container text>{ this.renderContentBlocks(this.props.book_body) }</Container>
        </div>
      </div>
    );
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App);
```
First, some quick housekeeping; we've moved our image files into an `assets/images` directory.  I've also taken a Rails logo from the Rails project website too.  We'll fly under these React/Rails logos as a placeholder for the moment.

The rest of the additions fall into 2 categories: components provided to us by Semantic-UI, or style objects to alter their presentation.  The Semantic UI project is large, and I can't tackle the scope of documenting these components in this book. Beyond that, documentation on these items is already available and exceptional on [the Semantic-UI React Website](https://react.semantic-ui.com).  I'll be diving deep on a few of the APIs we need to make heavy use of.  But for presentation items, please supplement from the official documentation as you find helpful.

Luckily most of the Component names from Semantic UI are, well... semantic.

### Some Thoughts on Styles

At the top of our altered file we're also defining several JavaScript style objects.  There are many ways to style React components, from inline styles, to style objects, to traditional stylesheets.  

My opinion is going to assert itself again here; but I'm still not entirely sold on the idea of abandoning traditional external CSS stylesheets.  But the lines between presentation, structure, and behavior inside React, and really any front-end library are already blurred.  So, it's hard to argue that externalizing all our style information into CSS is an imperative.  Moreover, there's a real advantage to be had for reusability in keeping our styles close to our components.

Setting up our component styles as constants in our components is my compromise.  It allows us to centralize our styles in one spot for each component.  And the constants can be reused similar to how we would CSS classes.  And if we need to reuse style beyond a single component, we can make them exportable.

### Inline Style Syntax

If you haven't used JavaScript styles before, the syntax is easy to wrap your head around.  If you're already familiar with the traditional CSS style names, the transition is easy.

Hyphenated names drop the hyphen, in favor of camel case name.  So `padding-left`, becomes `paddingLeft`.  Values for styles can be passed as integers in some cases, but when you want to pass specific units for a value, such as `"5px"` you can rely on string value.

With the change to our `App.js` component in place, let's check our rendering.

![Semantic-UI Reworked Application Layout](/images/5/SemanticUILayoutRework.png)

## Slicing Up Components

It is now at long last time for an overdue refactor to our App component!

We've got a **lot** going on in this one component.  We're making API calls.  Managing a connection to our store.  Building an entire Layout.  And making a fairly detailed data selection as we render our list of nodes.  Now that we have a solid foundation set, we can start making some more thoughtful decisions about how we separate these tasks.

### Container Components

Let's start with a look at our node rendering code.  Since we have the API side of the work complete(ish) for this section of content we can begin there.

Let's create two new directories in our client project `src/components` and `src/containers`.

Now let's set up a file `src/components/reader_pane.js`.  Inside we'll set up a new component, and migrate over some code from `App.js`.

``` javascript
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div id="reader-pane">
        <Container text>{ this.renderContentBlocks(this.props.book_body) }</Container>
      </div>
    );
  }
}

export default ReaderPane;
```

This is about as simple as we can make a React Component.  We're going to externalize the bit of styling around our reader's viewport into it's own components.  This way we can split out some of the logic around rendering our nodes from the App component, and also make our markup more readable.  Now when we call this code in our App component, it will have the more readable name `ReaderPane` to better describe what we're actually rendering. At least more effectively than some divs and assorted HTML tags can.

Let's look at what our App component would look like with this change.

``` javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import reactLogo from './assets/images/react-logo.svg';
import railsLogo from './assets/images/rails-logo.svg';
import ReaderPane from './components/reader_pane';
import './App.css'

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

// Redux map functions

class App extends Component {
  //API Call for LOAD_NODES
  
  renderContentBlocks = (content) => {
    let content_blocks = [];
    content.forEach((block) => {content_blocks.push(<p key={content_blocks.length}>{block.content}</p>)});
    return content_blocks;
  }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
        <ReaderPane book_body={this.props.book_body} />
      </div>
    );
  }
}

export default connect(
  mapStateToProps,
  mapDispatchToProps
)(App);
```

A step in the right direction... but I still see at least two problems.  

For one thing, we're relying on a property "book_body" to be passed into the component when it's rendered.  That may or may not be clear from the outside.  What definitely is clear, is that our **App** Component doesn't really have any business orchestrating what nodes get rendered.  Right now, it's not really a problem, because we're doing a wholesale printing of the entire book.  But what does this start to look like when we only want to print one chapter, or a few sections to the screen at once?

Let's set ourselves a better foundation for handling this process in the future, and reap some extra cleanup now while we are at it.

### React Containers

Let's create a new component, `src/components/nodes_list.js`.  Setup the file as follows.

``` javascript
import React, { Component } from 'react';

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {nodes_list.push(<p key={node.id}>{node.content}</p>)});
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

We're setting up our new NodesList to have one task; it will receive a list (array) of nodes, and happily print them for us.  We're also taking this time to update some of our variable names around the "node" concept we defined in our API, and dropping the use of terms like `book_contents` we were using in the wild-west day of chapters 1 and 2.

This step will let us remove the node looping/printing logic from the `ReaderPane` component.  But we still haven't solved the problem of needing to pass in an attribute manually to render our list of nodes.  We just moved it downstream.  

That's where containers come in.  React convention is to make a distinction between components that mange state, and those that simply handle presentation.  In the case of Redux, that means giving a certain level of prestige to the components we connect to the store.  It's about separating the logic centers of our application from the presentational elements.

Go ahead and create another file `src/containers/filtered_nodes_list.js`.  

``` javascript
import { connect } from 'react-redux';
import NodesList from './components/nodes_list';

const mapStateToProps = (state) => ({
  nodes: state.nodes
});

export default connect(
  mapStateToProps,
  null
)(NodesList);
```

Remember when we discussed the connect function in chapter 4, we said that connect returns a function that itself gets invoked by passing in another component?  We're about to see that magic in action, when we call a component we've never technically defined, `FilteredNodeList`.

mapStateToProps is going to solve the need for us to manually pass around our nodes property on our components.  Instead, we'll let our new container fetch them from the store.  Then the returned list of nodes will be merged with any other properties we manually tag to the component we pass into `connect()`, and we'll be free to let that wrapped component (`NodeList`) handle the details of rendering content.

We technically could have wrapped our `NodeList` component in the same module where we handle the rendering, and our result would be the same.  However, splitting our connect/container code into its own module/file gives us another layer of separation between how we choose what to render, and how what we render looks and behaves.  As we start adding complexity to what we choose to print, I think we'll appreciate this separation.

### ReaderPane Reassembled

Let's now turn back to our `ReaderPane` component and pull this all together.  As we do though, remember that I said we saw two problems?  Right now, we're simply calling `<ReaderPane />` as a static block of code and trusting it to print what we want.  But what if we want to reuse this component again, to print something other than our nodes?  We're stuck.  We can fix that by setting up `ReaderPane` to expect child elements to be passed to it. We'll do this using the `children` property to access elements passed via JSX nesting, rather than hard wiring the rendering of our Nodes.

``` javascript
import React, { Component } from 'react';
import { Container } from 'semantic-ui-react';

class ReaderPane extends Component {
  render() {
    return (
      <div id="reader-pane">
        <Container text>
        { this.props.children }
        </Container>
      </div>
    );
  }
}

export default ReaderPane;
```

And finally, let's pull it all together in `App.js`.  Shown this time in full form so you can see the progress we've made.  Pay attention to our use of the `ReaderPane` component and `FilteredNodeList`.  It's also worth pointing out we've removed the `mapStateToProps` from `App.js`.  Now that we have our `FilteredNodeList` container managing the connection of that part of our store we don't need it in App any longer.  We're passing `null` through the connect function instead so that our `mapDispatchToProps` function populates the right parameter of our connect function.

``` javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import reactLogo from './assets/images/react-logo.svg';
import railsLogo from './assets/images/rails-logo.svg';
import './App.css'

import ReaderPane from './components/reader_pane';
import FilteredNodesList from './containers/filtered_nodes_list';


const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
});

class App extends Component {
  componentWillMount(){
    axios.get("/api/nodes")
    .then(
      (response) => {
        this.props.dispatchLoadNodes(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  render() {
    return (
      <div id="app">
        <Menu
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
        <ReaderPane>
          <FilteredNodesList />
        </ReaderPane>
      </div>
    );
  }
}

export default connect(
  null,
  mapDispatchToProps
)(App);
```

## Moving Towards Navigation

Let's split out our Menu bar into its own component as well so we can begin to isolate our navigation elements.

Create a new file `src/components/menu_bar.js`, and migrate the menu setup from our main layout.

``` javascript
import React, { Component } from 'react';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <Dropdown text='Jump to Chapter...' pointing className='link item'>
                <Dropdown.Menu>
                  <Dropdown.Item>List Item</Dropdown.Item>
                  <Dropdown.Item>List Item</Dropdown.Item>
                </Dropdown.Menu>
              </Dropdown>
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```
And again, you can trim down `App.js` to accommodate this new component.

``` javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import {loadNodes } from './actions/nodes';
import axios from 'axios';
import './App.css'

import ReaderPane from './components/reader_pane';
import MenuBar from './components/menu_bar';
import FilteredNodesList from './containers/filtered_nodes_list';

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadNodes: (payload) => dispatch(loadNodes(payload))
});

class App extends Component {
  componentWillMount(){
    axios.get("/api/nodes")
    .then(
      (response) => {
        this.props.dispatchLoadNodes(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  render() {
    return (
      <div id="app">
        <MenuBar />
        <ReaderPane>
          <FilteredNodesList />
        </ReaderPane>
      </div>
    );
  }
}

export default connect(
  null,
  mapDispatchToProps
)(App);
```

## Spinning up New Endpoints

We've come to a point where we're ready for a new API endpoint.  Before we can move on with navigation and creating an ability to move between chapters, we need to first load that associated content from our API.  Let's run through that now to refresh what we've covered in the first few chapters without all the interruptions to install and configure new packages.

My hope is this exercise will give you an appreciation of how easy all this foundational work makes development once the pieces are in place.  Since we're already working client-side, let's start there. 

### Client Setup, Round 1 (Fight!)

First, let's define the new action we're going to build support for in a constants file, `src/constants/chapters.js`.

``` javascript
export const LOAD_CHAPTERS = "LOAD_CHAPTERS";
```

Then, let's create an action-creator in `src/actions/chapters.js`.

``` javascript
import * as constants from '../constants/chapters';

export const loadChapters = (payload) => ({type: constants.LOAD_CHAPTERS, payload});
```

The format of expecting our API to pass back an array of elements seems to be working well with our Nodes, so we'll use the same pattern with our loadChapters action creator.  We should setup a snapshot test though so that we at least get an alert if there's a major structural change to this FSA.  Setup `src/actions/chapters.spec.js` as follows.

``` javascript
/* global expect */
import * as actions from './chapters';

describe("Chapters actionCreators", ()=>{
  test("loadChapters(chapters)", ()=>{
    expect(actions.loadChapters([{contents: "Test chapter"}])).toMatchSnapshot();
  });
});
```

And finally, prep our reducer to handle this action.  Since we'll want our chapters to be stored under a different key in our store, we should setup a new sub-reducer for that namespace in `src/reducers/chapters.js`.

``` javascript
import * as constants from '../constants/chapters';

let default_state = [];

export const sortChapters = (chapters) => {
  return chapters.sort((a,b) =>{
    return a.id - b.id;
  });
};

const chaptersReducer = function(state = default_state,action){
  switch (action.type) {
    case(constants.LOAD_CHAPTERS):
      return [...sortChapters(action.payload)];
    default:
      return state;
  }
};

export default chaptersReducer;
```

This should look very similar to our nodesReducer function, and the load action there.  The only major change being the simplified sort function since we do not need a multi-level sort on our chapters.  The amount of overlap here is likely indicative that we have some opportunity to refactor and dry up this code.  But given the small amount of code we're talking about, I'm content to let this ride until it becomes a problem.

Let add some test coverage here as well by setting up `src/reducers/chapters.spec.js`.

``` javascript
/* global expect */
import  chaptersReducer, { sortChapters } from './chapters';
import * as actions from '../actions/chapters';

let defaultState = [];
let newState = [{title: "Test chapter"}];
let sampleChapters = [
  {id: 7, title: "Second"},
  {id: 8, title: "Third"},
  {id: 6, title: "First"}
];

describe("chapters Reducer", ()=>{
  test("sortChapters orders by id", ()=>{
    expect(sortChapters(sampleChapters)).toMatchSnapshot();
  });
  
  test("LOAD_CHAPTERS overwrites chapters array",()=>{
    expect(chaptersReducer(defaultState,actions.loadChapters(newState))).toEqual(newState);
  });
});
```

Be sure to look at the generated snapshot for your sortChapters function before you move on!  Testing against a bad snapshot won't do you a bit of good.

Don't forget to add the new sub reducer to your `combineReducers` function in `src/reducers/store.js`.

``` javascript
import { createStore, combineReducers } from "redux";
import nodes from './nodes';
import chapters from './chapters';

const store = createStore(
  combineReducers({nodes, chapters})
);

export default store;
```

At this point, I'd probably jump into the browser console and do a quick check to make sure everything is wired in correctly.  We should have a new key `chapters` in our store, with a default state of `[]`.  And the store should accept a dispatch of `LOAD_CHAPTERS`, and update our array.

![Test dispatches](/images/5/TestDispatches.png)

It look like we are prepped to receive new data from the API.  Let's change gears and switch back to our Rails application.

### Chapters from our API

Let's start by defining a route for the new action.  As we did with nodes, defining our route as an index action seems to make the most sense for the task at hand.

``` ruby
Rails.application.routes.draw do
  namespace :api do
    get 'nodes/', to: "nodes#index"
    get 'chapters/', to: "chapters#index"
  end
end
```

Then we'll need a matching chapters controller, so let's create a new file `app/controllers/api/chapters_controller.rb`.  We don't have an `fsa` scope defined on our Chapter model yet, but I like that pattern for accessing model data, so let's write our controller on the assumption we'll be adding one in just a moment.

``` ruby
class Api::ChaptersController < ApplicationController
  def index
    payload = Chapter.all.fsa
    render json: payload, status: 200
  end
end
```

And now we can drop into our model to build out that scope.  For now, all I am anticipating needing client-side for our Chapter model is the title and ID.

``` ruby
class Chapter < ApplicationRecord
    has_many :nodes
    
    scope :fsa, -> { order(id: :asc).select(:id, :title) }
end
```

Now, just as we did a quick smoke-test in browser for the client side of this iteration, we can do a similar test API-side using curl.  (Your host information will vary)

```
curl http://138.197.14.5:8080/api/chapters

[{"id":1,"title":"Chapter 0: Introduction"},{"id":2,"title":"Chapter 1: Installing React and Rails"},{"id":3,"title":"Chapter 2: Loading and Displaying Basic Content"},{"id":4,"title":"Chapter 3: Organizing Data"},{"id":5,"title":"Chapter 4: The Client Store"}]
```

If you get back an Array of chapter elements, then we are in good shape.  Back to the client for the finishing touches.

### Calls and Containers

For the moment, we're going to be defining another API call for fetching chapters in a new container component in our client.  I don't love, or really want to advocate this approach, but for the purpose of moving us forward, we're going to continue this pattern.  Externalizing these API calls is one of the last things we need to do to clean up our components, and we'll be discussing a strategy for doing that in a coming chapter using Redux Saga.  

For now, bear with me, and know that this is not an ideal way to handle this problem when making API calls of any complexity.

Create a new file `src/containers/chapter_menu_items.js`.  We're going to take a different approach to our container this time, and have it directly render content, rather than having it wrap another component.  The difference here is I can't imagine needing to reuse this component anywhere else in our application.  I'm also not expecting much complex logic to be needed around what gets rendered.  So, I'm comfortable with the store connection and presentation being contained in a single component.

``` javascript
import React, { Component } from 'react';
import { connect } from 'react-redux';
import { Dropdown } from 'semantic-ui-react';
import axios from 'axios';

import { loadChapters } from '../actions/chapters';

const mapStateToProps = (state) => ({
  chapters: state.chapters
});

const mapDispatchToProps = (dispatch) => ({
  dispatchLoadChapters: (payload) => dispatch(loadChapters(payload))
});

class ChapterMenuItems extends Component {
  componentWillMount(){
    axios.get("/api/chapters")
    .then(
      (response) => {
        this.props.dispatchLoadChapters(response.data);
      }
    )
    .catch(
      (error) => {
        console.log(error);
      }
    );
  }
  
  renderChapterMenuItems = (chapters) => {
    let chapters_list = [];
    chapters.forEach((chapter) => {
      chapters_list.push(
        <Dropdown.Item key={"chapter_" + chapter.id} id={chapter.id}>{chapter.title}</Dropdown.Item>
      );
    });
    return chapters_list;
  }
  
  render() {
    return (
      <Dropdown text='Jump to Chapter...' className='link item'>
        <Dropdown.Menu>
          { this.renderChapterMenuItems(this.props.chapters) }
        </Dropdown.Menu>
      </Dropdown>
    );
  }
}

export default connect(mapStateToProps,mapDispatchToProps)(ChapterMenuItems);
```

This single component contains most of the tools we've worked with thus far, if you’re comfortable with this code that’s a good sign you’re keeping up with the concepts we’ve covered.  And remember you'll need to update your `MenuBar` component as well to account for this new container.

``` javascript
import React, { Component } from 'react';
import { Container, Dropdown, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

import ChapterMenuItems from '../containers/chapter_menu_items'

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
};

const tightItem = {
  paddingLeft: "5px",
  paddingRight: "5px"
};

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container>
            <Menu.Item style={tightItem}><Image size='mini' src={reactLogo} /></Menu.Item>
            <Menu.Item style={tightItem}><Image size='mini' src={railsLogo} /></Menu.Item>
            <Menu.Item style={tightItem} header>Reactivating Rails: A work in progress</Menu.Item>
    
            <Menu.Menu position='right'>
              <ChapterMenuItems />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

And that's it, we're up and running with our chapters content.  Granted, that nice new menu doesn't **do** anything yet.  Before we do that, we need to talk about one area of application state we've ignored thus far; the URL bar.  And for that, we'll need to setup a client-side router.  

Before that though, there's one last thing I just can't resist taking a first pass at...

## Client Side Markdown

We've put a bit of effort into the look and feel of our application now.  And the Raw markdown showing through in our nodes is now beginning to bum me out.  So, before we move into the wonderful world of routing, let's take a pass at an initial markdown parser for our client.

If we get it installed now, we can noodle over how well the out-of-the-box behavior of our parse treats us.  Then decide what, if anything we might want to improve in future iterations.

I'm going to take the first pass using a package I found called [MarkdownIt](https://github.com/markdown-it/markdown-it).  It has an easy syntax and configuration process, and appears to be fairly extensible if needed.

To setup, we'll need to first install with NPM, `npm install markdown-it --save`.

Then, let's turn to our `NodesList` component.

``` javascript
import React, { Component } from 'react';
import MarkdownIt from 'markdown-it';
const md = new MarkdownIt();

class NodesList extends Component {
  renderNodes = (nodes) => {
    let nodes_list = [];
    nodes.forEach((node) => {
      nodes_list.push(
        <p key={"node_" + node.id} dangerouslySetInnerHTML={{__html: md.render(node.content)}} />
      );
    });
    return nodes_list;
  }
  
  render() {
    return (
      <div id="nodes_list">
        { this.renderNodes(this.props.nodes) }
      </div>
    );
  }
}

export default NodesList;
```

We're making a quick modification to `NodesList` to leverage Markdownit’s rendering as we loop through our nodes.  We've updated our generated paragraph tags to use the `dangerouslySetInnerHTML` prop.  As the name suggests, there is some danger involved with this approach.  By default, React/JSX are going to escape contents when we render a string within an element.  So our HTML tags will literally print out to the screen `<p>some content....`.  

That's not ideal for our use case.  The name of `dangerouslySetInnerHTML` is purposely meant to be frightening, because we should be very thoughtful about where and when we use it.  By disabling the automatic escaping on elements, we are opening our application up to Cross Site Scripting (XSS) attacks.  Loading content from an unsafe source could lead to your application rendering and executing malicious code, such as harm scripts.

Since we control the only API endpoint we're rendering, I believe this is an acceptable level of risk.  But should we ever need to render external contents we don't control we'll need to evaluate this again.

With these changes made, let's check out our rendering!

![Updated layout with basic markdown rendering](/images/5/MarkdownBasicRender.png)

Not bad for such a minimal bit of work!  There are some immediately apparent problems though.  First off, all our automatically generated image links are broken.  The local file paths expect our images to be located at `/images/...`, off our client server's address.  However, we need to remember that in production, everything will be managed by our Rails application server.  Therefore, we should move the images into `app/public/images/...` so that we are production ready.  In development, our request proxy will go looking for images there as well once they are not found on the client.

There is also some CSS cleanup we can do.  Our code blocks are being generated inside html `<pre>` tags.  And they are overflowing the max line length in some cases, and running off screen.

Our images are also attempting to render at their native size and blowing out our layout.

We can address all 3 of these issues quickly.  To start, we'll need to update our `rr:load_book` rake task to perform our image file move.  This task is different enough from our existing book parsing classes to justify its own loader.  Setup a new file `lib/loader/book_image_finder.rb`.

``` ruby
class BookImageFinder
  attr_reader :entries
  
  def initialize(path)
     @path = normalize_folder(path) 
     @entries = filter_image_dirs(Dir.entries(@path))
  end
  
  def copy_files_to_public
    entries.each do |file_name|
      file_path = expand_file_path(file_name)
      FileUtils.cp_r(file_path,"#{Rails.root}/public/images/#{file_name}")
    end
  end
  
  private
    def normalize_folder(path)
      path[-1] == "/" ? path : path + "/"
    end
    
    def filter_image_dirs(raw_file_list)
        raw_file_list.select do |file|
            file_path = expand_file_path(file)
            Dir.exists?(file_path) && file != "." && file != ".."
        end
    end
    
    def expand_file_path(file_name)
        @path + file_name
    end
end
```

This is very similar to out Markdown file finder class, but works on the assumption that any directory in our book directory will be a chapter's image resources.  When the class is instantiated, we remove all files, and the `.` and `..` directory listings from our Array of entries.  We then provide a public method for the Class, `copy_files_to_public` which will loop our directories and do a recursive copy into `public/ `.

We can also adapt our `BookFileFinder` tests for use with this new class in a new file `/reactive-api/spec/lib/book_image_finder_spec.rb`.  I'm going to stop short of testing the actual file copy though as I'd rather not deal with the headaches of cleaning up our file system between test runs.  Since the copy process is largely built on Ruby internals anyhow, we can be confident so long as we identify the right files to copy, things will go off smoothly.

``` ruby
require 'rails_helper'
require 'loader/book_image_finder'

RSpec.describe BookImageFinder do
  it "removes files, and relative DIR paths from entries" do
    path = "spec/lib/testbook/"
    entries = BookImageFinder.new(path).entries
    expect(entries.length).to eq 1
    expect(entries[0]).to eq "images"
  end
  
  it "enforces proper file path" do
    path = "spec/lib/testbook/"
    bad_path = "spec/lib/testbook"
    expect(BookImageFinder.new(path).entries).to eq BookImageFinder.new(bad_path).entries
  end
end
```

Now we can update our Rake task to use this new Class (`/reactive-api/lib/tasks/rr.rake`).

``` Ruby 
require "#{Rails.root}/lib/loader/book_file_finder"
require "#{Rails.root}/lib/loader/book_image_finder"
require "#{Rails.root}/lib/loader/chapter_file"

namespace :rr do
  desc "Import content at lib/reactivating-rails/"
  task load_book: :environment do
    puts "Loading book content..."
    book_path = "#{Rails.root}/lib/reactivating-rails"
    entries = BookFileFinder.new(book_path).entries
    images = BookImageFinder.new(book_path)
    
    puts "Copying image file to public/images..."
    images.copy_files_to_public
    
    entries.delete_if do |file|
      ChapterFile.new(file).invalid?
    end
    
    entries.each do |file|
      chapter = ChapterFile.new(file)
      chapter.save
      
      chapter.body.each do |node|
        chapter.record.nodes.create(node_type: node.type.to_s, content: node.to_commonmark)
      end
    end
  end

  desc "Clear content of previously loaded iterations"
  task clear_book: :environment do
    puts "Clearing book content..."
  end
end
```

Run the task to update your public directory with the required image assets.  (`bin/rails rr:load_book`)

Now all that we need is some CSS changes.  Let's also make some quick file changes to clean up our mobile rendering and make our content more responsive to small screen sizes while we are at it.  We'll use a max-width on our `<img>` elements inside `#reader-pane` to ensure images get scaled down if they are too large for the screen area.  Ad similarly, our `<pre>` tags can be told to wrap lines when needed.

Update `App.css` as follows.

``` css
img {max-width: 100%;}

pre {white-space: pre-wrap}

#reader-pane {
  margin-top: 85px;
}

@media only screen and (max-width: 990px) {
  #app .banner {
    margin-left: -10px;
  }
}

@media only screen and (max-width: 767px) {
 #app #reader-pane {
   margin-top: 125px;
 }
}
```

Media specific styles are something we just can't handle directly in our components.  And generally, when I need a media specific rule I transition all related styles for that element to the stylesheet as well, so they are all located in one place.  That's why we are seeing the `#reader-pane` element styled here.

Let's also make some updates to `MenuBar` to better support our small screen renderings.

``` javascript
import React, { Component } from 'react';
import { Container, Image, Menu } from 'semantic-ui-react';
import reactLogo from '../assets/images/react-logo.svg';
import railsLogo from '../assets/images/rails-logo.svg';

import ChapterMenuItems from '../containers/chapter_menu_items'

const fixedMenuStyle = {
  backgroundColor: '#fff',
  border: '1px solid #ddd',
  boxShadow: '0px 3px 5px rgba(0, 0, 0, 0.2)',
  paddingTop: "13px",
  paddingBottom: "13px"
};

const tightItem = {
  paddingTop: "0",
  paddingBottom: "0"
}

class MenuBar extends Component {
  render() {
    return (
        <Menu
          id="menu_bar"
          borderless
          stackable
          fixed="top"
          style={ fixedMenuStyle }
        >
          <Container textAlign="center">
            <Menu.Item className="banner" style={tightItem}>
              <Image size='mini' src={reactLogo} />
              <Image size='mini' src={railsLogo} />
              <Menu.Item header>Reactivating Rails: A work in progress</Menu.Item>
            </Menu.Item>

            <Menu.Menu position='right' style={tightItem}>
              <ChapterMenuItems />
            </Menu.Menu>
          </Container>
        </Menu>
    );
  }
}

export default MenuBar;
```

Finish up, and look at all we've accomplished.

## Wrapping Up

We made some rapid progress this chapter, introducing a new layout for our application, and laying the groundwork to introduce navigation and routing.  We'll be tackling that next chapter.  We also iterated through the entire process of adding support for a new action, including defining our API endpoint, client actions, and tying it all together.

Before we move on, I'd like to touch briefly on testing.  You may have noticed that as we added test for other areas of our application I did not add any tests around the rendering of our components.  

I tend to run light on tests in this area, and generally rely on the tools I am using to be well tested.  I only include my own component tests when I am introducing complex logic between a given state, and props for a component, and the treatment it gets onscreen.  We just haven’t built anything that complex yet. If you feel differently, you can certainly add some tests on your own.  

In future chapters, we'll be setting up Capybara/Rspec in our API to do end-to-end testing in a simulated browser.   I find these types of tests are generally easier to implement, and generally more useful.  They allow us to focus on what our users can/should be able to do in our test, rather than grinding over checking how each Component renders in isolation.

