# Chapter 1: Installing React and Rails

## Rails new

We're going to start the installation process with the Rails side of our application.

Most readers are probably familiar with this process.  What you may not be aware of, if you are venturing to use Rails 5 for the first time, is that we now have new generators available for bootstrapping API based applications.

The Rails side of our application is going to completely surrender the view layer to React.  Limiting the backend to an API interface alone will help us enforce this separation.  Bootstrapping the application as an API will also leave out many of Rails component parts that manage the View layer, but leave us with the Model and Controller framework we are familiar with.

If you're following along, and want to ensure matching versions, at the time of writing, I am using:
* Ruby 2.3.1
* Rails 5.1.3

To create our application, enter the generator command:
`rails new [application name] --api --skip-test-unit` 

Or in my case:
`rails new reactive-api --api --skip-test-unit`

  *Note: I'll be using Rspec for this application, so I've elected to skip the use of Test Unit.  If you prefer a different test framework you can of course adjust accordingly.*

Then you might switch to the directory and run your bundle:
`cd reactive-api && bundle install`

While bundler finishes its work, dive into the application directory, and have a look...

## What's in an API anyway?

You'll need to be on Rails 5+ for the above *--api* flag to work correctly.  Using this flag removes a lot of overhead from our application we won't need.

**The API generator simplifies our asset pipeline, removing:**
* coffee-rails
* jquery-rails
* sass-rails 

The thought here is clear.  We won't be passing anything more than JSON in our responses, so there's no need for the JavaScript libraries CoffeeScript, or jQuery.  And similarly, the SASS processing of our CSS is now retired.  Note any of these tools might find their way into our client side application, but the need for them might be less prevalent as React generally has more powerful native tools at its disposal.  For example, React itself is far better at managing state than Rail's use of jQuery.  The overrun use of jQuery responses in larger applications (lovingly referred to as "jQuery hell" by the Rails community) is what many developers hope to avoid by adopting a frontend UI framework.

And since React supports ES6 syntax the need for CoffeeScript is really a matter of preference.  My personal take is that the cleaned-up syntax of ES6 is making the syntactic sugar supplied by CoffeeScript less and less of a draw.

The need for SASS is also less clear, as we may opt for storing our styles in the JavaScript syntax of our React components, greatly simplifying our application level CSS.

**Some other gems left behind:**
* uglifier - which handles the minification of our JavaScript assets.  We'll get minification as part of our Webpack compiling when we run our React client in production.
* turbolinks - Which speeds page loads in our rails applications by intelligently reloading only necessary contents of our pages on route changes, simulating single page applications.  React will be inheriting this role.

You might also notice the absence of a few standard folders from our newly generated application

**Application folders MIA:**
* app/assets, vendor/assets, and lib/assets - No surprises here as we've ditched the asset pipeline.
* app/helpers - Gone with our view layer.  Keep in mind though that our *concerns/* folders remain in *models/concerns/* and *controllers/concerns/* for similar shared logic used in the Model or Controller layers.

And we've activated a few other convenience features:
* Our generators will now detect that our application is set with the flag `config.api_only = true` and will helpfully generate new application contents leaving the view layer behind accordingly.
* There is also mention of a commented-out Gem, rack-cors in our gemfile.  

  Put simply rack-cors simplifies the authorization of cross-origin request scripts (CORS).  This is a necessary step whenever your API and the client operate on different origins (domains, sub-domains, or ports).  rack-cors helps you configure the bounds in which your API will allow cross-origin requests, and handles the needed preflight requests accordingly.  It is a MASSIVELY helpful gem when you need to venture into the world of cross-origin requests.
  
  For our purposes, we'll be avoiding the subject of CORS entirely.  Instead we'll be using a request proxying strategy when our application runs in development modes; negating the need for CORS.  Then in production modes we'll be configuring Webpack to compile its production assets into the `public/` directory of our rails application.  The rails "homepage" will become the single page of our single page application, again bypassing the need for CORS requests in production.  Handy, no?

With that introduction behind us, let's turn to the client side for a moment...  

## Create React App

We're going to be using create-react-app (CRA) to bootstrap our client application.

There are no shortages of React starters out there.  You can find one pre-configured to meet most any needed combination of supporting libraries.  Unfortunately, along with the ones you want, there will probably be two or three that are more in the "nice to have" bucket, and not the "need to have" bucket.  And then probably one or two more that are in the "what the hell does this thing do?" bucket.

Starters are fine as you gain experience, you'll find one that fits your style, and learn to tweak it the last 10% it needs to be a perfect fit.

But when you're starting out, it's strongly recommended that you start with create-react-app, a minimalist configuration maintained by the Facebook team, which is entirely geared towards getting you started quickly with *React*.  It leaves the extensibility to you, and going through those steps a few times will help you immensely when you decide to move on.  You can ignore this advice if you choose, jJust know that some members of the React community may make stern "tsk tsk" noises if you ever confess this mortal sin to them. 

You can install create-react-app with NPM.  But you'll need to set the global flag:
`npm install -g create-react-app`

Then you can create a new application:
`create-react-app [name]`

In my case, I'm going to use the imaginative name, reactive-client:
`create-react-app reactive-client`

*(Note: I'd recommend executing this command outside of your Rails application folder hierarchy.  There's no need for the folders to be nested, and personally I enjoy the clean separation of client side, and API application files.)*

When your command is finished executing you'll have a new directory for your client-side project files.  If you open that up, you'll see a folder for `node_modules`, that not surprisingly contains your node modules.  

There's also a `public` folder, which we are not going to use, or fairer to say we won't be using it in its current home.  This folder is used when running our application in production using compiled assets.  When we reach this stage in our journey, we'll be targeting this folder to build inside our Rails application, replacing the index files there with our React client.  For now, we can politely ignore these files.

The bulk of our work will happen in the `src` directory.  If you open it, you should notice immediately how much less opinionated CRA is compared to React.  At the time of writing I have the following:

    App.css                     #Stylesheet for our starter App Component
    App.js                      #A starter component for our app
    App.test.js                 #Test suite smoke test
    index.css                   #Application level CSS
    index.js                    #JavaScript entry point for our application
    logo.svg                    #A stylish blue logo with swirlie bits
    registerServiceWorker.js    #I have no fucking clue but let's learn!

There's not a lot of opinions to be had among these 7 files.  If you're picking up React for the first time after working with Rails for a while, comparing React's rather loosely defined project structure might be a little discomforting at first.  Resist the urge to panic for now.  As we add complexity to our app, we'll set conventions for file structures, and the concerns those files will manage.

## Boot the server(s)

Now that we're installed, it's time to boot up our servers and make a quick health check.

Since we're already poking around in our client folders, let's start there.

Within your client folder, execute the command:
`npm start`

Your console should helpfully report that your app can now be viewed on localhost:[port].  Let's go check that out!
*(Note: both Rails and CRA will bind servers to ports defined in your application environment unless strictly told to do otherwise.  In my case the use of port 8080 is the default, but your environment may vary.  Keep an eye on this if you struggle with examples.)*

![CRA Starter App Homepage](/images/1/CRAHomepage.png)

Nothing fancy, but we're looking good so far.  Let's demonstrate one thing before we move on.  Open `App.js`, and update its contents to the following:

```javascript(/src/App.js)
import React, { Component } from 'react';
+ import logo from './logo.svg';
- import './App.css';

class App extends Component {
  render() {
    return (
      <div className="App">
        <div className="App-header">
          <img src={logo} className="App-logo" alt="logo" />
          <h2>Oh snap!</h2>
        </div>
        <p className="App-intro">
          To get started, edit <code>src/App.js</code> and save to reload.
        </p>
      </div>
    );
  }
}

export default App;
```
As soon as you save the updated file, swap back to your browser, and avoid the deeply rooted reflex you have to mash `ctrl + r` to reload the page.  CRA will helpfully detect the updated file, and perform a hot reload for the refreshed contents.

![Updated CRA Starter App Homepage](/images/1/CRAHomepageHotReload.png)

This bit of convenience will be a huge boon to our productivity.  Now, we need to connect our Rails application to this development environment so we can enjoy this hot-reloading behavior as we work in development.  We want to enjoy the perks of hot reloading, but we must not wake the CORS dragon.

With confidence CRA has our client up and running, let's turn our attention to Rails.

Change to your Rails application directory, and start the server:
`bin/rails server`

Uhh oh, if you haven't tweaked your application configurations you may be greeted with a cheery error like this one:
  /usr/local/rvm/gems/ruby-2.3.1@reactivating/gems/puma-3.9.1/lib/puma/binder.rb:269:in `initialize': Address already in use - bind(2) for "127.0.0.1" port 8080 (Errno::EADDRINUSE)
  
That's because we still have our client app running on port 8080, and Rails is trying to start Puma bound to that same address/port.  

If we look in the file `config/puma.rb` we'll see this configuration:
```ruby
port        ENV.fetch("PORT") { 3000 }
```

This configures puma to check my local environment variables for a PORT setting.  And if one is not found to default to port 3000.

We can hunt out a similar setting inside CRA if we do a little digging.  We need to look inside the main dependency CRA is built upon; an npm package called `react-scripts`.  This dependency ships the framework of CRA's configuration (items like Webpack, Babel, etc.).  This one dependency gives us all the out of the box configuration CRA ships with.

To peek into its settings, have a look at `node_module/react-scripts/scripts/start.js` and you'll find:
```javascript
const DEFAULT_PORT = parseInt(process.env.PORT, 10) || 3000;
```

Which is functionally equivalent to the Ruby code we saw above.

We can't have both development servers running on the same port.  Technically we could change either one, but changing CRA's configuration would require us to "eject" react-scripts.  Ejecting react-scripts copies all the dependencyâ€™s scripts into our project, allowing us to make customizations to settings like this.  

Normally I'd delay ejecting react-scripts if possible; in fact, CRA considers react-scripts production capable for small and mid-sized applications.  So many CRA users might never need to eject at all.  However, we're going to be undertaking to eject react-scripts soon anyhow as we customize the production build location to integrate our React application with rails.

So, for the moment, let's get rails running by altering our start command.  We'll revisit a more lasting fix when we get around to ejecting react-scripts:
`bin/rails server -p 3000` 

Now you should see Puma coming online on port 3000 as requested.  And if all goes well, there will be much rejoicing, you're on Rails!

![Rails Application Homepage](/images/1/RailsHomepage.png)

## Forwarding API requests

Now that we've done a smoke test on each of our servers, it's time to tackle request forwarding between our client server, and our API server.

In the long term, our production application will compile our React client into a public assets directory, containing a minified file with all our JavaScript, and an HTML index for our application to run from.  We'll build this to Rails' `public/` directory, and let Puma (or whatever server you choose) run the entire show for our applications.

This moment in time where we need two servers to play nicely, and handle requests across multiple origins, is a passing thing.  Or a symptom of our development environment.  It'd be a shame if we had to set up all our API requests to satisfy COR preflight checks, for a condition that only exists in development.

  What is a preflight request?  Anytime your application needs to make a cross domain request to another server (read as domain, sub domain, or port), the request must be limited to either a GET, POST, or HEAD type.  And POST requests may only use content-types application/x-www-form-urlencoded, multipart/form-data, or text/plain.  That's fairly limiting when you're trying to build a restful API.
  
  Failing to meet these conditions results in your application needing to a make a preflight request. During a preflight request, an initial handshake is sent to the server.  The receiver then checks the origin of the request to see if it's an approved sender, and the headers of the request are checked to ensure no malicious headers are included (typically by limiting to a short-list of standard header options, or specifically authorized custom headers).  If the preflight check goes well, the normal request can proceed.  If the preflight fails, the server will return an error.

Preflight requests not an insurmountable obstacle, and in fact Rails makes this easy to do; even suggesting a gem `rack-cors` in your gemfile to handle this setup.  If you plan to keep your client and server hosting separate for scalability reasons, this might be appropriate.  You could keep Rails totally devoted to your API, and give over hosting of your client files to a separate server, or CDN.

But for small to midsized applications, this seems needlessly complex.

Luckily, CRA makes this kind of proxying dead simple.

Open the `package.json` file of your client application.  We're going to be adding a key `proxy` to our top-level object, and giving it the value for our Rails application server (on port 3000, or whatever you've elected to use.)

```javascript
{
  "name": "reactive-client",
  "version": "0.1.0",
  "private": true,
  "proxy": "http://localhost:3000",
  "dependencies": {...},
  "scripts": {...},
}
```

Now, we just need to test this out.  Let set up a smoketest controller action so we can ensure our proxy is working as expected before moving forward.

Inside your Rails application directory, generate a new controller action:
`bin/rails generate controller smoketest example --no-test-framework`

That will create a new controller for us, and a route `get 'smoketest/example'`.  Before we move on, it would be an excellent idea to create a namespace for all our API routes to operate under.  That way we are less likely to collide with client-side routes as we expand out our application.

Open `config/routes.rb` and update it to the following:
```ruby
Rails.application.routes.draw do
  namespace :api do
    get 'smoketest/example'
  end
end
```

Now look at your routes using `bin/rails routes` and you should see the following:
`GET  /api/smoketest/example(.:format) api/smoketest#example`

We'll nest all our API routes into this namespace to create a clear line of separation for forwarded routes.

However, we need to nest our controllers inside an `api/` folder to account for this route change:
`mkdir app/controllers/api && mv app/controllers/smoketest_controller.rb app/controllers/api`

One last thing to do, open the new `app/controllers/api/smoketest_controller.rb`.  Currently the example action we've created returns an empty response.  Let's set it to send back some very basic JSON.

```ruby
class Api::SmoketestController < ApplicationController
  def example
    render json: {smoketest: "hello world"}
  end
end
```

Notice we've also changed SmokeTestController to inherit from a new module `Api`, again to account for our changed route.

With all that in place we're ready for our test.  Be sure you have **both** your client and API servers running.  And in a terminal, execute:
`curl http://138.197.14.5:8080/api/smoketest/example`

And you should receive a response: `{"smoketest":"hello world"}`

Notice that our curl command is directed at port 8080, which is the port of my React client server.  When CRA receives a request that it doesn't have a route to handle, it forwards that request on to the indicated server in our proxy settings, in this case, my API.  Another way we could look at this would be to direct the curl command at the API server itself: `curl http://138.197.14.5:3000/api/smoketest/example`.  The result is the same `{"smoketest":"hello world"}`, we simply targeted our request directly at the API server, bypassing the proxy.

With this proxying in place, we'll now be able to query our API as a local path such as `api/smoketest/example` from within on client application.  The request proxying will eliminate our need to manage CORS requests.

## Managing servers

Let's make one final configuration to our development environment before we wrap up...

Right now, we need both our servers running to have our application up and running.  This requires us to have two distinct processes running in two separate terminals, and the use of 2 commands each time we want to start our servers.  Not a huge deal, but it would be nice if we could start and stop the application more easily.

We're going to use Foreman to help us manage these server processes.

Begin by adding Foreman to your Gemfile's development dependencies, `gem 'foreman', '~> 0.82.0'` and then `bundle install`

Foreman simplifies the running of multiple processes with the use of a Procfile.  Allowing you to start several processes in a single terminal, with a single command.  When one process fails, Foreman will helpfully shut down the remaining controlled process as well.

To setup, create a file named `Procfile` in your Rails API application directory.

Then edit the file to contain the following:
```
client: cd [client-application directory] && npm start
api: bin/rails server -p 3000
```

Save the file, and shut down any running servers.  And then execute the following from your Rails application directory, `foreman start`.

You should see Foreman start each server process:
```
18:40:19 api.1    | => Booting Puma
18:40:19 api.1    | => Rails 5.1.3 application starting in development on http://138.197.14.5:3000
18:40:19 api.1    | => Run `rails server -h` for more startup options
18:40:19 api.1    | Puma starting in single mode...
18:40:19 api.1    | * Version 3.9.1 (ruby 2.3.1-p112), codename: Private Caller
18:40:19 api.1    | * Min threads: 5, max threads: 5
18:40:19 api.1    | * Environment: development
18:40:19 api.1    | * Listening on tcp://138.197.14.5:3000
18:40:19 api.1    | Use Ctrl-C to stop
18:40:20 client.1 | Starting the development server...
18:40:20 client.1 | 
18:40:26 client.1 | Compiled successfully!
18:40:26 client.1 | 
18:40:26 client.1 | You can now view reactive-client in the browser.
18:40:26 client.1 | 
18:40:26 client.1 |   http://localhost:8080/
18:40:26 client.1 | 
18:40:26 client.1 | Note that the development build is not optimized.
18:40:26 client.1 | To create a production build, use npm run build.
```

Using `ctrl + c` to kill the Foreman process will shut down both application servers.

For the moment, we'll need to start our applications out of the Rails directory to use Foreman to manage the servers.  But as we move forward we can modify react-scripts start script to do the same from our client application directory.

## Summary

That brings us to the end of Chapter 1.  we have set up both our client and API servers, and carved out a space for both to operate by defining the ports each is bound too.  

We set up create-react-app to manage proxy requests to our API, eliminating the need to manage CORS

And configured Foreman to simplify the task of managing multiple server processed in development.
