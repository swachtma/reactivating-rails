# Chapter 14: Synchronicity in Sagas

In chapter 14 we will be making some improvements to our login system to better handle situations where a user's token might expire in the midst of an authenticated action.  Revisiting our user authentication and rehydration processes, we can rewrite our sagas to leverage some more advanced concurrency patterns in the process.

Our goal for the end of this chapter is to have a mechanism by which tokens can expire gracefully; causing minimal disruption to our users as they try to digest our content.

## Sagas so Far

Up to this point, all of our sagas leverage what we introduced earlier as the watcher pattern.  

We have limited our sagas to using Redux Saga's high-level effects such as `takeLatest`, and `takeEvery` to subscribe our sagas to the store, and fire responses on every matching action dispatch.  We also, for the most part, have limited our sagas to a single linear path of logic.  We now have a use-case for some of Redux Saga's more advanced patterns.

### Writing Descriptive Sagas

One complaint I have about our current Sagas is having work fractured into several different files, even in places where the two sagas are a single linear set of instructions.

Our user hydration and dehydration sagas are an example of this.  If you think about sign-out for example; we have tied that work to any dispatch of the `CLEAR_USER` action.  However, this saga is only relevant during the time after a user has signed into our application.  

From a systems perspective, that is not a problem.  We could call `CLEAR_USER` repetitively all day long, our store would happily take the dispatch, and our `dehydrateUser` saga would attempt to clear our user's credentials.  If there don't happen to be user credentials in the store to clear, Redux will still happily go through the motions for us.

From a designer's perspective though, it is a shame that our login process spreads across 2 different sagas (and four files, if you count each saga, our Axios client, and a redirect utility function we leverage).  A new designer coming into our project would need to reconstruct the whole process back together from these fractured pieces to understand the way the system works as a whole.

There is also a hidden problem with this design or one we have thus far ignored.  

When a user returns after a previous session with stored credentials, Redux Persist is helpfully restoring their profile and token from our browser's local storage.  However, that rehydration process does nothing at the moment to ensure the token it is restoring hasn't expired since our last visit to the site.  Instead, the first check we have on the token's validity comes with the first authenticated request we make against our API.  That is not ideal; I do not want to interrupt my user, in the midst of reading, by suddenly squawking about an expired token.

With all that in mind, here are our goals for this iteration:
* Sign in, and sign out should exist as a single saga.
* This saga's scope should be expanded to cover user rehydration on repeat visits.
  * Rehydration should ensure the token restored is still valid.
    * If a token is expired, or expiring soon, we should sign out the user on their initial page load
    * A message should appear for expired tokens, prompting the user to sign in again.
    * Token expiration must be checked proactively throughout its life and cleared when expired.

Let's start with a refactor that does not change any behavior in our application but accomplishes the goal of merging the sign-in and sign-out sagas into a single process flow.

## Preparing our Refactor

Before we get started, let's trim away some of the deadwood.

Open your root saga, and make the following changes.

``` javascript(/reactive-client/src/sagas/root.js)
import { all } from 'redux-saga/effects';
import { watchBookRoutesSaga } from './instantiate_book';
import { watchRoutesToClearAlerts } from './clear_alerts';
import { manageUserSession } from './manage_user_session';
import { watchBookmarkChanges } from './set_bookmarks';


export default function* rootSaga(){
  yield all([
    watchBookRoutesSaga(),
    watchRoutesToClearAlerts(),
+     manageUserSession(),
    watchBookmarkChanges()
  ]);
}
```

`watchSignout` is removed entirely, as we are moving this process into a larger authentication saga.  We are also renaming our old sign-in saga `watchAuthRoutes` to `manageUserSession` to describe its new role handling sign-in, rehydration, and sign-out flows.

**Take a moment and also rename your file at** `/reactive-client/src/sagas/hydrate_user.js` ** to ** `/reactive-client/src/sagas/manage_user_session.js` ** as well to reflect the change in our saga's name.**

## Pausing Sagas for Actions

Prebaked effects like `takeEvery` and `takeLatest` are perfect when we want to repeat a series of steps with every matching dispatch.  What happens though if certain actions are not valid under all circumstances?  Do we need to be listening for sign-out actions, before a user authenticates?  Alternatively, do we want to honor a second sign-in request while the user already has an active session?  These scenarios are where the `take` effect comes in.

`take` allows us to write sagas that pause their execution until a specific action dispatches.  We can use it to write more advanced response patterns for our sagas.

When using `take` in a saga, you may not need a watcher saga at all.  Instead, we can set up our sagas to listen for different actions across their lifecycle as other aspects of our state change.  In our case, we are writing a single flow for user authentication that listens for sign-in, and rehydration actions in its early lifecycle.  Then the same saga should switch to listen for sign-out and expiration actions once a user session begins.

We can get a first look at the `take` effect by ridding ourselves of the watcher saga that has up until this point managed our sign-in process.  

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
+ import { takeLatest, put, call, take } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(/*action*/){
+  while(true){
    try{
+       let action = yield take(routes.AUTH_ROUTE);
+       yield call(redirectToPathIf,action.payload.bounce_path); 
        
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
    } catch(e){
      yield put(addAlert(e.message,"warning"));
  }
  }
} 

// export function* watchAuthRoutes(){
//   yield takeLatest(routes.AUTH_ROUTE, hydrateUser);
// }
```

I am showing our changes here with our old code commented out to illustrate the difference in our new approach.  Historically, we have allowed our watcher saga `watchAuthRoutes` to start a new pass at our user hydration saga every time someone lands on our `AUTH_ROUTE` after being redirected by GitHub.

We can rewrite this pattern using `take` as shown above.  The first thing you probably notice is the `while(true)` loop we are wrapping around our saga execution.  In a normal function, this infinite loop would be a catastrophic oversight.  Remember though; generators are not normal functions.  A generator suspends its execution each time it comes to a `yield` statement, and only reasserts control over our execution once the yielded statement alerts our generator it can proceed.

With Redux saga, we are passing control of execution to the saga middleware each time we invoke an effect.  In the case of the `take` effect, we are pausing until a matching action dispatches to our store.  In this case, that action is `routes.AUTH_ROUTE`.

The before and after of this change gives us **almost**, the same functionality.  Our new while loop, and `take` based approach listens to each dispatch of `AUTH_ROUTE` in our store, and executes our sign-in logic as a response.  That loop then repeats back on itself and again pauses until the next dispatch of the `AUTH_ROUTE` action.

The critical difference is that our original approach using `takeLatest` would have assured that before beginning another execution of this saga, we canceled any ongoing execution from previous dispatches.  We can restore this cancellation behavior as we move through our example.

You might also notice we are changing our interaction with the `redirectToPathIf` function to leverage the `call` effect.  This function is the only utility we have left that has not been set up as a generator function.  I want to change that now to promote easier testing and to standardize how we manage these utility methods we have set up for our Sagas.

Make the corresponding changes to `redirectToPathIf` before proceeding.

``` javascript(/reactive-client/src/sagas/utils/redirect_path.js)
import { put } from 'redux-saga/effects';

+ export default function* redirectToPathIf(path){
  if(path){
    let rd = decodeURIComponent(path);
    rd = JSON.parse(rd);
+     yield put(rd);
  }
}
```

## Switching Monitored Actions

Let's move forward again by pulling our sign-out behavior into this saga.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
+ import { put, call, take } from 'redux-saga/effects';
+ import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action = yield take(routes.AUTH_ROUTE);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
+       // Wait for Sign Out, and then...
+       yield take(user_actions.CLEAR_USER);
+       yield put(clearAlerts());
+       yield put(addAlert("Sign out successful","danger"));
+       yield call(delay,3000);
+       yield put(clearAlerts());
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 
```

This code comes over almost entirely unchanged from our old `dehydrateUser` saga.  Now, instead of allowing our loop to circle back immediately and accept another sign-in action, we are holding the loop to wait for a `CLEAR_USER` dispatch in our store.  Logically, this makes perfect sense; if a user authenticated, why honor any further attempts at authentication until the session terminates?

Let's make one additional refactor before moving on.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action = yield take(routes.AUTH_ROUTE);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
+       yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignOut() {
+   yield put(clearAlerts());
+   yield put(addAlert("Sign out successful","danger"));
+   yield call(delay,3000);
+   yield put(clearAlerts());
}
```

The signout flow of clearing existing alerts, placing a sign-out notification, and then timing that alert to clear is a concise standalone process.  We can externalize small units of work into isolated generators to keep our units of code small and easily testable.  This approach minimizes the brittleness of our tests in more complex sagas.

## Listening to Complex Conditions

Now we are ready to start expanding our functionality.  

We want our application to check our tokens for validity each time they rehydrate from our store.  That means our sign-in action might not be the path that leads our saga to expect a sign-out action.  Luckily, the `take` effect makes this easy.  We are going update our saga to listen to the action Redux-Persist dispatches to our store upon restoring a user's session, `persist/REHYDRATE`.

We have one complication though.  Take a look at the action Redux-Persist dispatches when restoring a user.

``` javascript
{
  type: 'persist/REHYDRATE',
  payload: {
    user: {
      id: 1,
      github_email: 'swachtma@gmail.com',
      username: 'swachtma',
      avatar: 'https://avatars0.githubusercontent.com/u/1584720?v=4',
      token: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vMTM4LjE5Ny4xNC41OjgwODAiLCJpZCI6MSwiZXhwIjoxNTIzNTMyNjg1LCJpYXQiOjE1MjA5NDA2ODV9.Ah9eE8QvWcw4dcue3YhPd64jqBx1x_hhj7w5KKxOttI'
    },
    _persist: {
      version: -1,
      rehydrated: true
    }
  },
  key: 'root'
}
```

This object structure, and our internal action for sign-in use different object structures.  For either action, we need to locate our token so we can send it to our API for verification.  We need to prepare for both possible action payload structures.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
+       let token = action.payload.token || action.payload.user.token; 
        yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
+       let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

Easy enough on the surface, but there is a problem.  Refresh your browser and see what happens if your application instantiates **without** a user token in storage available.

![Error Alert Warning: Your session has expired or is no longer valid, please sign in again.](/images/13/SessionExpiredOrInvalid.png)

What's going on here?  If you do some investigating in the Redux Developer Tools, the problem is easy to spot.  Redux-Persist is dispatching its rehydration action even in situations where there is no token in storage.  When this action triggers our saga, we end up passing an undefined value in `token` to our API call.  

We need to prepare for the possibility that a dispatched rehydration action might not indicate we are restoring a user session.  Here is where the `take` effect begins to shine.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
+       let action,token;
+       while(!token){
+         action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
+         token = action.payload.token || action.payload.user.token; 
+       }
      
+       yield call(handleSignIn,token);
        yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

+ export function* handleSignIn(token){
+   const pub_client = yield call(axiosCreateClient,false);
+   let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
+   yield put(setUser(user.data));
+   yield call(retrieveUserBookmark);
+ }

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

Now our saga continues to wait for a sign-in, or rehydration action until one of them not only dispatches but also provides a value for `token`.  Once this variable is defined, our first loop terminates and moves our saga onto communicating with the API to trade this token for user credentials.

We are also externalizing our sign-in flow into a standalone generator function.  This change is partly for testability, but there's another reason as well, concurrency.  

## Forking Saga Work

Right now, our sign in process is blocking our saga from proceeding until our communication with the API is complete.  However, that does not need to be the case.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
+ import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action,token;
      while(!token){
        action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
        token = action.payload.token || action.payload.user.token; 
      }
      
+       let sign_in = yield fork(handleSignIn,token);
        yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
+       yield cancel(sign_in);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignIn(token){
  const pub_client = yield call(axiosCreateClient,false);
  let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
  yield put(setUser(user.data));
  yield call(retrieveUserBookmark);
}

export function* handleSignOut() {
  yield put(clearAlerts());
  yield put(addAlert("Sign out successful","danger"));
  yield call(delay,3000);
  yield put(clearAlerts());
}
```

The `fork` effect in this latest example is an effect very similar to the `call` effect we have used previously.  Both `fork` and `call` send instructions to the saga middleware to execute a function.  The difference is that `fork` executes as an asynchronous (non-blocking) unit of work, allowing the saga to proceed immediately with our redirect and monitoring for a sign-out dispatch.  

Exercise this power responsibly though; we need to consider all outcomes carefully when forking lines of work.  We need to consider what happens if a sign-out dispatch follows our sign-in process so quickly that work is still underway.  You could quickly end up in a state where you are firing sign-out instructions as your API communication is still hydrating a user.  That could leave you with a broken state.

Luckily, `fork` gives us an easy remedy to this risk.  When you call the `fork` effect, Redux Saga returns you a pointer to the task.  Should you need to stop this task prematurely for any reason, you can pass the reference to the forked task to another effect `cancel` and abort its execution.  

We do this above to ensure we have no active sign-in efforts underway before running our sign-out logic.

# Handling Session Expirations with Forked Work

We now have login and logout merged into a single saga.  However, in doing so, we have also emphasized a security hole in our design.  By linking the rehydration action to our `AuthenticationController`, we have created a mechanism which refreshes our user token's expiration each time it rehydrates.  That is not an acceptable pattern because it means once someone gets a user's token they can refresh it infinitely to retain account access.  This design flaw has technically always been present in our controller, but now we have accentuated the problem by connecting this workflow directly to our UI.

Let's address this issue as we deal with some other problems related to our session timeout.

First, I am going to rewrite our `TokenOps` class and `AuthenticationController` to only allow a token refresh when a user hits our authentication controller with a specially marked short-term token.

``` ruby(/reactive-api/app/controllers/concerns/token_ops.rb)
module TokenOps
  extend ActiveSupport::Concern
+   def self.encode(expires, user, type = "SHORT")
+     payload = {
+       iss: ENV['CLIENT_URL'],
+       id: user.id,
+       type: type,
+       exp: expires.to_i,
+       iat: Time.now.to_i
+     }
+     JWT.encode payload, ENV['JWT_SECRET'], 'HS256'
+   end

  def self.decode(token)
    options = {
      iss: ENV['CLIENT_URL'],
      verify_iss: true,
      verify_iat: true,
      leeway: 30,
      algorithm: 'HS256'
    }
    JWT.decode token, ENV['JWT_SECRET'], true, options
  end
end
```

Our separate `encode_long` and `encode_short` functions were creating confusion, so I am migrating back to using a single encode and decode method.  The `encode` method, now accepts a specific expiration time passed as its first parameter and adds a `type` key to our token payload.  We can use this type value to validate whether our token is eligible for a refresh or not.

Now let's restructure our `AuthenticationController` to leverage these altered methods.

``` ruby(/reactive-api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    begin
      code = params[:code]
      bounce_path = ERB::Util.url_encode(params[:bounce_path])
      github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
      token = github.get_token(code).token
      
      github_users = Github::Client::Users.new oauth_token: token
      user = User.create_or_fetch(github_users.get)
+       jwt = TokenOps.encode(2.minutes.from_now.to_i, user, "SHORT")
      
      redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
    rescue
      redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
    end
  end
  
  def show
    begin 
      token = params[:token]
+       decoded_token = TokenOps.decode(token)[0]
+       expires = decoded_token["exp"]
      user = User.find(decoded_token["id"])
      
+       if(decoded_token["type"] == "SHORT")
+         expires = 30.days.from_now.to_i
+         token = TokenOps.encode(expires, user, "LONG") 
+       end
+ 
+       countdown = (expires - Time.now).to_i
+       raise AuthenticationErrors::BadToken if countdown < 12 * 60 * 60
+       
+       render json: user.fsa(token, countdown), status: 200
    rescue
      raise token == "githubfailure" ? AuthenticationErrors::GithubFailure : AuthenticationErrors::BadToken
    end
  end
end
```

We are now limiting this controller to generate a new token only when the user is beginning a new session, fresh from being redirected off GitHub's OAuth endpoint.

We are also pulling the new `expiration` key from our token's payload.  We can send this value client-side to manage our session expiration in Redux Saga.  Since we cannot access the decoded token value client-side, we need to update our controller to pass this information as part of the route's payload.

We calculate a `countdown` value before generating our controller's response.  If the countdown calculates that the remaining token expiration time is less than twelve hours, we are going to raise our `AuthenticationErrors::BadToken` exception.  

This exception causes our client to clear the active user from our state, and prompt for a fresh login.  This check minimizes the chance that a user's session might expire in the middle of their active time on our website.  If the token is nearing expiration, I would rather have the user sign in at the start of a visit, than to have them suddenly be signed out in the middle of a task.

Here is our updated `User.fsa` method.

``` ruby(/reactive-api/app/models/user.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

class User < ApplicationRecord
  has_one :bookmark
  
+  def fsa(token, expires)
    {
      id: id,
      github_email: github_email,
      username: username,
      avatar: avatar,
      token: token,
+       expires: expires
    }
  end
  
-   def self.create_or_fetch(user)
-     find_by(github_id: user.id) || create(
-       github_id: user.id,
-       github_email: user.email,
-       username: user.login,
-       avatar: user.avatar_url
-     )
-   end
end
```

Now that we are receiving a marker for how long our session time persists; modify your client-side code to handle this countdown.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser, clearUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

- export function* manageUserSession(){
-   while(true){
-     try{
-       let action,token;
-       while(!token){
-         action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
-         token = action.payload.token || action.payload.user.token; 
-       }
-       
-       let sign_in = yield fork(handleSignIn,token);
-       yield call(redirectToPathIf,action.payload.bounce_path); 
-       
-       // Wait for Sign Out, and then...
-       yield take(user_actions.CLEAR_USER);
-       yield cancel(sign_in);
-       yield call(handleSignOut);
-     } 
-     catch(e){
-       yield put(addAlert(e.message,"warning"));
-     }
-   }
- } 

export function* handleSignIn(token){
  try {
    const pub_client = yield call(axiosCreateClient,false);
    let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
+   yield fork(manageUserTimeout,user.data.expires);
    yield put(setUser(user.data));
    yield call(retrieveUserBookmark);
  }
  catch(e){
    yield put(addAlert(e.message,"warning"));
  }
}

+ export function* manageUserTimeout(countdown){
+   // delay timeout cannot exceed 32-bit int (2147483647) or ~24 days
+   countdown = countdown >= 2147000 ? 2147000 : countdown;
+   yield call(delay, countdown);
+   yield put(addAlert("Your session has expired, please sign in again.","danger"));
+   yield put(clearUser());
+ }

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

When a user signs-in, or rehydrates a session, we are going to use their countdown timer to start a forked process.  This process uses the Redux Saga `delay` utility to suspend a sign-our token has expired.  Once the timer elapses, we clear the user session and display an alert.

You might be wondering why we are checking that our counter length is less than 2147483647.  The Redux Saga `delay` effect utilizes JavaScript's `setTimeout` method, which limits its timer value to a 32-bit integer.  If we overflow this counter with a larger value, it expires immediately and breaks our delay.

This code is almost right.  The problem is our Saga does not clear the user information on sign-out right now.  We are listening to the `CLEAR_USER` action dispatch sent by our UI components, and using our saga to display some additional alert messaging.  However, the actual clearing of user information in our store is kicked off by a component's dispatch.  This approach is causing me to needlessly reuse code in my Saga now that there are multiple ways to trigger a session's termination.

Let's rewrite our sign-out logic so that our UI components trigger an action, which in turn begins our saga's sign-out, but leaves the actual clearing of the user state to the saga itself.

``` javascript(/reactive-client/src/constants/user.js)
export const SET_USER = "SET_USER";
+ export const SIGNAL_SIGNOUT = "SIGNAL_SIGNOUT";
export const CLEAR_USER = "CLEAR_USER";
```

To begin, we set up a new action in our store to be our new Saga trigger.  We also want an action creator for this new action type.

``` javascript(/reactive-client/src/actions/user.js)
import * as constants from "../constants/user";

- export const setUser = (payload) => ({
-   type: constants.SET_USER, payload
- });

+ export const signalSignout = () => ({ type: constants.SIGNAL_SIGNOUT });
export const clearUser = () => ({ type: constants.CLEAR_USER }) ;
```

Then we need to update our provider/container element to bind this new action to our component state.

``` javascript(/reactive-client/src/containers/user_provider.js)
import { connect } from 'react-redux';

import UserBadge from '../components/user_badge';
+ import { signalSignout } from '../actions/user';

- export const connectToUser = (WrappedComponent) => {
-    return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
- };

- const mapStateToProps = (state) => ({
-   username: state.user.username,
-   avatar: state.user.avatar
- });

const mapDispatchToProps = (dispatch) => ({
+   dispatchSignalSignout: (e) => dispatch(signalSignout())
});

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedUserBadge = connectToUser(UserBadge);
```

``` javascript(/reactive-client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import ConnectedGitHubIcon from './github_icon';

class UserBadge extends Component {
  render() {
    if(!this.props.username){
      return (
        <ConnectedGitHubIcon />
      );
    } else {
      let badge = <Image src={this.props.avatar} avatar />;
      return (
        <Menu.Item name={this.props.username}>
          <Dropdown icon={badge} compact pointing="top right">
            <Dropdown.Menu>
+               <Dropdown.Item onClick={this.props.dispatchSignalSignout}>Sign Out</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </Menu.Item>
      );
    }
  }
}

export default UserBadge;
```

Finally, we can modify our Saga to leverage these new distinct actions for triggering and executing our sign-out process.

``` javascript(/reactive-client/src/sagas/manage_user_session.js)
import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser, clearUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action,token;
      while(!token){
        action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
        token = action.payload.token || action.payload.user.token; 
      }
      
      let sign_in = yield fork(handleSignIn,token);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
+       yield take(user_actions.SIGNAL_SIGNOUT);
      yield cancel(sign_in);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignIn(token){
  try {
    const pub_client = yield call(axiosCreateClient,false);
    let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
    
    yield fork(manageUserTimeout,user.data.expires);
    yield put(setUser(user.data));
    yield call(retrieveUserBookmark);
  }
  catch(e){
+     yield call(handleSignOut,e.message);
  }
}

export function* manageUserTimeout(countdown){
  // delay timeout cannot exceed 32-bit int (2147483647) or ~24 days
  countdown = countdown >= 2147000 ? 2147000 : countdown;
  yield call(delay, countdown);
+   yield call(handleSignOut,"Your Session has expired, please sign in again.");
}

+ export function* handleSignOut(message) {
+   message = message || "Sign out successful";
+   yield put(clearUser());
+   
+   yield put(clearAlerts());
+   yield put(addAlert(message,"warning"));
+   yield call(delay,3000);
+   yield put(clearAlerts());
}
```

Our `handleSignOut` generator function has now been updated to handle all potential outcomes that terminate a user session.  Since our saga now controls clearing a user's credentials from our store, we can use this one method for all paths of our logic.  If a user's session expires, or if they attempt to send an invalid token to our controller, we pass the specific messaging from our server-side error into the signout function to override the default messaging.

We now have a comprehensive system for managing user authentication across its lifecycle in our application.  There's one outcome of our Saga logic we have not discussed though.  

When we set up our `manageUserTimeout` generator, we forked it off the sign in process.  What happens if before a user's session expires, they explicitly trigger a sign-out?  Do we still have a countdown running that might call another sign-out action when its timer expires?  It turns out, no.  

Redux Saga's `fork` effect creates what is called an "attached" fork.  With an attached fork, Redux Saga automatically handles cancellation for us if the saga terminates, errors, or is canceled somewhere up the line.

This automatic cancellation means that on a `SIGNAL_SIGNOUT` dispatch, when we call `yield cancel(sign_in)`, that the attached fork for our timer dies as well.  So no matter how our session winds up ending, we do not need to worry about a lingering timer.  

Redux Saga also offers a `spawn` effect, which functions similarly to `fork`, but creates a "detached" fork instead.  A detached fork remains active even if the parent that starts its execution fails or cancels.  We do not need it here, but keep it in mind as a tool for your toolkit when working with sagas.

## Refactoring API Tests

The updates we made to our `TokenOps` class and `AuthenticationController` have broken a number of our tests.  Let's update these specs now to get back to green.

First off, several of our tests have broken because we changed the interface on our `TokenOps.encode` method.  We have a helper function in our controller tests that leverage this function to handle authenticated requests.  Update this method, so it leverages the new `encode` format.  We are also changing the helper method itself to be more flexible, allowing us to pass on specific values for the token's expiration and type values.  This setup allows us to painlessly prepare test cases where we need an expired or nearly expired, token.

``` ruby(/reactive-api/spec/helpers.rb)
module Helpers
  def request_as(user, exp = 25.hours.from_now, term = "LONG")
   return {"Authorization" => TokenOps.encode(exp, user, term) }
  end
end
```

Similarly, our `User` model spec needs to be updated to account for the changes we made to our `fsa` method.

``` ruby(/reactive-api/spec/models/user_spec.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

require 'rails_helper'

RSpec.describe User, type: :model do
-   before(:each) do
-     @user = User.create({
-         github_id: 2,
-         github_email: "test@test.com",
-         username:"something_witty",
-         avatar:"someimage.gif",
-       })
-   end
  
  it "provides .fsa(token) to produce user FSA response object" do
+    fsa = @user.fsa("sometoken", 200000)
   expect(fsa[:username]).to eq @user.username
   expect(fsa[:token]).to eq "sometoken"
  end
  
-   describe "create_or_fetch" do
-     it "creates a new user if one cannot be found" do
-       User.create_or_fetch(OpenStruct.new({
-         id: 1,
-         email: "someone",
-         username: "someoneelse",
-         avatar: "someimage"
-       }))
-       
-       expect(User.all.count).to eq 2
-     end
-     
-     it "returns a recond by github_id if available" do
-       requested_user = User.create_or_fetch(OpenStruct.new({id: 2}))
-       expect(requested_user).to eq @user
-       expect(User.all.count).to eq(1)
-     end
-   end
end
```

Our `TokenOps` class should check that it provides both an `encode` and `decode` method.  We are also testing that the decoded token provides the critical user ID and expiration values we need.  We also test that the class can encode and decode both of our token types.

``` ruby(/reactive-api/spec/controllers/concerns/token_ops_spec.rb)
require 'rails_helper'

RSpec.describe TokenOps do
    it "provides an encode and decode method" do
      expect(TokenOps.respond_to? :encode).to be true
      expect(TokenOps.respond_to? :decode).to be true
    end
    
    describe "encode" do
      before(:each) do
        @user = User.create({
          github_id: "test",
          github_email: "test@test.com",
          username:"something_witty",
          avatar:"someimage.gif",
        })
      end
      
      describe "defaults" do
        before(:each) do
          token = TokenOps.encode(2.minutes.from_now, @user)
          @decoded = TokenOps.decode(token)[0]
        end
        
        it "provide an id value and expiration when decoded" do
          expect(@decoded["id"]).not_to be_nil
          expect(@decoded["exp"]).not_to be_nil
        end
        
        it "default to SHORT type, if not specified" do
          expect(@decoded["type"]).to eq "SHORT"
        end
      end
      
      describe "explicit LONG" do
        it "can be decoded" do
          token = TokenOps.encode(30.days.from_now, @user)
          decoded = TokenOps.decode(token)[0]
          expect(decoded["exp"]).not_to be_nil
        end
      end
  end
end
```
Our `AuthenticationController` has several edge cases in this controller now that are difficult to reproduce in the real world.  Rspec makes producing these conditions easy however.

1. A short-term token should have its expiration extended when traded for a LONG token during sign-in.
2. A LONG token will **not** have its expiration extended on return visits.
3. A token with less than 12 hours left in its life is considered expired and should raise an exception.

``` ruby(/reactive-api/spec/controllers/api/authentication_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::AuthenticationController, type: :controller do
-   describe "GET #github" do
-     let(:sample_response) { OpenStruct.new({id: 1, email: "", login: "", avatar_url: ""}) }
-    
-     before(:each) do
-       #create a stub for main Github API class.  Stub is then allowed to respond to 
-       # .get_token(code).token chain of our controller with a fake token.
-       github = double("github")
-       class_double("Github", :new => github).as_stubbed_const(:transfer_nested_constants => true)
-       allow(github).to receive_message_chain(:get_token, :token) { "fake token" }
-       
-       #Similar to above we mock the Client::Users class then allow the returned double
-       #github_users to respond to #get with a mocked user profile response.
-       @github_users = double("@github_users")
-       allow(Github::Client::Users).to receive(:new) { @github_users }
-       allow(@github_users).to receive(:get) { sample_response }
-     end
-     
-     it "returns http success for new users" do
-       get :github
-       expect(response).to have_http_status(302)
-     end
-     
-     it "returns http success for existing users" do
-       User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
-       get :github
-       expect(response).to have_http_status(302)
-     end
-   end
  
  describe "GET #show" do
    before(:each) do
      @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
      @token = TokenOps.encode(2.minutes.from_now, @user)
    end
      
    it "returns a user profile on valid SHORT token" do
      get :show, params: {:token => @token}
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)).to include("id","username","github_email","token","avatar","expires")
    end
    
+     it "updates expiration if token is type == SHORT" do
+       get :show, params: {:token => @token}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["expires"]).to be > 2.days.from_now.to_i - Time.now.to_i
+     end
    
+     it "does not update expiration if type == LONG" do
+       get :show, params: {:token => TokenOps.encode(14.days.from_now, @user, "LONG")}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["expires"]).to be < 15.day.from_now.to_i
+     end
    
+     it "raises AuthenticationErrors::BadToken if expiration < 12 hours" do
+       get :show, params: {:token => TokenOps.encode(11.hours.from_now, @user, "LONG")}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
end 
```

## Refactoring Client-Side Tests

Before we start into client-side testing, let's remove files we no longer need from our application.  If you have not done so already, delete the now retired `/reactive-client/src/sagas/dehydrate_user.js` file, and its corresponding spec.  This functionality lives on in our merged `manageUserSession` saga.

Our client-side changes have also broken a large number of our existing tests.  The changes we made to our session management sagas were so extensive I think it is easier for us to start from scratch than it is to bring old tests back to green.  As we do so, I hope you see how much smoother our testing implementation has become.  By splitting small units of work into single-purpose generators, we can simplify testing dramatically.  

In fact, we can write almost this entire spec without needing to leverage the `cloneableGenerator` utility we introduced in previous chapters.  While I am not opposed to using this utility, its use can also signal opportunities to refactor our work into smaller units.  Removing this usage by isolating lines of work also has the side effect of making our tests more readable overall, so it is win-win.

Here's is the updated spec.

``` javascript(/reactive-client/src/sagas/manage_user_session.spec.js)
/* global expect, jest */
import { call, put, fork, take, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import { cloneableGenerator, createMockTask  } from 'redux-saga/utils';

import axiosCreateClient from './utils/axios_client';
import redirectToPathIf from './utils/redirect_path';

import { handleSignIn, handleSignOut, manageUserTimeout, manageUserSession } from './manage_user_session.js';
import * as routes from '../constants/settings';
import { setUser, clearUser } from '../actions/user';
import { SIGNAL_SIGNOUT } from '../constants/user';
import { clearAlerts } from '../actions/alerts';
import retrieveUserBookmark from './utils/retrieve_bookmark';

let generator, clone, mock_task;
describe("manageUserSession", ()=>{
  let saga;
  it("Waits for auth route, or rehydration, and continue to wait until token found",()=>{
    saga = manageUserSession();
    expect(saga.next().value).toEqual(take([routes.AUTH_ROUTE, "persist/REHYDRATE"]));
  });
  
+   it("continue to wait until token is given, then forks work an redirects",()=>{
+     expect(saga.next({payload: {user: {}}}).value).toEqual(take([routes.AUTH_ROUTE, "persist/REHYDRATE"]));
+     expect(saga.next({payload:  { token: "sometoken", bounce_path: "somepath"}}).value).toEqual(fork(handleSignIn,"sometoken"));
+     mock_task = createMockTask();
+     expect(saga.next(mock_task).value).toEqual(call(redirectToPathIf,"somepath"));
+   });
+   
+   it("waits for sign-out, then cancels active sign-ins, and begin sign-out", () =>{
+     expect(saga.next().value).toEqual(take(SIGNAL_SIGNOUT));
+     expect(saga.next().value).toEqual(cancel(mock_task));
+     expect(saga.next().value).toEqual(call(handleSignOut));
+   });
+ });

describe("handleSignIn", ()=>{
  generator = cloneableGenerator(handleSignIn)("mocktoken"); 
  it("sets up a client, and callls '/api/hydrate_user'", ()=>{
    let pub_client = {"get": jest.fn()};
    expect(generator.next().value).toEqual(call(axiosCreateClient,false));
    expect(generator.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + "mocktoken"));
    clone = generator.clone();
  });
  
  it("forks a manageUserTimeout thread, sets the user, and fetches bookmarks", ()=>{
    let response = {data: {expires: 100}};
    expect(generator.next(response).value).toEqual(fork(manageUserTimeout,100));
    expect(generator.next().value).toEqual(put(setUser(response.data)));
    expect(generator.next().value).toEqual(call(retrieveUserBookmark));
  });
  
  describe("RED PATH", ()=>{
    it("calls signout on errors", ()=>{
      expect(clone.throw({message: "error"}).value).toEqual(call(handleSignOut,"error"));
    });
  });
});

describe("manageUserTimeout", ()=>{
  it("limits timeout to 2147000000 milliseconds", ()=>{
    generator = manageUserTimeout(2147001);
    expect(generator.next().value).toEqual(call(delay, 2147000000));
  });
  
  it("delays by countdown * 1000, then calls handleSignOut", ()=>{
    generator = manageUserTimeout(10);
    expect(generator.next().value).toEqual(call(delay, 10000));
    expect(call(handleSignOut,"Your Session has expired, please sign in again."));
  });
});

describe("handleSignOut", () =>{
  it("Delivers a custom message if provided",() => {
    generator = handleSignOut("Custom message");
    [1,2].forEach(()=>{ generator.next() });
    expect(generator.next().value["PUT"]["action"]["payload"]["message"]).toEqual("Custom message");
  });
  
  it("clears user session", ()=> {
    generator = handleSignOut();
    expect(generator.next().value).toEqual(put(clearUser()));
  });
  
  it("clears alerts, adds a new alert, delays, and clears alerts again.", ()=> {
    expect(generator.next().value).toEqual( put(clearAlerts()));
    expect(generator.next().value["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
    expect(generator.next().value).toEqual( call(delay,3000) );
    expect(generator.next().value).toEqual( put(clearAlerts()) );
  });
});

/*describe("hydrateUser GREEN path", () => {
  let path =encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
  test("then sets up a public axios client",() =>{
    expect(saga.next().value).toEqual(call(axiosCreateClient,false));
  });
  
  test("saga then trades temp token for long-term",() => {
    let pub_client = {"get": jest.fn()};
    expect(saga.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token));
  });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});

describe("hydrateUser RED path", () => {
  let saga = hydrateUser();

  test("begins by redirecting if path provided",() => {
    let error = saga.next(new Error()).value;
    expect(error["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
  });
}); */
```

You should be comfortable with the majority of this file from our previous work, so I am not covering it in depth.  However, we are introducing a new saga utility we have not seen before, `createMockTask`.  

When forking lines of work in a saga, we need a way to test out any cancellation functionality.  To do this, redux Saga provides `createMockTask` which provides us a stand-in for the task pointer returned by Redux Saga's `fork` effect.  To utilize this task, we need to pass it to the invocation of our generators `next` method so that it is received by the `yield` statement immediately **after** our use of `fork` inside our generator.  

We then keep this mock task at the ready until we are ready to test our `cancel` effect.  At which point, we pass in the mock task to ensure the effect is appropriately instructing the saga middleware to cancel the task.

To finish up our client-side tests, we need to make some small changes to our test suite for `redirectToPathIf` as well.

``` javascript(/reactive-client/src/sagas/utils/redirect_path.spec.js)
/* global expect */
import redirectToPathIf from './redirect_path';
import { put } from 'redux-saga/effects';

describe("redirectToPathIf", () => {
  test("returns path action", ()=> {
    let sample = {type: "ROUTE_ACTION", payload: {test: "value"}};
    let encoded_sample = encodeURIComponent(JSON.stringify(sample));
    let generator = redirectToPathIf(encoded_sample);
    expect(generator.next().value).toEqual(put(sample));
  });
});
```

## Summary

In this chapter, we have finally completed the login, and session management functionality we started in Chapter 11.  We now have a reliable mechanism in place for managing user sessions across our application, and throughout the user's session lifecycle on our application. 

With that in place, we are nearing a point where we are ready for the first release of our application.  At this point, we have a minimalist implementation of our E-Reader.  It is not the most robust reader the internet has ever seen, but it delivers the core set of features needed for a user to utilize our application.

We will be spending the last few chapters of this book preparing for release.  

Beginning next chapter, we will perform a redesign of our front-end UI to polish our presentation, primarily with an eye on improving our layout's responsive design to better support small screen resolutions on mobile and tablet devices.

Then, in Chapter 16, we will perform an overall refactor of our application to clean up our codebase before release. We will add some tests for our components, a task I have thus far avoided while our application UI has been in a state of constant transition.   I also plan to add some end to end tests to our application using Capybara to execute web driver based integration tests to verify critical functions at the top-level of our application.  

Finally, in chapter 17, we release, bringing our application online for the first time on a public domain.