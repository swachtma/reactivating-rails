# Chapter 14: Synchronicity in Sagas

In chapter 14 we improve our login system's management of user tokens that expire in the midst of an ongoing session.  Revisiting authentication and user hydration, we rewrite our sagas using advanced concurrency patterns to more effectively manage these processes.

Our goal for this iteration is creating a mechanism for tokens to expire gracefully; causing minimal disruption to our users.

## Getting Started 

If you're starting here or jumping between chapters, I recommend executing the code below to clone the project and check out the branch for this chapter.

``` bash
# Copy and paste the following commands to check out the starter commit
git clone https://github.com/swachtma/reactivating-rails-app.git && \
cd reactivating-rails-app && \
git checkout ch14-starter
```

## Writing Descriptive Sagas

One complaint I have with our current Sagas is that work for a single user-journey divides across several different sagas and files.  

Our user hydration and dehydration sagas are an example of this.  Think about sign-out for example; we have tied that saga to any dispatch of the `CLEAR_USER` action.  However, this saga is only relevant after a user has signed into our application.  That's not a catastrophic problem.  We could call `CLEAR_USER` repetitively all day long, and our `dehydrateUser` saga would attempt to clear our user's credentials.  If there don't happen to be user credentials in the store, Redux will still happily go through the motions for us.

From a designer's perspective though, it's a shame our login process spreads across 2 different sagas (and four files counting each saga, our Axios client, redirect utility function).  A new developer coming onboard would need to reconstruct the whole process from these fractured pieces to understand the way the system works as a whole.

There is also a hidden problem with this design or one we have thus far ignored.  

When users return after a previous session, Redux Persist is helpfully restoring their profile and token from the browser's local storage.  However, that rehydration process does nothing to ensure the token it is restoring hasn't expired since our last visit to the site.  We first check the token's validity when making an authenticated request against our API.  That's not ideal; I don't want to interrupt my user, in the midst of reading, by suddenly squawking about an expired token.

With that in mind, here are our iteration goals:
* Sign in, and sign out should exist as a single saga.
* This saga's scope should expand to cover user rehydration on return visits.
  * Rehydration should ensure the token restored is still valid.
    * If a token is expired, or expiring soon, we should sign out the user on their initial page load
    * A message should appear for expired tokens, prompting the user to sign in again.
    * Token expiration must be checked proactively throughout its life and cleared when expired.

Let's start with a refactor preserving existing behavior in our application while merging sign-in and sign-out into a single saga.

## Preparing our Refactor

Before we begin, let's trim away some deadwood.  Open your root saga, and make the following changes.

``` javascript(/client/src/sagas/root.js)
import { all } from 'redux-saga/effects';
import { watchBookRoutesSaga } from './instantiate_book';
import { watchRoutesToClearAlerts } from './clear_alerts';
import { manageUserSession } from './manage_user_session';
import { watchBookmarkChanges } from './set_bookmarks';


export default function* rootSaga(){
  yield all([
    watchBookRoutesSaga(),
    watchRoutesToClearAlerts(),
+     manageUserSession(),
    watchBookmarkChanges()
  ]);
}
```

Remove `watchSignout` entirely and rename our sign-in saga `watchAuthRoutes` to `manageUserSession` to describe its new role handling sign-in, rehydration, and sign-out.

Take a moment and also rename your file `/client/src/sagas/hydrate_user.js` to `/client/src/sagas/manage_user_session.js` as well to reflect the saga's new name.

## Pausing Sagas for Actions

Prebaked effects like `takeEvery` and `takeLatest` are perfect when we want to repeat a series of steps every time actions dispatch.  What happens though when certain actions aren't valid under all circumstances?  Should we listen for sign-out actions, before a user authenticates?  Do we want to honor a second sign-in request during an active user session?  Scenarios like these are where the `take` effect comes into play.

`take` allows us to write sagas that pause their execution until a specific action dispatches.  We can use it to create nuanced response patterns for our sagas.

When using `take` in a saga, you may not need a watcher saga at all.  With `take` we can create sagas that listen for different actions across their lifecycle as other aspects of our state change.  

We are going to write a single saga for user authentication that listens for sign-in, and rehydration actions early lifecycle.  Then that same saga changes to listen for sign-out and token expirations once a user session begins.

We can get a first look at the `take` effect by removing the watcher saga that has previously managed sign-in.  

``` javascript(/client/src/sagas/manage_user_session.js)
+ import { takeLatest, put, call, take } from 'redux-saga/effects';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import { setUser } from '../actions/user';
import { addAlert } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(/*action*/){
+  while(true){
    try{
+       let action = yield take(routes.AUTH_ROUTE);
+       yield call(redirectToPathIf,action.payload.bounce_path); 
        
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
    } catch(e){
      yield put(addAlert(e.message,"warning"));
  }
  }
} 
```

Historically, our watcher saga `watchAuthRoutes` started our user hydration saga every time someone landed on our `AUTH_ROUTE` after being redirected from GitHub.

We rewrite this pattern using `take` to replace our watcher in the example above.  You probably noticed the `while(true)` loop wrapping our entire saga.  In a normal function, this infinite loop would be a catastrophic oversight.  Remember though; generators are not normal functions.  A generator suspends its execution each time it comes to a `yield` statement, and only reasserts control after resolving the yielded statement.

With Redux Saga, we are passing execution to the saga middleware each time we invoke an effect.  In the case of `take`, we are pausing until a matching action dispatches to our store.  Our while loop, and `take` effect listen for dispatches of `AUTH_ROUTE`, and executes our sign-in logic as a response.  The loop then repeats back on itself and again pauses until the next dispatch of the `AUTH_ROUTE` action.

The critical difference is that our original approach using `takeLatest` would automatically cancel any ongoing executions of the saga from previously dispatches.

You might also notice we wrapped `redirectToPathIf` inside a `call` effect.  This utility function is the only one not created as a generator.  I'm changing that now to promote easier testing and to standardize these utility methods used inside our sagas.

Make the following changes to `redirectToPathIf` before proceeding.

``` javascript(/client/src/sagas/utils/redirect_path.js)
import { put } from 'redux-saga/effects';

+ export default function* redirectToPathIf(path){
  if(path){
    let rd = decodeURIComponent(path);
    rd = JSON.parse(rd);
+     yield put(rd);
  }
}
```

## Switching Monitored Actions

Let's move forward again by pulling our sign-out behavior into this saga.

``` javascript(/client/src/sagas/manage_user_session.js)
+ import { put, call, take } from 'redux-saga/effects';
+ import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action = yield take(routes.AUTH_ROUTE);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
+       // Wait for Sign Out, and then...
+       yield take(user_actions.CLEAR_USER);
+       yield put(clearAlerts());
+       yield put(addAlert("Sign out successful","danger"));
+       yield call(delay,3000);
+       yield put(clearAlerts());
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 
```

This code comes over almost entirely unchanged from our `dehydrateUser` saga.  Now, instead of allowing our loop to circle back immediately and accept another sign-in action, we are holding the loop to wait for a `CLEAR_USER` dispatch in our store.  Logically, this makes perfect sense; if a user authenticated, why honor any further attempts at authentication until the session terminates?

Let's make one additional refactor before moving on.

``` javascript(/client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action = yield take(routes.AUTH_ROUTE);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
      let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
+       yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignOut() {
+   yield put(clearAlerts());
+   yield put(addAlert("Sign out successful","danger"));
+   yield call(delay,3000);
+   yield put(clearAlerts());
}
```

The signout flow of clearing existing alerts, placing a sign-out notification, and then timing that alert's removal is a short standalone process.  Externalize units of work into isolated generators to keep our units of code small and testable.

## Listening to Complex Conditions

Now we are ready to start expanding our functionality.  

Our application should check our token's validity during each rehydration from our store.  That means sign-in isn't the only precursor action our saga should accept before a sign-out action.  

We are going to update our saga to listen for the action Redux-Persist dispatches when restoring a user's session, `persist/REHYDRATE`.  We have a complication though; look at the action Redux-Persist dispatches when restoring a user.

``` javascript
{
  type: 'persist/REHYDRATE',
  payload: {
    user: {
      id: 1,
      github_email: 'swachtma@gmail.com',
      username: 'swachtma',
      avatar: 'https://avatars0.githubusercontent.com/u/1584720?v=4',
      token: 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJodHRwOi8vMTM4LjE5Ny4xNC41OjgwODAiLCJpZCI6MSwiZXhwIjoxNTIzNTMyNjg1LCJpYXQiOjE1MjA5NDA2ODV9.Ah9eE8QvWcw4dcue3YhPd64jqBx1x_hhj7w5KKxOttI'
    },
    _persist: {
      version: -1,
      rehydrated: true
    }
  },
  key: 'root'
}
```

This object and our sign-in action use different payload structures.  We need to locate our token from either action format to send it to our API for verification.

``` javascript(/client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
+       let action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
+       let token = action.payload.token || action.payload.user.token; 
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      const pub_client = yield call(axiosCreateClient,false);
+       let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
      yield put(setUser(user.data));
      
      yield call(retrieveUserBookmark);
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

Easy enough on the surface, but there is a problem.  Refresh your browser and see what happens if your application instantiates **without** a user token in storage available.

![Error Alert Warning: Your session has expired or is no longer valid, please sign in again.](/images/13/SessionExpiredOrInvalid.png)

What's going on here?  If you investigate in the Redux Developer Tools, the problem is easy to spot.  Redux-Persist dispatches its rehydration action even when there is no token in storage.  When that action triggers our saga, we end up passing an undefined value in `token` to our API.  

We need to prepare for the possibility that a dispatched rehydration action might not indicate we are restoring a user session.  Here is where `take` begins to shine.

``` javascript(/client/src/sagas/manage_user_session.js)
import { put, call, take } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
+       let action,token;
+       while(!token){
+         action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
+         token = action.payload.token || action.payload.user.token; 
+       }
      
+       yield call(handleSignIn,token);
        yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

+ export function* handleSignIn(token){
+   const pub_client = yield call(axiosCreateClient,false);
+   let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
+   yield put(setUser(user.data));
+   yield call(retrieveUserBookmark);
+ }

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

Our saga now waits for a sign-in or rehydration action until one not only dispatches but also provides a `token`.  Once `token` is defined, our first loop terminates advancing our saga to the API requests completing sign-in/rehydration.

We are also externalizing our sign-in flow into a standalone generator.  This change is made partly for testability, but there's another reason as well: concurrency.  

## Forking Saga Work

Right now, sign-in blocks our saga until our API communication is complete.  However, that does not need to be the case.

``` javascript(/client/src/sagas/manage_user_session.js)
+ import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action,token;
      while(!token){
        action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
        token = action.payload.token || action.payload.user.token; 
      }
      
+       let sign_in = yield fork(handleSignIn,token);
        yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
      yield take(user_actions.CLEAR_USER);
+       yield cancel(sign_in);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignIn(token){
  const pub_client = yield call(axiosCreateClient,false);
  let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
  yield put(setUser(user.data));
  yield call(retrieveUserBookmark);
}

export function* handleSignOut() {
  yield put(clearAlerts());
  yield put(addAlert("Sign out successful","danger"));
  yield call(delay,3000);
  yield put(clearAlerts());
}
```

The `fork` effect in this latest example is an effect very similar to the `call` effect we have used previously.  Both `fork` and `call` send instructions to the saga middleware to execute a function.  The difference is that `fork` executes asynchronously (non-blocking), allowing the saga to proceed immediately to our redirect and monitoring for a sign-out dispatch.  

Exercise this power responsibly; we need to consider all outcomes carefully when forking work.  Consider what happens if a sign-out dispatch follows our sign-in process so quickly that work is still underway.  You could end up in a state where you are firing sign-out instructions while you're still hydrating a user.  That could leave you with a broken state.

Luckily, `fork` gives us a remedy to this risk.  When you call the `fork` effect, Redux Saga returns a pointer to the task.  If you need to stop that task prematurely, you can pass that pointer to another effect, `cancel` which aborts its execution.  

We do this above to ensure we have no active sign-in efforts underway before running our sign-out logic.

# Handling Session Expirations with Forked Work

We have login and logout merged into a single saga.  However, in doing so, we have also emphasized a security hole in our design.  

By linking our rehydration action to our `AuthenticationController`, we have created a mechanism which refreshes our user token's expiration every time it rehydrates.  That's unacceptable because it means once someone gets a user's token they can refresh it infinitely to retain account access.  This design flaw has always been present in our controller, but we accentuated the problem by connecting this workflow directly to our UI.

Let's address this issue as we deal with some other problems related to our session timeout.

First, I am going to rewrite our `TokenOps` class and `AuthenticationController` to only allow a token refresh when a user hits our authentication controller with a specially marked short-term token.

``` ruby(/api/app/controllers/concerns/token_ops.rb)
module TokenOps
  extend ActiveSupport::Concern
+   def self.encode(expires, user, type = "SHORT")
+     payload = {
+       iss: ENV['CLIENT_URL'],
+       id: user.id,
+       type: type,
+       exp: expires.to_i,
+       iat: Time.now.to_i
+     }
+     JWT.encode payload, ENV['JWT_SECRET'], 'HS256'
+   end

  def self.decode(token)
    options = {
      iss: ENV['CLIENT_URL'],
      verify_iss: true,
      verify_iat: true,
      leeway: 30,
      algorithm: 'HS256'
    }
    JWT.decode token, ENV['JWT_SECRET'], true, options
  end
end
```

Our separate `encode_long` and `encode_short` functions were adding complexity, so I am migrating back to using a single encode and decode method.  The `encode` method, now accepts a specific expiration time passed as its first parameter and adds a `type` key to our token payload.  We can use this type value to validate whether our token is eligible for a refresh or not.

Next, refactor `AuthenticationController` to leverage these altered methods.

``` ruby(/api/app/controllers/api/authentication_controller.rb)
class Api::AuthenticationController < ApplicationController
  include TokenOps
  
  def github
    begin
      code = params[:code]
      bounce_path = ERB::Util.url_encode(params[:bounce_path])
      github = Github.new client_id: ENV["GITHUB_CLIENT_ID"], client_secret: ENV["GITHUB_CLIENT_SECRET"]
      token = github.get_token(code).token
      
      github_users = Github::Client::Users.new oauth_token: token
      user = User.create_or_fetch(github_users.get)
+       jwt = TokenOps.encode(2.minutes.from_now.to_i, user, "SHORT")
      
      redirect_to "#{ENV["CLIENT_URL"]}/auth/#{jwt}/#{bounce_path}", status: 302
    rescue
      redirect_to "#{ENV["CLIENT_URL"]}/auth/githubfailure/#{bounce_path}"
    end
  end
  
  def show
    begin 
      token = params[:token]
+       decoded_token = TokenOps.decode(token)[0]
+       expires = decoded_token["exp"]
      user = User.find(decoded_token["id"])
      
+       if(decoded_token["type"] == "SHORT")
+         expires = 30.days.from_now.to_i
+         token = TokenOps.encode(expires, user, "LONG") 
+       end
+ 
+       countdown = (expires - Time.now).to_i
+       raise AuthenticationErrors::BadToken if countdown < 12 * 60 * 60
+       
+       render json: user.fsa(token, countdown), status: 200
    rescue
      raise token == "githubfailure" ? AuthenticationErrors::GithubFailure : AuthenticationErrors::BadToken
    end
  end
end
```

We are now limiting this controller to generating a new token only when the user is beginning a new session, fresh from being redirected off GitHub's OAuth endpoint.  Only when their decoded token carries the type "SHORT".

We are also pulling the new `expiration` key from our token's payload. I want to send this value client-side to help us manage our user's session expirations in Redux Saga.  Since we cannot access the decoded token value client-side, we need to update our controller to pass this as decoded information.

We calculate a `countdown` value before generating our controller's response.  If the countdown calculates that the remaining token expiration time is less than twelve hours, we are going to raise our `AuthenticationErrors::BadToken` exception.  

This exception causes our client to clear the active user from our state, and prompt for a fresh login.  This preemptive expiration minimizes the chance a user's session might expire in the middle of their active time on our website.  If the token is nearing expiration, I would rather have the user sign in at the start of a visit, than have them suddenly be signed out in the middle of a task with an explanation.

Here is our updated `User.fsa` method:

``` ruby(/api/app/models/user.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

class User < ApplicationRecord
  has_one :bookmark
  
+  def fsa(token, expires)
    {
      id: id,
      github_email: github_email,
      username: username,
      avatar: avatar,
      token: token,
+       expires: expires
    }
  end
  
-   def self.create_or_fetch(user)
-     find_by(github_id: user.id) || create(
-       github_id: user.id,
-       github_email: user.email,
-       username: user.login,
-       avatar: user.avatar_url
-     )
-   end
end
```

Now that we a timer for our user's remaining session duration; modify your client-side code to handle this countdown.

``` javascript(/client/src/sagas/manage_user_session.js)
import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser, clearUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

- export function* manageUserSession(){
-   while(true){
-     try{
-       let action,token;
-       while(!token){
-         action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
-         token = action.payload.token || action.payload.user.token; 
-       }
-       
-       let sign_in = yield fork(handleSignIn,token);
-       yield call(redirectToPathIf,action.payload.bounce_path); 
-       
-       // Wait for Sign Out, and then...
-       yield take(user_actions.CLEAR_USER);
-       yield cancel(sign_in);
-       yield call(handleSignOut);
-     } 
-     catch(e){
-       yield put(addAlert(e.message,"warning"));
-     }
-   }
- } 

export function* handleSignIn(token){
  try {
    const pub_client = yield call(axiosCreateClient,false);
    let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
+   yield fork(manageUserTimeout,user.data.expires);
    yield put(setUser(user.data));
    yield call(retrieveUserBookmark);
  }
  catch(e){
    yield put(addAlert(e.message,"warning"));
  }
}

+ export function* manageUserTimeout(countdown){
+   // delay timeout cannot exceed 32-bit int (2147483647) or ~24 days
+   countdown = countdown >= 2147000 ? 2147000 : countdown;
+   yield call(delay, countdown);
+   yield put(addAlert("Your session has expired, please sign in again.","danger"));
+   yield put(clearUser());
+ }

- export function* handleSignOut() {
-   yield put(clearAlerts());
-   yield put(addAlert("Sign out successful","danger"));
-   yield call(delay,3000);
-   yield put(clearAlerts());
- }
```

When a user signs-in, or rehydrates a session, we are using their countdown timer to start a forked process.  This process uses the Redux Saga's `delay` to suspend a sign-out until our token's expiration.  Once the timer elapses, we clear the user session and display an alert.

You might be wondering why we are checking that our counter length is less than 2147483647.  Redux Saga's `delay` effect utilizes JavaScript's `setTimeout` method, which limits its timer value to a 32-bit integer.  Overflowing this counter with a larger value expires it immediately, breaking our delay.

This code is almost right.  The problem is our saga doesn't clear the user's information on sign-out.  The saga listens for `CLEAR_USER` actions and displays some additional alert messaging.  However, clearing user information from our store is the domain of `CLEAR_USER` itself.  This approach is forcing me to needlessly repeat code in my Saga now that there are multiple ways to trigger a session's termination.

Let's rewrite our sign-out logic so that our UI components trigger an action, which in turn advances our saga, but leaves clearing user state to the saga itself.

To begin, create a new constant to be our saga's new trigger, and an action creator for this new action type.

``` javascript(/client/src/constants/user.js)
export const SET_USER = "SET_USER";
+ export const SIGNAL_SIGNOUT = "SIGNAL_SIGNOUT";
export const CLEAR_USER = "CLEAR_USER";
```

``` javascript(/client/src/actions/user.js)
import * as constants from "../constants/user";

- export const setUser = (payload) => ({
-   type: constants.SET_USER, payload
- });

+ export const signalSignout = () => ({ type: constants.SIGNAL_SIGNOUT });
export const clearUser = () => ({ type: constants.CLEAR_USER }) ;
```

Then update our provider/container to bind this new action to our component state.

``` javascript(/client/src/containers/user_provider.js)
import { connect } from 'react-redux';

import UserBadge from '../components/user_badge';
+ import { signalSignout } from '../actions/user';

- export const connectToUser = (WrappedComponent) => {
-    return connect(mapStateToProps,mapDispatchToProps)(WrappedComponent);
- };

- const mapStateToProps = (state) => ({
-   username: state.user.username,
-   avatar: state.user.avatar
- });

const mapDispatchToProps = (dispatch) => ({
+   dispatchSignalSignout: (e) => dispatch(signalSignout())
});

// EXPORTABLE CONNECTED COMPONENTS
export const ConnectedUserBadge = connectToUser(UserBadge);
```

``` javascript(/client/src/components/user_badge.js)
import React, { Component } from 'react';
import { Image, Menu, Dropdown } from 'semantic-ui-react';

import ConnectedGitHubIcon from './github_icon';

class UserBadge extends Component {
  render() {
    if(!this.props.username){
      return (
        <ConnectedGitHubIcon />
      );
    } else {
      let badge = <Image src={this.props.avatar} avatar />;
      return (
        <Menu.Item name={this.props.username}>
          <Dropdown icon={badge} compact pointing="top right">
            <Dropdown.Menu>
+               <Dropdown.Item onClick={this.props.dispatchSignalSignout}>Sign Out</Dropdown.Item>
            </Dropdown.Menu>
          </Dropdown>
        </Menu.Item>
      );
    }
  }
}

export default UserBadge;
```

Finally, modify our Saga to leverage these new distinct actions for triggering and executing sign-out.

``` javascript(/client/src/sagas/manage_user_session.js)
import { put, call, take, fork, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import axiosCreateClient from './utils/axios_client';

import * as routes from '../constants/settings';
import * as user_actions from '../constants/user';
import { setUser, clearUser } from '../actions/user';
import { addAlert, clearAlerts } from '../actions/alerts';
import redirectToPathIf from './utils/redirect_path';
import retrieveUserBookmark from './utils/retrieve_bookmark';

export function* manageUserSession(){
  while(true){
    try{
      let action,token;
      while(!token){
        action = yield take([routes.AUTH_ROUTE,"persist/REHYDRATE"]);
        token = action.payload.token || action.payload.user.token; 
      }
      
      let sign_in = yield fork(handleSignIn,token);
      yield call(redirectToPathIf,action.payload.bounce_path); 
      
      // Wait for Sign Out, and then...
+       yield take(user_actions.SIGNAL_SIGNOUT);
      yield cancel(sign_in);
      yield call(handleSignOut);
    } 
    catch(e){
      yield put(addAlert(e.message,"warning"));
    }
  }
} 

export function* handleSignIn(token){
  try {
    const pub_client = yield call(axiosCreateClient,false);
    let user = yield call([pub_client, "get"], "/api/hydrate_user?token=" + token);
    
    yield fork(manageUserTimeout,user.data.expires);
    yield put(setUser(user.data));
    yield call(retrieveUserBookmark);
  }
  catch(e){
+     yield call(handleSignOut,e.message);
  }
}

export function* manageUserTimeout(countdown){
  // delay timeout cannot exceed 32-bit int (2147483647) or ~24 days
  countdown = countdown >= 2147000 ? 2147000 : countdown;
  yield call(delay, countdown);
+   yield call(handleSignOut,"Your Session has expired, please sign in again.");
}

+ export function* handleSignOut(message) {
+   message = message || "Sign out successful";
+   yield put(clearUser());
+   
+   yield put(clearAlerts());
+   yield put(addAlert(message,"warning"));
+   yield call(delay,3000);
+   yield put(clearAlerts());
}
```

Our `handleSignOut` generator function now manages all potential precursors that might terminate a user's session.  

Since our saga now controls clearing a user's credentials from our store, we can use this one method for all paths of our logic.  If a user's session expires, or if they attempt to send an invalid token to our controller, we can pass the specific messaging from our server-side error to `handleSignOut` to override its default messaging.

We now have a comprehensive system for managing user authentication across its lifecycle in our application.  There's one outcome of our saga we have not discussed though.  

When we set up `manageUserTimeout`, we forked it off the sign in process.  What happens if before a user's session expires, they explicitly trigger a sign-out?  Do we still have a countdown running that might call another sign-out action when its timer expires?  It turns out, no.  

Redux Saga's `fork` effect creates what is called an "attached" fork.  With an attached fork, Redux Saga automatically handles cancellation for us if the saga terminates, errors, or is canceled somewhere up the chain.

This automatic cancellation means that on a `SIGNAL_SIGNOUT` dispatch, when we call `yield cancel(sign_in)`, that the attached fork for our timer dies as well.  So no matter how our session winds up ending, we don't need to worry about a lingering timer.  

Redux Saga also offers a `spawn` effect, which functions similarly to `fork`, but creates a "detached" fork.  A detached fork remains active even if the parent that began its execution fails or cancels.  We don't need it here, but keep it in mind as a tool for your toolkit when working with sagas.

## Refactoring API Tests

The updates we made to `TokenOps` and `AuthenticationController` have broken some tests.

Several have broken because we changed the interface on `TokenOps.encode`.  We have a helper function in our controller tests leveraging this function to handle authenticated requests.  Update this method to the new `encode` format and change the helper method itself to accept specific token expiration and type values.  

This helper allows us to painlessly prepare tests when we need an expired or nearly expired, token.

``` ruby(/api/spec/helpers.rb)
module Helpers
  def request_as(user, exp = 25.hours.from_now, term = "LONG")
   return {"Authorization" => TokenOps.encode(exp, user, term) }
  end
end
```

Our `User` model spec also needs updating to account for the changes in its `fsa` method.

``` ruby(/api/spec/models/user_spec.rb)
- # == Schema Information
- #
- # Table name: users
- #
- #  id           :integer          not null, primary key
- #  github_id    :integer
- #  github_email :string
- #  username     :string
- #  avatar       :string
- #  created_at   :datetime         not null
- #  updated_at   :datetime         not null
- #

require 'rails_helper'

RSpec.describe User, type: :model do
-   before(:each) do
-     @user = User.create({
-         github_id: 2,
-         github_email: "test@test.com",
-         username:"something_witty",
-         avatar:"someimage.gif",
-       })
-   end
  
  it "provides .fsa(token) to produce user FSA response object" do
+    fsa = @user.fsa("sometoken", 200000)
   expect(fsa[:username]).to eq @user.username
   expect(fsa[:token]).to eq "sometoken"
  end
  
-   describe "create_or_fetch" do
-     it "creates a new user if one cannot be found" do
-       User.create_or_fetch(OpenStruct.new({
-         id: 1,
-         email: "someone",
-         username: "someoneelse",
-         avatar: "someimage"
-       }))
-       
-       expect(User.all.count).to eq 2
-     end
-     
-     it "returns a recond by github_id if available" do
-       requested_user = User.create_or_fetch(OpenStruct.new({id: 2}))
-       expect(requested_user).to eq @user
-       expect(User.all.count).to eq(1)
-     end
-   end
end
```

Our `TokenOps` class should ensure it provides both an `encode` and `decode` method and that the decoded token provides critical user ID and expiration values.  We also test that the class can encode and decode both of our SHORT and LONG token types.

``` ruby(/api/spec/controllers/concerns/token_ops_spec.rb)
require 'rails_helper'

RSpec.describe TokenOps do
    it "provides an encode and decode method" do
      expect(TokenOps.respond_to? :encode).to be true
      expect(TokenOps.respond_to? :decode).to be true
    end
    
    describe "encode" do
      before(:each) do
        @user = User.create({
          github_id: "test",
          github_email: "test@test.com",
          username:"something_witty",
          avatar:"someimage.gif",
        })
      end
      
      describe "defaults" do
        before(:each) do
          token = TokenOps.encode(2.minutes.from_now, @user)
          @decoded = TokenOps.decode(token)[0]
        end
        
        it "provide an id value and expiration when decoded" do
          expect(@decoded["id"]).not_to be_nil
          expect(@decoded["exp"]).not_to be_nil
        end
        
        it "default to SHORT type, if not specified" do
          expect(@decoded["type"]).to eq "SHORT"
        end
      end
      
      describe "explicit LONG" do
        it "can be decoded" do
          token = TokenOps.encode(30.days.from_now, @user)
          decoded = TokenOps.decode(token)[0]
          expect(decoded["exp"]).not_to be_nil
        end
      end
  end
end
```

`AuthenticationController` has several edge cases that are difficult to reproduce in the real world.  Rspec however, makes producing these conditions easy.

1. A short-term token should have its expiration extended when traded for a LONG token.
2. A LONG token should **never** have its expiration extended.
3. A token with less than 12 hours left in its life is considered expired and should raise an exception.

``` ruby(/api/spec/controllers/api/authentication_controller_spec.rb)
require 'rails_helper'

RSpec.describe Api::AuthenticationController, type: :controller do
-   describe "GET #github" do
-     let(:sample_response) { OpenStruct.new({id: 1, email: "", login: "", avatar_url: ""}) }
-    
-     before(:each) do
-       #create a stub for main Github API class.  Stub is then allowed to respond to 
-       # .get_token(code).token chain of our controller with a fake token.
-       github = double("github")
-       class_double("Github", :new => github).as_stubbed_const(:transfer_nested_constants => true)
-       allow(github).to receive_message_chain(:get_token, :token) { "fake token" }
-       
-       #Similar to above we mock the Client::Users class then allow the returned double
-       #github_users to respond to #get with a mocked user profile response.
-       @github_users = double("@github_users")
-       allow(Github::Client::Users).to receive(:new) { @github_users }
-       allow(@github_users).to receive(:get) { sample_response }
-     end
-     
-     it "returns http success for new users" do
-       get :github
-       expect(response).to have_http_status(302)
-     end
-     
-     it "returns http success for existing users" do
-       User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
-       get :github
-       expect(response).to have_http_status(302)
-     end
-   end
  
  describe "GET #show" do
    before(:each) do
      @user = User.create(github_id: 1, github_email: "someone", username: "someoneelse", avatar: "someimage")
      @token = TokenOps.encode(2.minutes.from_now, @user)
    end
      
    it "returns a user profile on valid SHORT token" do
      get :show, params: {:token => @token}
      expect(response).to have_http_status(:success)
      expect(JSON.parse(response.body)).to include("id","username","github_email","token","avatar","expires")
    end
    
+     it "updates expiration if token is type == SHORT" do
+       get :show, params: {:token => @token}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["expires"]).to be > 2.days.from_now.to_i - Time.now.to_i
+     end
    
+     it "does not update expiration if type == LONG" do
+       get :show, params: {:token => TokenOps.encode(14.days.from_now, @user, "LONG")}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["expires"]).to be < 15.day.from_now.to_i
+     end
    
+     it "raises AuthenticationErrors::BadToken if expiration < 12 hours" do
+       get :show, params: {:token => TokenOps.encode(11.hours.from_now, @user, "LONG")}
+       expect(response).to have_http_status(:success)
+       expect(JSON.parse(response.body)["type"]).to eq "ERROR|FAILURE"
+     end
  end
end 
```

## Refactoring Client-Side Tests

Before client-side testing, let's remove files no longer needed in our application.  If you haven't already, delete `/client/src/sagas/dehydrate_user.js`, and its corresponding spec.

Client-side changes have also broken many of our existing tests.  Changes to our session management sagas were so extensive I think it is easier to start from scratch than refactor existing tests.  As we rebuild, I hope you notice how much easier testing our implementation has become.  By splitting units of work into single-purpose generators, we can simplify testing dramatically.  

We can write almost this entire spec without needing to leverage the `cloneableGenerator` utility introduced in previous chapters.  While I am not opposed to `cloneableGenerator` it tends to make tests less readable, and its use can signal opportunities to refactor.

Here's is our updated spec.

``` javascript(/client/src/sagas/manage_user_session.spec.js)
/* global expect, jest */
import { call, put, fork, take, cancel } from 'redux-saga/effects';
import { delay } from 'redux-saga';
import { cloneableGenerator, createMockTask  } from 'redux-saga/utils';

import axiosCreateClient from './utils/axios_client';
import redirectToPathIf from './utils/redirect_path';

import { handleSignIn, handleSignOut, manageUserTimeout, manageUserSession } from './manage_user_session.js';
import * as routes from '../constants/settings';
import { setUser, clearUser } from '../actions/user';
import { SIGNAL_SIGNOUT } from '../constants/user';
import { clearAlerts } from '../actions/alerts';
import retrieveUserBookmark from './utils/retrieve_bookmark';

let generator, clone, mock_task;
describe("manageUserSession", ()=>{
  let saga;
  it("Waits for auth route, or rehydration, and continue to wait until token found",()=>{
    saga = manageUserSession();
    expect(saga.next().value).toEqual(take([routes.AUTH_ROUTE, "persist/REHYDRATE"]));
  });
  
+   it("continue to wait until token is given, then forks work an redirects",()=>{
+     expect(saga.next({payload: {user: {}}}).value).toEqual(take([routes.AUTH_ROUTE, "persist/REHYDRATE"]));
+     expect(saga.next({payload:  { token: "sometoken", bounce_path: "somepath"}}).value).toEqual(fork(handleSignIn,"sometoken"));
+     mock_task = createMockTask();
+     expect(saga.next(mock_task).value).toEqual(call(redirectToPathIf,"somepath"));
+   });
+   
+   it("waits for sign-out, then cancels active sign-ins, and begin sign-out", () =>{
+     expect(saga.next().value).toEqual(take(SIGNAL_SIGNOUT));
+     expect(saga.next().value).toEqual(cancel(mock_task));
+     expect(saga.next().value).toEqual(call(handleSignOut));
+   });
+ });

describe("handleSignIn", ()=>{
  generator = cloneableGenerator(handleSignIn)("mocktoken"); 
  it("sets up a client, and callls '/api/hydrate_user'", ()=>{
    let pub_client = {"get": jest.fn()};
    expect(generator.next().value).toEqual(call(axiosCreateClient,false));
    expect(generator.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + "mocktoken"));
    clone = generator.clone();
  });
  
  it("forks a manageUserTimeout thread, sets the user, and fetches bookmarks", ()=>{
    let response = {data: {expires: 100}};
    expect(generator.next(response).value).toEqual(fork(manageUserTimeout,100));
    expect(generator.next().value).toEqual(put(setUser(response.data)));
    expect(generator.next().value).toEqual(call(retrieveUserBookmark));
  });
  
  describe("RED PATH", ()=>{
    it("calls signout on errors", ()=>{
      expect(clone.throw({message: "error"}).value).toEqual(call(handleSignOut,"error"));
    });
  });
});

describe("manageUserTimeout", ()=>{
  it("limits timeout to 2147000000 milliseconds", ()=>{
    generator = manageUserTimeout(2147001);
    expect(generator.next().value).toEqual(call(delay, 2147000000));
  });
  
  it("delays by countdown * 1000, then calls handleSignOut", ()=>{
    generator = manageUserTimeout(10);
    expect(generator.next().value).toEqual(call(delay, 10000));
    expect(call(handleSignOut,"Your Session has expired, please sign in again."));
  });
});

describe("handleSignOut", () =>{
  it("Delivers a custom message if provided",() => {
    generator = handleSignOut("Custom message");
    [1,2].forEach(()=>{ generator.next() });
    expect(generator.next().value["PUT"]["action"]["payload"]["message"]).toEqual("Custom message");
  });
  
  it("clears user session", ()=> {
    generator = handleSignOut();
    expect(generator.next().value).toEqual(put(clearUser()));
  });
  
  it("clears alerts, adds a new alert, delays, and clears alerts again.", ()=> {
    expect(generator.next().value).toEqual( put(clearAlerts()));
    expect(generator.next().value["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
    expect(generator.next().value).toEqual( call(delay,3000) );
    expect(generator.next().value).toEqual( put(clearAlerts()) );
  });
});

/*describe("hydrateUser GREEN path", () => {
  let path =encodeURIComponent(JSON.stringify(routeHome()));
  let action = { type: 'AUTH_ROUTE', payload: { token: "shortTermToken", bounce_path: path }};
  let sample_user = {data: {username: "SomeDude"}};
  let saga = hydrateUser(action);

  test("begins by redirecting if path provided",() => {
    expect(saga.next(path).value).toEqual(put(routeHome()));
  });
  
  test("then sets up a public axios client",() =>{
    expect(saga.next().value).toEqual(call(axiosCreateClient,false));
  });
  
  test("saga then trades temp token for long-term",() => {
    let pub_client = {"get": jest.fn()};
    expect(saga.next(pub_client).value).toEqual(call([pub_client, "get"], "/api/hydrate_user?token=" + action.payload.token));
  });
  
  test("saga then sets user state and alerts user", ()=> {
    let results = saga.next(sample_user);
    expect(results.value).toEqual(put(setUser(sample_user.data)));
  });
  
  test("saga then yields to retrieveUserBookmark", ()=> {
    expect(saga.next()["value"]["CALL"]["fn"]).toEqual(retrieveUserBookmark);
  });
});

describe("hydrateUser RED path", () => {
  let saga = hydrateUser();

  test("begins by redirecting if path provided",() => {
    let error = saga.next(new Error()).value;
    expect(error["PUT"]["action"]["type"]).toEqual("ADD_ALERT");
  });
}); */
```

Despite their length, you should be comfortable with the majority of these specs, so I am not covering them in depth.  However, we are introducing a new saga utility, `createMockTask`.  

When forking work in a saga, we need a way to test cancellation functionality.  To do this, redux Saga provides `createMockTask` which provides us a stand-in for the task pointer returned by Redux Saga's `fork` effect.  To utilize this utility, we need to pass it to the invocation of our generators `next` method immediately **after** our use of `fork` inside our generator.  We then keep this mock task at the ready until we are ready to test cancellation.

To finish our client-side tests, we need some small changes in our `redirectToPathIf` spec as well.

``` javascript(/client/src/sagas/utils/redirect_path.spec.js)
/* global expect */
import redirectToPathIf from './redirect_path';
import { put } from 'redux-saga/effects';

describe("redirectToPathIf", () => {
  test("returns path action", ()=> {
    let sample = {type: "ROUTE_ACTION", payload: {test: "value"}};
    let encoded_sample = encodeURIComponent(JSON.stringify(sample));
    let generator = redirectToPathIf(encoded_sample);
    expect(generator.next().value).toEqual(put(sample));
  });
});
```

## Summary

In this chapter, we finally completed the login, and session management functionality introduced in Chapter 11.  We have a reliable mechanism for managing user sessions across our application and throughout the session's lifecycle. 

We are nearing a point where we are ready for the first release of our application.  We have a minimalist implementation of our E-Reader, not the most robust the internet has ever seen, but a solid core.

Next chapter, we redesign our front-end UI to polish our presentation.  We focus primarily on improving our layout's responsive design to better support small screen resolutions on mobile and tablet devices.

Then, in Chapter 16, we perform an overall refactor of our application to clean up our codebase before release. We also add tests for our components, a task thus far avoided while our UI has been in constant transition.  Finally, in chapter 17, we release, bringing our application online for the first time on a public domain.