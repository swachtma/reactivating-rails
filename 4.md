
## Client side data structure 

We need to spend so time planning our client side data structure.  This is going to have a big influence of the way we populate and access our data store.  There are two approaches we commonly see in store design: deep structures vs. wide structures.

Deep structures tend to use nesting of related elements to create their organization.  And example for our purposes might look like the following:

```javascript
{
  content: [{chapter_id, title, nodes: [{node_id, markdown},{...}]}]
}
```

Here we see our two data type represented, at the simplest level we have our chapters, grouped into an array of objects.  We could order these elements inside our store to allow us to easily pull and print our chapters.  Our nodes are a little more complex.  We've nested the chapters inside an object structure similar to the related chapter content.  The advantage of this approach is most likely speed of access; if we want to pull all the nodes related to a specific chapter we have an easy ID we can use in the top level object to query off of.

The tradeof, is the complexity of populating this structure.  The drawback is harder to see with our simplified data model.  But imagine this structure applied to our full data layout:

```
{
  content: [{chapter_id, title, section: [
    { section_id, title, nodes: [
      { node_id, content }]
    }] 
  }]
}
```

Do you begin to see why this creates complexity when we need to load or update data?  If we need to update the nodes for a specific chapter/section we need to traverse the entire tree structure, find the content we need and then make our updates.  And to make that just a little more interesting redux will want us to return a NEW object, not an updated copy of the old object reference.  

I'll admit this is largely a matter of preference, but my preference is strongly for wide and flat redux stores.

In our case this will look more like the following:

```javascript
{
  chapters: [{id, title}, {...}]  
  sections: [{id, section_id, heading}, {...}]
  nodes: [{id, chapter_id, section_id, content},{...}]
}
```

This means when load new nodes, we can likely ignore the `chapters` and `sections` part of our store.  Our reducers can enforce business rules that are relevant to each part of the store.  And we have a way to easily and flexibily load only parts of our store content.  

For the moment, as we did with our API we are going to set aside the concept of sections entirely.  So our store paln will look like the following:

```javascript
{
  chapters: [{id, title}, {...}]  
  nodes: [{id, chapter_id, content},{...}]
}
```

We're going to use our active Record ID's to dictate content order.  This will rely on our API to load content acording to that schema (so far so sood).  We're also going to ensure our store's reducers **enforce** this rule.  When content is loaded, we'll ensure the array of chapters, or nodes, is sorted according to the ID schema.  So chapter.id == 1 will be positioned in front of chapter.id == 2.

Our lower level elements will enforce a multi-level sort, first sorting by the chapter_id value, and then the node's own id value afterwords.  

The reason for this policy is that it will allow our react componenets to be stupid about such logic.  Would you rather sort and order your store on the fly everytime you read content?  Or do it in one central place, and know your componenets can just pick a starting point in the document and print content in the order it's handed to them?  I know my vote.

## Installing Redux

We need to do a little setup before we can dive into our client work.

We're going to install Redux, as well as react-redux, which is the offical store connector for usage with React.
```
npm install --save redux
npm install --save react-redux
```

We're going to need to setup our store, and a provide it to our React components before we can start working with developing our data structure.

For a start let's look at providing our store to our application.  Create a new directory `src/reducers` inside you client folder structure.  And inside that directory, create a file `store.js`.  This will be the entry point into our redux store logic; here's we'll assemble our reducers into a single Root reducer function, apply middle ware, set defaults for our application state and other tasks. For now though, we're going to start small.

```javascript
import { createStore } from "redux";

const store = createStore((state,action) => state);

export default store;
```

We're using the `createStore` method provided to us by redux to instantiate a new store.  You'll notice inside we're providing a function as a parameter for the store: `createStore((state,action) => state);`.  That function is for the moment serving as our reducer.  A reducer, if you are not already familiar is a function that at it's simplest takes two arguments; the current state of our store, and an action.  And it returns a new state object.  We're going to revisit this concept in a moment, once we've wired in our store to our React components.

Open `src/index.js` and modify it as follows:

``` javascript
import React from 'react';
import ReactDOM from 'react-dom';
import { Provider } from 'react-redux';
import store from './reducers/store';
import './index.css';
import App from './App';
import registerServiceWorker from './registerServiceWorker';

window.store = store;

ReactDOM.render(
  <Provider store={store}>
      <App />
  </Provider>
  ,document.getElementById('root')
);
    
registerServiceWorker();
```

We are wrapping our top level `App` componenet inside the High Order Component `Provider`, given to us by react-redux.  Provider will make our `store` availableable as a property to each of our components.  The documentation for Redux explains that you could accomplish a similar pattern by passing the store manually through your componenet properties, such as `<App store={store} />`.  However this would quickly become tedious, as we'l have many comonenets in our hierarchy that have no direct need of the store, however they'll still be responsible for passing the store through the properties of any child components they might render.  Provider, takes care of this for us somewhat automagically.

You'll notice I've also assigned our store to the Browser's `window` object.  This will make our store available to us in the Browser console, a step which I find very useful for testing purposes.

Now let's talk about reducers.  We said above that a reducer is a function that takes a state, and an action and returns a new state.  Before we look at that we should probably quickly discuss what an action, is.  Redux is built on the Fluz pattern, and therefore we'll be using Flux Standard Actions, or FSAs.  For berevity's sake, most people simply refer to them as actions.  But anaction is essentially an oject, which follows the pattern `{type: "SOME_KEY", some_data: "stuff"}`.  The type parameter is a unique name for the action inside of application, and tells our reducers whether or not they need to opperate on a dispatched action.

When we dispatch an action to our store, such as: `store.dispatch({type: "SOME_KEY", some_data: "stuff"})` the action gets passed to our reducer function, which will check the value of `type`, and respond as needed.  While it's possible to house all of our reducer logic in a single reducer function, the more common approach is to use a nested reducer structure, where one reducer opperates at the top level, and defers ownership of smaller areas of the states to nested reducer functions. In this way, we are able to create a separation of concerns with our application logic.  In our case this means we'l end up with dedicated reducers for our node state, our chapters state, perhaps our sections, maybe an area of user content... who knows.

When an action is dispatch it is passed to ALL of our nested reducers, and the `type` attribute dictates which reducers respond and how.

The action should also contain everything else in the payload (other attributes) that the reducer will need to accomplish the given action's intended mutation of the state. Our reducers will contain logic within them that reads the current state from our store, and then using the action payload, returns a **new** object for our application state.  Or if the action type is not relevant for that particular reducer, then the reducer will simly returns the current unaltered state.

Let's add an action to our Reducer.

``` javascript
import { createStore } from "redux";

let default_state = {nodes: []};

const store = createStore(
  function(state = default_state,action){
    switch (action.type) {
      case("LOAD_NODES"):
        return Object.assign({},state,
        { nodes: action.payload}
        );
      default:
        return state;
    }
  }
);

export default store;
```

Now our reducer has instructions on how to handle a new action type: "LOAD_NODES".  When this action is passed, we will use `Object.assign` to build a new state object.  The assign method will merge several objects into a new object; not that we pass an object literal as the first parameter to ensure we end this process with a **new** and not updated state object.  This is critical for React/Redux to correctly identify when the state has been update, and where.  Assign will then merge keys for the trailing objects passed as parameters, giving preference to the later members to of the attribute list whenkeys overlap.  

In our usage this gives us an easy way to overwrite all the stored nodes with a new array.

You'll also notice our function definition has changed to assign a default state by setting a default value for the state parameter of ourstore. This is one of the ways Redux gives us to instantiate our store with a default state.

Open up your Browser, and load your application.  Let's run some commands in the console.

``` javascript
store.getState();
store.dispatch({type: "LOAD_NODES", payload: [{id: 1, chapter_id: 1, content: "# Some Heading"}]})
store.getState();
store.dispatch({type: "SOME_ACTION", payload: "Somes stuff"})
store.getState();
```

Notice, on the first call to `store.getState()` that we see our default returned, including an empty array of nodes.  Then our first dispatched action, loads in an example node, and our state is updated to reflect this new array.  Then another action is dispatched; but the state comes back to us unaltered.  

That is the simplest representation I can give you of the reducer pattern; we opperate on what we understand and own, and ignore what we do not.