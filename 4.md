# Chapter 4: Organizing Data

Our next iteration divides across two chapters; the first deals with our API, while chapter 5 covers our corresponding React changes. We are creating a data storage layer on both our client and server to manage the content of our book.  We start with ActiveRecord, and creating models for our data; then on creating a Rake task to parse our Markdown content.   Let's get started.

## All Content is Not Created Equal

Currently, we handle all content as simple text blocks, but markdown hides nuance in its simple syntax.  Our chapters consist of blocks of text, code, lists, headings, tables, images, links, and other formats.  Our app is utterly blind to all of that.

We also have a document taxonomy to honor.  A book is not just a collection of random elements; we have an organizational structure we need to preserve; grouping our content into chapters, sections, and paragraphs.  In this iteration, we'll set up a database structure to support our content's organizational scheme, and provide metadata our client needs to render markdown in the browser.

## What's on (in) the Table?

Since we are only displaying one book, having a table to store that information seems overkill.  Chapters seem like a logical division, as do blocks of text. 

In our case, chapters are the individual MD files we parse.  Blocks are the top-level divisions in our markdown and carry a variety of different types that influence how they should render (code fences, paragraphs, lists, and so on).

Now let's consider the relationships between our elements: 
* A book has many chapters
    * A Chapter belongs to a book
    * A Chapter has many blocks
             * A block belongs to a chapter

We only need to represent two relationships in our tables.

* A Chapter has many sections
    * A block belongs to a section

We are abandoning the representation of books entirely.   We'll revisit the other relationships later if and when our application demands we support them.

Here's our plan for this iteration:
* Create tables for our new models
* Define relationships
* Change the import of our book from a controller action to a runnable task
* Modify our controller action to pass a JSON response ready for our client.

## Setting Up Tables

Let's start by getting some tables set up.  I prefer to do this using Rail's model generators, as they give us both a migration for our database setup, and a Class in our `models/` directory we can modify.

Let's not try to boil the ocean, and instead keep our stored data simple.  Run the following generator commands in your terminal from the API directory of your application.

``` bash
docker-compose exec api rails generate model Chapter title:string

docker-compose exec api  rails generate model Block chapter_id:integer type:string content:text

docker-compose exec api bin/rails db:migrate
```

Next o ahead and declare our relationships in your models.

``` ruby(/api/app/models/chapter.rb)
class Chapter < ApplicationRecord
  has_many :blocks
end
```

``` ruby(/api/app/models/block.rb)
class Block < ApplicationRecord
  belongs_to :chapter
end
```

Simple; now we can turn our attention to updating the way that we load content.

## Creating a Task

I admitted when we set up our `books#index` action that we were committing some sins.

Our controller action has no business parsing our book.   It is hugely inefficient to repeat work every time the action is triggered.  Now is our chance to clean up, migrating the work to a rake task we can run to load our database with content.

Rails provides a generator to produce rake tasks.  That generator takes the form: `rails generate task [namespace] [action] [...action]`

Try running the following in your terminal.

``` bash
docker-compose exec api rails generate task rr load_book clear_book
```

This generator creates two tasks:
`rails rr:load_book`
`rails rr:clear_book`

Open the generated task file.

```ruby()
```

Notice both tasks created depend on the `:environment` task.  This dependency makes the full environment of our Rails application available to us inside our tasks.  This setup allows us to do things like query and load data into our ActiveRecord models.

Before we write the task, let's migrate the importer classes we created in the last chapter.  We're going to relocate them to our `lib/` directory and modify them to load our database tables as we go.

``` ruby(/api/lib/loader/book_file_finder.rb)
class BookFileFinder
  attr_reader :entries
  
  def initialize(path)
     @path = normalize_folder(path) 
+     @entries = validate_chapters
  end
  
  private
-     def normalize_folder(path)
-       path[-1] == "/" ? path : path + "/"
-     end
    
-     def locate_chapter_files
-        raw_file_list = expand_file_paths(Dir.entries(@path))
-        filter_chapter_files(raw_file_list);
-     end

+ def validate_chapters
+   all_entries = locate_chapter_files.sort!
+   all_entries.delete_if do |file|
+     load_or_invalidate_chapter(file)
+   end
+ end
      
+ def load_or_invalidate_chapter(file)
+   invalid =  true
+   md_doc = CommonMarker.render_doc(File.read(file))
+   md_doc.each do |node|
+     if node.type == :header
+       invalid = false
+       Chapter.create(title: node.to_commonmark)
+       break
+     end
+   end
        
+   return invalid
+ end
    
-     def filter_chapter_files(raw_file_list)
-         raw_file_list.select do |file|
-             File.file?(file) && File.extname(file) == ".md" && !/readme\.md/i.match?(file)
-         end
-     end
    
-     def expand_file_paths(file_array)
-       file_array.map do |file|
-         @path + file
-       end
-     end
end
```

Look at our updated `BookFileFinder` class.  Storing these classes in `controllers/concerns/` was always temporary.  Now that we are tying them to a rake task, they can settle into their final destination in the `lib/` directory.

I am adding some business rules to our Chapters.  We are going to require that a file has at least 1 valid heading tag to be considered valid chapter. Moreover, we use the content of the first heading we find as the chapter title.

We pass each file through a new `validate_chapter` method.  Using the `delete_if` enumerator, we remove chapters that don't contain at least one heading node in the document's text.  When we find a valid chapter title, we create a new database record and break from our loop of the book's nodes.

Now let's write some logic into our Rake task.

``` ruby(/api/lib/tasks/rr.rake)
require "#{Rails.root}/lib/loader/book_file_finder"

namespace :rr do
  desc "Import content at lib/reactivating-rails/"
  task load_book: :environment do
    puts "Loading book content..."
    entries = BookFileFinder.new("#{Rails.root}/lib/reactivating-rails")
  end

  desc "Clear content of previously loaded iterations"
  task clear_book: :environment do
    puts "Clearing book content..."
  end
end
```

For a simple start to our `rr:load_book` task, we call our file finder class with our book's directory.  Go ahead and run the task using the following terminal command: `docker-compose exec api bin/rails rr:load_book`

There's not much to see, but if we open an IRB console session (`docker-compose run api bin/rails console`), we can query ActiveRecord to see our progress.  In your IRB console run `Chapter.last`.  You should see something like:

`id: 9, title: "Chapter 2: Loading and Displaying Basic Content\n", created_at: "2017-08-30 01:59:40", updated_at: "2017-08-30 01:59:40"`

Not bad, but we are not getting much feedback from our rake task as it runs.  I would prefer some reporting to my console to indicate where I should start digging if something goes awry.  I also think we are overreaching in our `BookFileFinder` class now.  The validation of a chapter is not an easy read, and that is probably a sign we are doing too much in one class.

Let's move the Chapter validation into a class of its own:

``` ruby(/api/lib/loader/chapter_file.rb)
class ChapterFile
  attr_reader :title, :body, :record
  
  def initialize(file)
    @file_path = file
    @body = CommonMarker.render_doc(File.read(file))
  end
  
  public
    def save
      unless self.invalid?
        puts "Creating chapter: #{@record.title}"
        @record.save
      end
    end
    
    def invalid?
      @body.each do |node|
        if node.type == :header
          @record = Chapter.new(title: node.to_plaintext.strip)
          return false
        end
      end
      puts "#{@file_path} removed as invalid chapter; ensure file has at least one heading."
      return true
    end
end
```

We're creating two public methods for this class: `save` and `invalid?`. 

Our `invalid?` method traverses the node map of our markdown, setting up an unsaved Chapter instance upon finding a heading suitable as a chapter title.  If no heading nodes are present, the method returns true to signal removal of the file from our list of entries.

The `save` logic become a standalone method so we can be deliberate about when that save happens in the context of our Rake task.

We're also creating several attribute readers as an interface to several levels of our markdown:
* `:body`, which contains the full text of the chapter
* `:title`, to store our assigned title.
* And `:record`, which stores our Active Record model instance.  
 

Keeping the record  Active Record instance available will all us to use method chaining such as `chapter.block.create`, rather than passing IDs around when creating our blocks. 

Now we can update our Rake task to use this new class.

``` ruby(/api/lib/tasks/rr.rake)
task load_book: :environment do
    puts "Loading book content..."
    entries = BookFileFinder.new("#{Rails.root}/lib/reactivating-rails").entries
    
    entries.delete_if do |file|
      ChapterFile.new(file).invalid?
    end
    
    entries.each do |file|
      chapter = ChapterFile.new(file)
      chapter.save
    end
  end
```

We are splitting our work with the `ChapterFiles` class into two iterations through the collection:  
 1. Using `delete_if`, remove any invalid chapter instances.
 2. Then we pass through the remainder to save the valid files.

This configuration bears the inefficiency of running our validation twice for the valid chapters.  However, in trade, we get clean, clear ruby in our task.  I am willing to make that trade in a task run so infrequently.

Now, remove our Chapter validation from the `BookFileFinder` class.

``` ruby(/api/lib/loader/book_file_finder.rb)
class BookFileFinder
  attr_reader :entries
  
  def initialize(path)
     @path = normalize_folder(path) 
     @entries = locate_chapter_files.sort_by! {|x| File.basename(x,".md").to_i}
  end
  
  private
    def normalize_folder(path)
      path[-1] == "/" ? path : path + "/"
    end
    
    def locate_chapter_files
       raw_file_list = expand_file_paths(Dir.entries(@path))
       filter_chapter_files(raw_file_list);
    end
    
    def filter_chapter_files(raw_file_list)
        raw_file_list.select do |file|
            File.file?(file) && File.extname(file) == ".md" && !/readme\.md/i.match?(file)
        end
    end
    
    def expand_file_paths(file_array)
      #Array.map allows us to iterate through the array
      # Here we update each member by concatenating the directory path onto the file name
      file_array.map do |file|
        @path + file
      end
    end
end
```
Let's check in and run our rake task, `bin/rails rr:load_book`

``` bash
Creating chapter: Chapter 0: Introduction
Creating chapter: Chapter 1: Installing React and Rails
Creating chapter: Chapter 2: Loading and Displaying Basic Content
```

If you check out your database in the Rails console, you should see a Chapter record created for each chapter file.

The next step for us to tackle is parsing our blocks.  Seeing as we already loop our Chapters for our `chapter.save` call, our work should be trivial.

``` ruby(/api/lib/tasks/rr.rake)
task load_book: :environment do
  puts "Loading book content..."
  entries = BookFileFinder.new("#{Rails.root}/lib/reactivating-rails").entries
  
  entries.delete_if do |file|
    ChapterFile.new(file).invalid?
  end
  
  entries.each do |file|
    chapter = ChapterFile.new(file)
    chapter.save
    
+     chapter.body.each do |node|
+       chapter.record.blocks.create(type: node.type.to_s, content: node.to_commonmark)
+     end
  end
end
```

However, we have a problem.  It seems I stumbled into a reserved word when I selected `type` as a column name.  We need to change that before moving forward.  Since we are running a migration anyhow, it has also been bothering me that I chose the model name `Blocks`, while `CommonMarker` refers to this element as a `node`.  I would like to unify on one term, so let's take this opportunity to rename our table as well.

`bin/rails generate migration rename_table_block_as_node`

``` ruby(/api/db/migrate/[stamp]_rename_table_block_as_node.rb)
class RenameTableBlockAsNode < ActiveRecord::Migration[5.1]
  def change
    rename_table :blocks, :nodes
    rename_column :nodes, :type, :node_type
  end
end
```

Run the migration (`bin/rails db:migrate`), and be sure to update your `Blocks` model name, file name, spec name, and association in the `Chapters` model (to `has_many :nodes`).

Finally, update your rake task:

``` ruby
task load_book: :environment do
  puts "Loading book content..."
  entries = BookFileFinder.new("#{Rails.root}/lib/reactivating-rails").entries
  
  entries.delete_if do |file|
    ChapterFile.new(file).invalid?
  end
  
  entries.each do |file|
    chapter = ChapterFile.new(file)
    chapter.save
    
    chapter.body.each do |node|
+       chapter.record.nodes.create(node_type: node.type.to_s, content: node.to_commonmark)
    end
  end
end
```

Execute your task again, and open an IRB console.  You should now see populated `Node` and `Chapter` tables.

I am going to delay implementing the other Rake task we generated, `rr:clear_book`.  We can skimp by using the default Rails task `bin/rails db:reset`, which clears all our tables, and reset our indexes to zero.  As we add more models to our application purging the entire database might become untenable.  For now though, it meets our needs.  

If you have run the `rr:load_book` task several times this iteration, you might want to run `db:reset` and then `rr:load_book`  again before moving forward to ensure you have clean data.

## Testing Our Importer

Before moving on, let's brush-up our test suite.

Our tests should be green, but new business rules for chapter creation need test coverage.  Let's add a new document to our `testbook/` directory.  Name the file `invalidChapter.md`, and put a bit of sample text inside.

``` markdown(/api/spec/lib/testbook/invalidChapter.md)
Chapter.invalid? should return true when evaluating this file as it contains no valid headings to serve as the chapter title.
```

I'm also going to move `book_file_finder_spec.rb` , `book_file_parse_spec.rb`, and their associated `testbook/` directory into a `spec/lib/` folder to mirror our restructured `app/` directory.

If we rerun the spec now, we get a failure on our test `BookFileFinder removes readme.md, directories, and non-md files from return`.  Our file finder only concerns itself with the initial validation of the file as markdown and ensuring that the file is not a directory or README.

Go ahead and update each spec as follows:

``` ruby(/api/spec/lib/book_file_finder_spec.rb)
require 'rails_helper'
require 'loader/book_file_finder'

RSpec.describe BookFileFinder do
  it "removes readme.md, directories, and non-md files from return" do
+     path = "spec/lib/testbook/"
    entries = BookFileFinder.new(path).entries
+     expect(entries.length).to eq 2
    expect(entries[0]).to eq path+"mockChapter.md"
  end
  
  it "enforces proper file path" do
+     path = "spec/lib/testbook/"
+     bad_path = "spec/lib/testbook"
    expect(BookFileFinder.new(path).entries).to eq BookFileFinder.new(bad_path).entries
  end
end
```

``` ruby(/api/spec/lib/book_file_parse_spec.rb)
require 'rails_helper'
require 'loader/book_file_parser'

RSpec.describe BookFileParser do
  it "creates payload of top level blocks from array of MD files" do
+     payload = BookFileParser.new(["spec/lib/testbook/mockChapter.md"]).payload
    expect(payload.length).to eq 13
  end
end
```

We're now green except for pending tests generated for our models.  Leave these be for now; there's no need to test our current minimalist implementation.

However, let's add a spec for our chapter parser.

``` ruby(/api/spec/lib/chapter_file_spec.rb)
require 'rails_helper'
require 'loader/chapter_file.rb'

RSpec.describe ChapterFile do
  it "invalidates chapters without titles/headings" do
    chapter_test = ChapterFile.new("spec/lib/testbook/invalidChapter.md").invalid?
    expect(chapter_test).to be_truthy
  end
  
  describe "valid chapters" do
    before(:each) do
      @chapter = chapter = ChapterFile.new("spec/lib/testbook/mockChapter.md")
    end
    
    it "have headings/titles" do
      expect(@chapter.invalid?).to be_falsey
    end
    
    it "create model instances when saved." do
      @chapter.save
      expect(Chapter.all.count).to eq(1)
    end
  end
end
```

With our rake task in place, let's update our controller action to prepare it for working with our client-side data store (Redux).

## Fluxifying your Controller Actions

We need to put the cart before the horse for a minute and talk about Flux.

If you are not familiar, Flux is the data pattern underlying Redux.  In the simplest terms, Flux is a principle of unidirectional data flow.  Redux enforces this pattern by encapsulating all state changes in instructions that get passed to our data store called Flux Standard Actions (FSA), or usually just "actions" for short.

An action is an object that contains a type attribute, and a payload of other information required to perform the requested state change.  For example, `{type: "SOME_KEY", payload: {data: "stuff"}}`

These actions pass through a series of functions called reducers, which manage transformations of our application's state.
1. An action gets dispatched to the store.  
2. The store checks to see if it knows how to respond to the action key specified in the `type` attribute of the action.
  * If it does, the reducer creates a new state object for the store.
  * If it does not, the state persists unaltered

Down the chain, our React components subscribe to this application state.  When the state changes, the components rerender and the screen redraws as needed.

All that is to say, our controller actions should follow this pattern, and push back data easily composed into actions for our store.

We're close already, but there are a few things we can do to make this easier.

## Scoping our Model data

First, let's create a scope in our model that we can use to limit our queries.

Rails automatically generates default columns that we don't need in our client.  Fields such as `created_at`, and `updated_at` don't have much to offer us.

We can also use Active Record to enforce some conventions like sort order.    We might still reinforce this order on the client as well in cases where it is critical, but ActiveRecord makes sorting so easy, it seems a shame not to take advantage.

Let's open our `Node` model and add a scope.

``` ruby 
- # == Schema Information
- #
- # Table name: nodes
- #
- #  id         :integer          not null, primary key
- #  chapter_id :integer
- #  node_type  :string
- #  content    :text
- #  created_at :datetime         not null
- #  updated_at :datetime         not null
- #

class Node < ApplicationRecord
  belongs_to :chapter
  
+   scope :fsa, -> { order(chapter_id: :asc, id: :asc ).select(:id, :chapter_id, :node_type, :content) }
end
```

We are creating a scope called `:fsa` for our model to prepare data for our client.  First enforcing our content order: chapters first, and then the nodes within.  Then limiting the columns selected to those we need.

Open the console, and try it out by running `Nodes.all.fsa`.  You should get back a response like the following:

``` bash
[#<Node id: 6, chapter_id: 1, node_type: "paragraph", content: "I'm also hoping this exercise will help me develop...">, #<Node id: 7, chapter_id: 1, node_type: "header", content: "## So, what are we building?\n">, #<Node id: 8, chapter_id: 1, node_type: "paragraph", content: "Together (In a non-linear timey-wimey sense), we a...">, #<Node id: 9, chapter_id: 1, node_type: "paragraph", content: "Why? A few reasons... First, I enjoy the easy synt...">, #<Node id: 10, chapter_id: 1, node_type: "paragraph", content: "There's also the small detail that I'm embarking o...">, ...]
```

Now update our controller action.  Rename your controller from `books` to `nodes` to account for its new focus.  (Don't forget to update your routes and file names as well to account for this renamed controller.)

``` ruby(/api/app/controllers/api/nodes_controller.rb)
class Api::NodesController < ApplicationController
  def index
+     payload = Node.all.fsa
+     render json: payload, status: 200
  end
end
```

We are using our `fsa` scope to prepare data for use in our Flux actions.  The last step in preparation is calling our render method with the JSON key.  This key helps us by automatically converting our payload of nodes into an array of objects (a format which is very easy for our client to digest).

I favor this approach because our scope supplies us with a centralized location where we can update the content of our Flux actions.  As we build, if we decide we need to expand our Node's provided attributes, updating this scope does so across our entire application.

## Wrapping Up

This chapter we have:
* Migrated our book importer into a Rake Task
* Setup our first database tables and associations
* Transformed our controller action to be ready for use in Flux Standard actions (FSA)

We are going to stop there and turn to our client application in our next chapter.  In Chapter 5 we setup Redux to serve as our client-side data store and create our first actions to load data from our API.

Now, let's into dig into Redux!
